{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///external {\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\",\"root\":\"BABYLON\"}","webpack:///./src/CharacterController.ts"],"names":["root","factory","exports","module","require","define","amd","a","i","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","avatar","camera","scene","agMap","faceForward","_walkSpeed","_runSpeed","this","_backSpeed","_jumpSpeed","_leftSpeed","_rightSpeed","_turnSpeed","Math","PI","_gravity","_minSlopeLimit","_maxSlopeLimit","_sl","_sl2","_stepOffset","_vMoveTot","_vMovStartPos","_walk","AnimData","_walkBack","_idle","_idleJump","_run","_runJump","_fall","_turnLeft","_turnRight","_strafeLeft","_strafeRight","_slideBack","_anims","_walkKey","_walkBackKey","_turnLeftKey","_turnRightKey","_strafeLeftKey","_strafeRightKey","_jumpKey","_walkCode","_walkBackCode","_turnLeftCode","_turnRightCode","_strafeLeftCode","_strafeRightCode","_jumpCode","_elasticCamera","_cameraTarget","_noFirstPerson","_saveMode","_isRHS","_signRHS","_faceForward","_started","_stopAnim","_prevAnim","_avStartPos","_grounded","_freeFallDist","_fallFrameCountMin","_fallFrameCount","_inFreeFall","_wasWalking","_wasRunning","_jumpStartPosY","_jumpTime","_movFallTime","_sign","_turnedBack","_turnedForward","_degree270","_idleFallTime","_groundFrameCount","_groundFrameMax","_savedCameraCollision","_inFP","_ray","Zero","One","_rayDir","_cameraSkin","_skip","_move","_isAG","_hasAnims","_avatar","_setRHS","setFaceForward","_scene","setAnimationGroups","_skeleton","skeleton","checkAnims","_camera","checkCollisions","_act","Action","_renderer","_moveAVandCamera","_handleKeyUp","e","_onKeyUp","_handleKeyDown","_onKeyDown","addEventListener","setAvatar","setAvatarSkeleton","setSlopeLimit","minSlopeLimit","maxSlopeLimit","setStepOffset","stepOffset","setWalkSpeed","setRunSpeed","setBackSpeed","setJumpSpeed","setLeftSpeed","setRightSpeed","setTurnSpeed","setGravity","anim","ag","exist","setAnimationRanges","arMap","arData","loop","setAnim","rangeName","rate","speedRatio","getAnimationRange","enableBlending","targetedAnimations","ta","animation","blendingSpeed","disableBlending","setWalkAnim","setRunAnim","setWalkBackAnim","setSlideBackAnim","setIdleAnim","setTurnRightAnim","setTurnLeftAnim","setStrafeRightAnim","setSrafeLeftAnim","setIdleJumpAnim","setRunJumpAnim","setFallAnim","setWalkKey","setWalkBackKey","setTurnLeftKey","setTurnRightKey","setStrafeLeftKey","setStrafeRightKey","setJumpKey","setWalkCode","code","setWalkBackCode","setTurnLeftCode","setTurnRightCode","setStrafeLeftCode","setStrafeRightCode","setJumpCode","setCameraElasticity","b","setCameraTarget","v","copyFrom","cameraCollisionChanged","setNoFirstPerson","skel","setMode","mesh","meshMatrix","getWorldMatrix","_localX","FromFloatArray","_localY","_localZ","actualZ","Cross","Dot","checkAGs","start","reset","_updateTargetValue","registerBeforeRender","stop","unregisterBeforeRender","removeEventListener","pauseAnim","resumeAnim","_isAvFacingCamera","forward","position","subtract","dt","getEngine","getDeltaTime","jump","_doJump","anyMovement","_doMove","_doIdle","play","beginAnimation","y","jumpDist","disp","forwardDist","rotation","alpha","_moveVector","clone","normalize","scaleToRef","moveWithCollisions","length","_endJump","actDisp","_areVectorsEqual","_verticalSlope","v1","v2","abs","x","z","atan","sqrt","u","moving","shift","calcMovePOV","backward","stepLeft","stepRight","turnLeft","turnRight","prevName","_endFreeFall","_groundIt","_unGroundIt","addToRef","target","radius","lowerRadiusLimit","_snapCamera","visibility","subtractToRef","origin","direction","pi","pickWithRay","hit","newPos","pickedPoint","scale","nr","keyCode","chr","String","fromCharCode","disableKeyBoard","enableKeyBoard","walk","walkBack","run","strafeLeft","strafeRight","idle"],"mappings":"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","file":"CharacterController.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"babylonjs\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"babylonjs\")) : factory(root[\"BABYLON\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import {\r\n    Skeleton,\r\n    ArcRotateCamera,\r\n    Vector3,\r\n    Mesh,\r\n    Scene,\r\n    Ray,\r\n    PickingInfo,\r\n    AnimationGroup,\r\n    TransformNode,\r\n    Matrix\r\n} from \"babylonjs\"\r\n\r\nexport class CharacterController {\r\n\r\n    private _avatar: Mesh;\r\n    private _skeleton: Skeleton;\r\n    private _camera: ArcRotateCamera;\r\n    private _scene: Scene;\r\n\r\n    //avatar speed in meters/second\r\n    private _walkSpeed: number = 3;\r\n    private _runSpeed: number = this._walkSpeed * 2;\r\n    private _backSpeed: number = this._walkSpeed / 2;\r\n    private _jumpSpeed: number = this._walkSpeed * 2;\r\n    private _leftSpeed: number = this._walkSpeed / 2;\r\n    private _rightSpeed: number = this._walkSpeed / 2;\r\n    //trun speed in radian per second (equivalent to 180 degree/second by default)\r\n    private _turnSpeed: number = Math.PI;\r\n    private _gravity: number = 9.8;\r\n    //slopeLimit in degrees\r\n    private _minSlopeLimit: number = 30;\r\n    private _maxSlopeLimit: number = 45;\r\n    //slopeLimit in radians\r\n    private _sl: number = Math.PI * this._minSlopeLimit / 180;\r\n    private _sl2: number = Math.PI * this._maxSlopeLimit / 180;\r\n\r\n    //The av will step up a stair only if it is closer to the ground than the indicated value.\r\n    private _stepOffset: number = 0.25;\r\n    //toal amount by which the av has moved up\r\n    private _vMoveTot: number = 0;\r\n    //position of av when it started moving up\r\n    private _vMovStartPos: Vector3 = new Vector3(0, 0, 0);\r\n\r\n    //animations\r\n    private _walk: AnimData = new AnimData(\"walk\");\r\n    private _walkBack: AnimData = new AnimData(\"walkBack\");\r\n    private _idle: AnimData = new AnimData(\"idle\");\r\n    private _idleJump: AnimData = new AnimData(\"idleJump\");\r\n    private _run: AnimData = new AnimData(\"run\");\r\n    private _runJump: AnimData = new AnimData(\"runJump\");\r\n    private _fall: AnimData = new AnimData(\"fall\");\r\n    private _turnLeft: AnimData = new AnimData(\"turnLeft\");\r\n    private _turnRight: AnimData = new AnimData(\"turnRight\");\r\n    private _strafeLeft: AnimData = new AnimData(\"strafeLeft\");\r\n    private _strafeRight: AnimData = new AnimData(\"strafeRight\");\r\n    private _slideBack: AnimData = new AnimData(\"slideBack\");\r\n\r\n    private _anims: AnimData[] = [this._walk, this._walkBack, this._idle, this._idleJump, this._run, this._runJump, this._fall, this._turnLeft, this._turnRight, this._strafeLeft, this._strafeRight, this._slideBack];\r\n\r\n    //move keys\r\n    private _walkKey: string = \"W\";\r\n    private _walkBackKey: string = \"S\";\r\n    private _turnLeftKey: string = \"A\";\r\n    private _turnRightKey: string = \"D\";\r\n    private _strafeLeftKey: string = \"Q\";\r\n    private _strafeRightKey: string = \"E\";\r\n    private _jumpKey: string = \"32\";\r\n    private _walkCode: number = 38;\r\n    private _walkBackCode: number = 40;\r\n    private _turnLeftCode: number = 37;\r\n    private _turnRightCode: number = 39;\r\n    private _strafeLeftCode: number = 0;\r\n    private _strafeRightCode: number = 0;\r\n    private _jumpCode: number = 32;\r\n\r\n    private _elasticCamera: boolean = true;\r\n    private _cameraTarget: Vector3 = new Vector3(0, 0, 0);\r\n    //should we go into first person view when camera is near avatar (radius is lowerradius limit)\r\n    private _noFirstPerson: boolean = false;\r\n\r\n    public setAvatar(avatar: Mesh) {\r\n        this._avatar = avatar;\r\n    }\r\n\r\n    public setAvatarSkeleton(skeleton: Skeleton) {\r\n        this._skeleton = skeleton;\r\n        this.checkAnims(skeleton);\r\n    }\r\n\r\n    public setSlopeLimit(minSlopeLimit: number, maxSlopeLimit: number) {\r\n        this._minSlopeLimit = minSlopeLimit;\r\n        this._maxSlopeLimit = maxSlopeLimit;\r\n\r\n        this._sl = Math.PI * minSlopeLimit / 180;\r\n        this._sl2 = Math.PI * this._maxSlopeLimit / 180;\r\n    }\r\n\r\n    /**\r\n     * The av will step up a stair only if it is closer to the ground than the indicated value.\r\n     * Default value is 0.25 m\r\n     */\r\n    public setStepOffset(stepOffset: number) {\r\n        this._stepOffset = stepOffset;\r\n    }\r\n\r\n    public setWalkSpeed(n: number) {\r\n        this._walkSpeed = n;\r\n    }\r\n    public setRunSpeed(n: number) {\r\n        this._runSpeed = n;\r\n    }\r\n    public setBackSpeed(n: number) {\r\n        this._backSpeed = n;\r\n    }\r\n    public setJumpSpeed(n: number) {\r\n        this._jumpSpeed = n;\r\n    }\r\n    public setLeftSpeed(n: number) {\r\n        this._leftSpeed = n;\r\n    }\r\n    public setRightSpeed(n: number) {\r\n        this._rightSpeed = n;\r\n    }\r\n    // get turnSpeed in degrees per second.\r\n    // store in radians per second\r\n    public setTurnSpeed(n: number) {\r\n        this._turnSpeed = n * Math.PI / 180;\r\n    }\r\n    public setGravity(n: number) {\r\n        this._gravity = n;\r\n    }\r\n\r\n    /**\r\n     * Use this to provide animationGroups to the character controller.\r\n     * Provide the AnimationGroups using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animationGroup.\r\n     * Example:\r\n     * let myWalkAnimationGroup:AnimationGroup = ...;\r\n     * let agMap:{} = {\r\n     *  \"walk\":myWalkAnimationGroup,\r\n     *   ....\r\n     * }\r\n     * \r\n     * @param agMap a map of character controller animation name to animationGroup\r\n     */\r\n    public setAnimationGroups(agMap: {}) {\r\n        this._isAG = true;\r\n        for (let anim of this._anims) {\r\n            if (agMap[anim.name] != null) {\r\n                anim.ag = agMap[anim.name];\r\n                anim.exist = true;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Use this to provide AnimationRanges to the character controller.\r\n     * Provide the AnimationRanges using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animation range name or an object with animation range data.\r\n     * example:\r\n     * let arMap = {\r\n     *  \"walk\":\"myWalk\",\r\n     *  \"run\" : {\"name\":\"myRun\",\"rate\":1},\r\n     *  \"idle\" : {\"name\":\"myIdle\",\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     * }\r\n     * \r\n     * @param arMap a map of character controller animation name to animationRange data\r\n     */\r\n\r\n    public setAnimationRanges(arMap: {}) {\r\n        this._isAG = false;\r\n        let arData: string | {};\r\n        for (let anim of this._anims) {\r\n            arData = arMap[anim.name];\r\n            if (arData != null) {\r\n                if (arData instanceof Object) {\r\n                    if (arData[\"name\"]) anim.name = arData[\"name\"];\r\n                    if (arData[\"loop\"]) anim.loop = arData[\"loop\"];\r\n                    if (arData[\"rate\"]) anim.loop = arData[\"rate\"];\r\n                } else {\r\n                    anim.name = arData;\r\n                }\r\n                anim.exist = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private setAnim(anim: AnimData, rangeName?: string | AnimationGroup, rate?: number, loop?: boolean) {\r\n        if (!this._isAG && this._skeleton == null) return;\r\n        if (loop != null) anim.loop = loop;\r\n        if (!this._isAG) {\r\n            if (rangeName != null) anim.name = <string>rangeName;\r\n            if (rate != null) anim.rate = rate;\r\n            if (this._skeleton.getAnimationRange(anim.name) != null) {\r\n                anim.exist = true;\r\n            } else {\r\n                anim.exist = false;\r\n            }\r\n        } else {\r\n            if (rangeName != null) {\r\n                anim.ag = <AnimationGroup>rangeName;\r\n                anim.exist = true;\r\n            }\r\n            if (rate != null && anim.exist) {\r\n                anim.rate = rate;\r\n                anim.ag.speedRatio = rate;\r\n            }\r\n        }\r\n    }\r\n\r\n    public enableBlending(n: number) {\r\n        if (this._isAG) {\r\n            for (let anim of this._anims) {\r\n                if (anim.exist) {\r\n                    let ar: AnimationGroup = anim.ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = true;\r\n                        ta.animation.blendingSpeed = n;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            this._skeleton.enableBlending(n);\r\n        }\r\n    }\r\n\r\n    public disableBlending() {\r\n        if (this._isAG) {\r\n            for (let anim of this._anims) {\r\n                if (anim.exist) {\r\n                    let ar: AnimationGroup = anim.ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //setters for animations\r\n    public setWalkAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._walk, rangeName, rate, loop);\r\n    }\r\n    public setRunAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._run, rangeName, rate, loop);\r\n    }\r\n    public setWalkBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._walkBack, rangeName, rate, loop);\r\n    }\r\n    public setSlideBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._slideBack, rangeName, rate, loop);\r\n    }\r\n    public setIdleAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._idle, rangeName, rate, loop);\r\n    }\r\n    public setTurnRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._turnRight, rangeName, rate, loop);\r\n    }\r\n    public setTurnLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._turnLeft, rangeName, rate, loop);\r\n    }\r\n    public setStrafeRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._strafeRight, rangeName, rate, loop);\r\n    }\r\n    public setSrafeLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._strafeLeft, rangeName, rate, loop);\r\n    }\r\n    public setIdleJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._idleJump, rangeName, rate, loop);\r\n    }\r\n    public setRunJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._runJump, rangeName, rate, loop);\r\n    }\r\n    public setFallAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._fall, rangeName, rate, loop);\r\n    }\r\n\r\n    // setters for keys\r\n    public setWalkKey(key: string) {\r\n        this._walkKey = key\r\n    }\r\n    public setWalkBackKey(key: string) {\r\n        this._walkBackKey = key\r\n    }\r\n    public setTurnLeftKey(key: string) {\r\n        this._turnLeftKey = key\r\n    }\r\n    public setTurnRightKey(key: string) {\r\n        this._turnRightKey = key\r\n    }\r\n    public setStrafeLeftKey(key: string) {\r\n        this._strafeLeftKey = key\r\n    }\r\n    public setStrafeRightKey(key: string) {\r\n        this._strafeRightKey = key\r\n    }\r\n    public setJumpKey(key: string) {\r\n        this._jumpKey = key\r\n    }\r\n\r\n    public setWalkCode(code: number) {\r\n        this._walkCode = code\r\n    }\r\n    public setWalkBackCode(code: number) {\r\n        this._walkBackCode = code\r\n    }\r\n    public setTurnLeftCode(code: number) {\r\n        this._turnLeftCode = code\r\n    }\r\n    public setTurnRightCode(code: number) {\r\n        this._turnRightCode = code\r\n    }\r\n    public setStrafeLeftCode(code: number) {\r\n        this._strafeLeftCode = code\r\n    }\r\n    public setStrafeRightCode(code: number) {\r\n        this._strafeRightCode = code\r\n    }\r\n    public setJumpCode(code: number) {\r\n        this._jumpCode = code\r\n    }\r\n\r\n    public setCameraElasticity(b: boolean) {\r\n        this._elasticCamera = b;\r\n    }\r\n    public setCameraTarget(v: Vector3) {\r\n        this._cameraTarget.copyFrom(v);\r\n    }\r\n    /**\r\n     * user should call this whenever the user changes the camera checkCollision \r\n     * property\r\n     * \r\n     */\r\n    public cameraCollisionChanged() {\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n    }\r\n    public setNoFirstPerson(b: boolean) {\r\n        this._noFirstPerson = b;\r\n    }\r\n\r\n\r\n    private checkAnims(skel: Skeleton) {\r\n        for (let anim of this._anims) {\r\n            if (skel != null) {\r\n                if (skel.getAnimationRange(anim.name) != null) anim.exist = true;\r\n            } else {\r\n                anim.exist = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use this to make the  character controller suitable for a isometeric/top down games or  fps/third person game.\r\n     * 1 In isometric/top down games the camera direction has no bearing on avatar movement.\r\n     * 0 In fps/third person game rotating the camera around the avatar , rotates the avatr too.\r\n     */\r\n    private mode = 0;\r\n    private _saveMode = 0;\r\n    public setMode(n: number) {\r\n        this.mode = n;\r\n        this._saveMode = n;\r\n    }\r\n\r\n\r\n    /**\r\n        * checks if a have left hand , right hand issue.\r\n        * In other words if a mesh is a LHS mesh in RHS system or \r\n        * a RHS mesh in LHS system\r\n        * The X axis will be reversed in such cases.\r\n        * thus Cross product of X and Y should be inverse of Z.\r\n        * \r\n        * BABYLONJS GLB models are RHS and exhibit this behavior\r\n        * \r\n        */\r\n    private _isRHS = false;\r\n    private _signRHS = -1;\r\n    private _setRHS(mesh: TransformNode) {\r\n\r\n        let meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        let _localX = Vector3.FromFloatArray(meshMatrix.m, 0);\r\n        let _localY = Vector3.FromFloatArray(meshMatrix.m, 4);\r\n        let _localZ = Vector3.FromFloatArray(meshMatrix.m, 8);\r\n\r\n        let actualZ = Vector3.Cross(_localX, _localY);\r\n        //same direction or opposite direction of Z\r\n        if (Vector3.Dot(actualZ, _localZ) < 0) {\r\n            this._isRHS = true;\r\n            this._signRHS = 1;\r\n        }\r\n        else {\r\n            this._isRHS = false;\r\n            this._signRHS = -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use setFaceForward(true|false) to indicate that the avatar face  faces forward (true) or backward (false).\r\n     * The avatar face faces forward if its face points to positive local Z axis direction\r\n     */\r\n    private _faceForward = -1;\r\n    public setFaceForward(b: boolean) {\r\n        b ? this._faceForward = -1 : 1;\r\n        if (this._isRHS && b) {\r\n            this._degree270 = - this._degree270;\r\n            this._faceForward = 1;\r\n        }\r\n    }\r\n\r\n    private checkAGs(agMap: {}) {\r\n        for (let anim of this._anims) {\r\n            if (agMap[anim.name] != null) {\r\n                anim.ag = agMap[anim.name];\r\n                anim.exist = true;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    private _started: boolean = false;\r\n    public start() {\r\n        if (this._started) return;\r\n        this._started = true;\r\n        this._act.reset();\r\n        this._movFallTime = 0;\r\n        //first time we enter render loop, delta time is zero\r\n        this._idleFallTime = 0.001;\r\n        this._grounded = false;\r\n        this._updateTargetValue();\r\n\r\n        window.addEventListener(\"keyup\", this._handleKeyUp, false);\r\n        window.addEventListener(\"keydown\", this._handleKeyDown, false);\r\n\r\n        this._scene.registerBeforeRender(this._renderer);\r\n        this._scene\r\n    }\r\n\r\n    public stop() {\r\n        if (!this._started) return;\r\n        this._started = false;\r\n        this._scene.unregisterBeforeRender(this._renderer);\r\n        window.removeEventListener(\"keyup\", this._handleKeyUp, false);\r\n        window.removeEventListener(\"keydown\", this._handleKeyDown, false);\r\n\r\n        this._prevAnim = null;\r\n    }\r\n\r\n    /**\r\n     * use pauseAnim to stop the charactere controller from playing\r\n     * any animation on the character\r\n     * use this when you want to play your animation instead\r\n     * see also resumeAnim()\r\n     */\r\n    private _stopAnim: boolean = false;\r\n    public pauseAnim() {\r\n        this._stopAnim = true;\r\n    }\r\n\r\n    /**\r\n     * use resumeAnim to resume the character controller playing\r\n     * animations on the character.\r\n     * see also pauseAnim()\r\n     */\r\n    public resumeAnim() {\r\n        this._stopAnim = false;\r\n    }\r\n\r\n    private _prevAnim: AnimData = null;\r\n\r\n    private _avStartPos: Vector3 = new Vector3(0, 0, 0);\r\n    private _grounded: boolean = false;\r\n    //distance by which AV would move down if in freefall\r\n    private _freeFallDist: number = 0;\r\n\r\n    //how many minimum contiguos frames should the AV have been in free fall\r\n    //before we assume AV is in big freefall.\r\n    //we will use this to remove animation flicker during move down a slope (fall, move, fall move etc)\r\n    //TODO: base this on slope - large slope large count\r\n    private _fallFrameCountMin: number = 50;\r\n    private _fallFrameCount: number = 0;\r\n\r\n    private _inFreeFall: boolean = false;\r\n    private _wasWalking: boolean = false;\r\n    private _wasRunning: boolean = false;\r\n    private _moveVector: Vector3;\r\n\r\n    //used only in mode 1\r\n    //value 1 or -1 , -1 if avatar is facing camera\r\n    //private _notFacingCamera = 1;\r\n\r\n    private _isAvFacingCamera(): number {\r\n        if (Vector3.Dot(this._avatar.forward, this._avatar.position.subtract(this._camera.position)) < 0) return 1\r\n        else return -1;\r\n    }\r\n\r\n    private _moveAVandCamera() {\r\n        this._avStartPos.copyFrom(this._avatar.position);\r\n        let anim: AnimData = null;\r\n        let dt: number = this._scene.getEngine().getDeltaTime() / 1000;\r\n\r\n        if (this._act.jump && !this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            anim = this._doJump(dt);\r\n        } else if (this.anyMovement() || this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            anim = this._doMove(dt);\r\n        } else if (!this._inFreeFall) {\r\n\r\n            anim = this._doIdle(dt);\r\n        }\r\n        if (!this._stopAnim && this._hasAnims && anim != null) {\r\n            if (this._prevAnim !== anim) {\r\n                if (anim.exist) {\r\n                    if (this._isAG) {\r\n                        if (this._prevAnim != null && this._prevAnim.exist) this._prevAnim.ag.stop();\r\n                        anim.ag.play(anim.loop);\r\n                    } else {\r\n                        this._skeleton.beginAnimation(anim.name, anim.loop, anim.rate);\r\n                    }\r\n                }\r\n                this._prevAnim = anim;\r\n            }\r\n        }\r\n        this._updateTargetValue();\r\n        return;\r\n    }\r\n\r\n    //verical position of AV when it is about to start a jump\r\n    private _jumpStartPosY: number = 0;\r\n    //for how long the AV has been in the jump\r\n    private _jumpTime: number = 0;\r\n    private _doJump(dt: number): AnimData {\r\n\r\n        let anim: AnimData = null;\r\n        anim = this._runJump;\r\n        if (this._jumpTime === 0) {\r\n            this._jumpStartPosY = this._avatar.position.y;\r\n        }\r\n        //up velocity at the begining of the lastt frame (v=u+at)\r\n        let js: number = this._jumpSpeed - this._gravity * this._jumpTime;\r\n        //distance travelled up since last frame to this frame (s=ut+1/2*at^2)\r\n        let jumpDist: number = js * dt - 0.5 * this._gravity * dt * dt;\r\n        this._jumpTime = this._jumpTime + dt;\r\n\r\n        let forwardDist: number = 0;\r\n        let disp: Vector3;\r\n        if (this.mode != 1) this._avatar.rotation.y = this._degree270 - this._camera.alpha;\r\n        if (this._wasRunning || this._wasWalking) {\r\n            if (this._wasRunning) {\r\n                forwardDist = this._runSpeed * dt;\r\n            } else if (this._wasWalking) {\r\n                forwardDist = this._walkSpeed * dt;\r\n            }\r\n            //find out in which horizontal direction the AV was moving when it started the jump\r\n            disp = this._moveVector.clone();\r\n            disp.y = 0;\r\n            disp = disp.normalize();\r\n            disp.scaleToRef(forwardDist, disp);\r\n            disp.y = jumpDist;\r\n        } else {\r\n            disp = new Vector3(0, jumpDist, 0);\r\n            anim = this._idleJump;\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y/2;\r\n        }\r\n        //moveWithCollision only seems to happen if length of displacment is atleast 0.001\r\n        this._avatar.moveWithCollisions(disp);\r\n        if (jumpDist < 0) {\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y;\r\n            //anim=this.fall;\r\n            //check if going up a slope or back on flat ground \r\n            if ((this._avatar.position.y > this._avStartPos.y) || ((this._avatar.position.y === this._avStartPos.y) && (disp.length() > 0.001))) {\r\n                this._endJump();\r\n            } else if (this._avatar.position.y < this._jumpStartPosY) {\r\n                //the avatar is below the point from where it started the jump\r\n                //so it is either in free fall or is sliding along a downward slope\r\n                //\r\n                //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n                //else it is on a slope\r\n                let actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                    //AV is on slope\r\n                    //Should AV continue to slide or stop?\r\n                    //if slope is less steeper than acceptable then stop else slide\r\n                    if (this._verticalSlope(actDisp) <= this._sl) {\r\n                        this._endJump();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    /**\r\n     * does cleanup at the end of a jump\r\n     */\r\n    private _endJump() {\r\n        this._act.jump = false;\r\n        this._jumpTime = 0;\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n\r\n    }\r\n\r\n    /**\r\n     * checks if two vectors v1 and v2 are equal within a precision of p\r\n     */\r\n    private _areVectorsEqual(v1: Vector3, v2: Vector3, p: number) {\r\n        return ((Math.abs(v1.x - v2.x) < p) && (Math.abs(v1.y - v2.y) < p) && (Math.abs(v1.z - v2.z) < p));\r\n    }\r\n    /*\r\n     * returns the slope (in radians) of a vector in the vertical plane\r\n     */\r\n    private _verticalSlope(v: Vector3): number {\r\n        return Math.atan(Math.abs(v.y / Math.sqrt(v.x * v.x + v.z * v.z)));\r\n    }\r\n\r\n    //for how long has the av been falling while moving\r\n    private _movFallTime: number = 0;\r\n\r\n\r\n    private _sign = 1;\r\n    private _turnedBack = false;\r\n    private _turnedForward = true;\r\n    // private _degree270 = -4.69;\r\n    private _degree270 = 3 * (Math.PI / 2);\r\n\r\n    private _doMove(dt: number): AnimData {\r\n\r\n        //initial down velocity\r\n        let u: number = this._movFallTime * this._gravity\r\n        //calculate the distance by which av should fall down since last frame\r\n        //assuming it is in freefall\r\n        this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n\r\n        this._movFallTime = this._movFallTime + dt;\r\n\r\n        let moving: boolean = false;\r\n        let anim: AnimData = null;\r\n\r\n        if (this._inFreeFall) {\r\n            this._moveVector.y = -this._freeFallDist;\r\n            moving = true;\r\n        } else {\r\n            this._wasWalking = false;\r\n            this._wasRunning = false;\r\n\r\n            if (this._act.forward) {\r\n                let forwardDist: number = 0;\r\n                if (this._act.shift) {\r\n                    this._wasRunning = true;\r\n                    forwardDist = this._runSpeed * dt;\r\n                    anim = this._run;\r\n                } else {\r\n                    this._wasWalking = true;\r\n                    forwardDist = this._walkSpeed * dt;\r\n                    anim = this._walk;\r\n                }\r\n                if (this.mode != 1) {\r\n                    this._avatar.rotation.y = this._degree270 - this._camera.alpha;\r\n                } else {\r\n                    if (!this._turnedForward) {\r\n                        this._turnedForward = true;\r\n                        this._turnedBack = false;\r\n                        //this.avatar.rotation.y -= 3.14;\r\n                    }\r\n                }\r\n                this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, this._faceForward * forwardDist);\r\n                moving = true;\r\n            } else if (this._act.backward) {\r\n                this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, -this._faceForward * (this._backSpeed * dt));\r\n                anim = this._walkBack;\r\n                moving = true;\r\n            } else if (this._act.stepLeft) {\r\n                anim = this._strafeLeft;\r\n                this._moveVector = this._avatar.calcMovePOV(this._signRHS * (this._leftSpeed * dt) * this._isAvFacingCamera(), -this._freeFallDist, 0);\r\n                moving = true;\r\n            } else if (this._act.stepRight) {\r\n                anim = this._strafeRight;\r\n                this._moveVector = this._avatar.calcMovePOV(-this._signRHS * (this._rightSpeed * dt) * this._isAvFacingCamera(), -this._freeFallDist, 0);\r\n                moving = true;\r\n            }\r\n        }\r\n\r\n        if ((!this._act.stepLeft && !this._act.stepRight) && (this._act.turnLeft || this._act.turnRight)) {\r\n\r\n            if (this.mode == 1) {\r\n                // while turining, the avatar could start facing away from camera and end up facing camera.\r\n                // we should not switch turning direction during this transition\r\n                if (this._act.name != this._act.prevName) {\r\n                    this._act.prevName = this._act.name;\r\n                    this._sign = this._isAvFacingCamera();\r\n                }\r\n                if (this._act.turnLeft) {\r\n                    if (this._act.forward) this._avatar.rotation.y += this._turnSpeed * dt * this._sign;\r\n                    else if (this._act.backward) this._avatar.rotation.y -= this._turnSpeed * dt * this._sign;\r\n                    else {\r\n                        this._avatar.rotation.y += this._turnSpeed * dt * this._sign;\r\n                        anim = this._turnLeft;\r\n                    }\r\n                } else {\r\n                    if (this._act.forward) this._avatar.rotation.y -= this._turnSpeed * dt * this._sign;\r\n                    else if (this._act.backward) this._avatar.rotation.y += this._turnSpeed * dt * this._sign;\r\n                    else {\r\n                        this._avatar.rotation.y -= this._turnSpeed * dt * this._sign;\r\n                        anim = this._turnRight;\r\n                    }\r\n                }\r\n            } else {\r\n                if (this._act.turnLeft) {\r\n                    this._camera.alpha = this._camera.alpha + this._turnSpeed * dt;\r\n                    if (!moving) anim = this._turnLeft;\r\n                } else {\r\n                    this._camera.alpha = this._camera.alpha - this._turnSpeed * dt;\r\n                    if (!moving) anim = this._turnRight;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (moving) {\r\n            if (this.mode != 1) this._avatar.rotation.y = this._degree270 - this._camera.alpha;\r\n            if (this._moveVector.length() > 0.001) {\r\n                this._avatar.moveWithCollisions(this._moveVector);\r\n                //walking up a slope\r\n                if (this._avatar.position.y > this._avStartPos.y) {\r\n                    let actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                    let _sl: number = this._verticalSlope(actDisp);\r\n                    if (_sl >= this._sl2) {\r\n                        //this._climbingSteps=true;\r\n                        //is av trying to go up steps\r\n                        if (this._stepOffset > 0) {\r\n                            if (this._vMoveTot == 0) {\r\n                                //if just started climbing note down the position\r\n                                this._vMovStartPos.copyFrom(this._avStartPos);\r\n                            }\r\n                            this._vMoveTot = this._vMoveTot + (this._avatar.position.y - this._avStartPos.y);\r\n                            if (this._vMoveTot > this._stepOffset) {\r\n                                //move av back to its position at begining of steps\r\n                                this._vMoveTot = 0;\r\n                                this._avatar.position.copyFrom(this._vMovStartPos);\r\n                                this._endFreeFall();\r\n                            }\r\n                        } else {\r\n                            //move av back to old position\r\n                            this._avatar.position.copyFrom(this._avStartPos);\r\n                            this._endFreeFall();\r\n                        }\r\n                    } else {\r\n                        this._vMoveTot = 0;\r\n                        if (_sl > this._sl) {\r\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                            this._fallFrameCount = 0;\r\n                            this._inFreeFall = false;\r\n                        } else {\r\n                            //continue walking\r\n                            this._endFreeFall();\r\n                        }\r\n                    }\r\n                } else if ((this._avatar.position.y) < this._avStartPos.y) {\r\n                    let actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                    if (!(this._areVectorsEqual(actDisp, this._moveVector, 0.001))) {\r\n                        //AV is on slope\r\n                        //Should AV continue to slide or walk?\r\n                        //if slope is less steeper than acceptable then walk else slide\r\n                        if (this._verticalSlope(actDisp) <= this._sl) {\r\n                            this._endFreeFall();\r\n                        } else {\r\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                            this._fallFrameCount = 0;\r\n                            this._inFreeFall = false;\r\n                        }\r\n                    } else {\r\n                        this._inFreeFall = true;\r\n                        this._fallFrameCount++;\r\n                        //AV could be running down a slope which mean freefall,run,frefall run ...\r\n                        //to remove anim flicker, check if AV has been falling down continously for last few consecutive frames\r\n                        //before changing to free fall animation\r\n                        if (this._fallFrameCount > this._fallFrameCountMin) {\r\n                            anim = this._fall;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this._endFreeFall();\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _endFreeFall(): void {\r\n        this._movFallTime = 0;\r\n        this._fallFrameCount = 0;\r\n        this._inFreeFall = false;\r\n    }\r\n\r\n    //for how long has the av been falling while idle (not moving)\r\n    private _idleFallTime: number = 0;\r\n    private _doIdle(dt: number): AnimData {\r\n        if (this._grounded) {\r\n            return this._idle;\r\n        }\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n        this._movFallTime = 0;\r\n        let anim: AnimData = this._idle;\r\n        this._fallFrameCount = 0;\r\n\r\n\r\n        if (dt === 0) {\r\n            this._freeFallDist = 5;\r\n        } else {\r\n            let u: number = this._idleFallTime * this._gravity\r\n            this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n            this._idleFallTime = this._idleFallTime + dt;\r\n        }\r\n        //if displacement is less than 0.01(? need to verify further) then \r\n        //moveWithDisplacement down against a surface seems to push the AV up by a small amount!!\r\n        if (this._freeFallDist < 0.01) return anim;\r\n        let disp: Vector3 = new Vector3(0, -this._freeFallDist, 0);;\r\n        if (this.mode != 1) this._avatar.rotation.y = this._degree270 - this._camera.alpha;\r\n        this._avatar.moveWithCollisions(disp);\r\n        if ((this._avatar.position.y > this._avStartPos.y) || (this._avatar.position.y === this._avStartPos.y)) {\r\n            //                this.grounded = true;\r\n            //                this.idleFallTime = 0;\r\n            this._groundIt();\r\n        } else if (this._avatar.position.y < this._avStartPos.y) {\r\n            //AV is going down. \r\n            //AV is either in free fall or is sliding along a downward slope\r\n            //\r\n            //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n            //else it is on a slope\r\n            let actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n            if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                //AV is on slope\r\n                //Should AV continue to slide or stop?\r\n                //if slope is less steeper than accebtable then stop else slide\r\n                if (this._verticalSlope(actDisp) <= this._sl) {\r\n                    //                        this.grounded = true;\r\n                    //                        this.idleFallTime = 0;\r\n                    this._groundIt();\r\n                    this._avatar.position.copyFrom(this._avStartPos);\r\n                } else {\r\n                    this._unGroundIt();\r\n                    anim = this._slideBack;\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _groundFrameCount = 0;\r\n    private _groundFrameMax = 10;\r\n    /**\r\n     * donot ground immediately\r\n     * wait few more frames\r\n     */\r\n    private _groundIt(): void {\r\n        this._groundFrameCount++;\r\n        if (this._groundFrameCount > this._groundFrameMax) {\r\n            this._grounded = true;\r\n            this._idleFallTime = 0;\r\n        }\r\n    }\r\n    private _unGroundIt() {\r\n        this._grounded = false;\r\n        this._groundFrameCount = 0;\r\n    }\r\n\r\n    private _savedCameraCollision: boolean = true;\r\n    private _inFP = false;\r\n    private _updateTargetValue() {\r\n        //donot move camera if av is trying to clinb steps\r\n        if (this._vMoveTot == 0)\r\n            this._avatar.position.addToRef(this._cameraTarget, this._camera.target);\r\n\r\n        if (this._camera.radius > this._camera.lowerRadiusLimit) { if (this._elasticCamera) this._snapCamera(); }\r\n\r\n        if (this._camera.radius <= this._camera.lowerRadiusLimit) {\r\n            if (!this._noFirstPerson && !this._inFP) {\r\n                this._avatar.visibility = 0;\r\n                this._camera.checkCollisions = false;\r\n                this._saveMode = this.mode;\r\n                this.mode = 0;\r\n                this._inFP = true;\r\n            }\r\n        } else {\r\n            this._inFP = false;\r\n            this.mode = this._saveMode;\r\n            this._avatar.visibility = 1;\r\n            this._camera.checkCollisions = this._savedCameraCollision;\r\n        }\r\n    }\r\n\r\n    private _ray: Ray = new Ray(Vector3.Zero(), Vector3.One(), 1);\r\n    private _rayDir: Vector3 = Vector3.Zero();\r\n    //camera seems to get stuck into things\r\n    //should move camera away from things by a value of cameraSkin\r\n    private _cameraSkin: number = 0.5;\r\n    private _skip: number = 0;\r\n    private _snapCamera() {\r\n        //            if(this.skip<120) {\r\n        //                this.skip++;\r\n        //                return;\r\n        //            }\r\n        //            this.skip=0;\r\n        //get vector from av (camera.target) to camera\r\n        this._camera.position.subtractToRef(this._camera.target, this._rayDir);\r\n        //start ray from av to camera\r\n        this._ray.origin = this._camera.target;\r\n        this._ray.length = this._rayDir.length();\r\n        this._ray.direction = this._rayDir.normalize();\r\n\r\n        let pi: PickingInfo = this._scene.pickWithRay(this._ray, (mesh) => {\r\n            //if(mesh==this.avatar||!mesh.isPickable||!mesh.checkCollisions) return false;\r\n            if (mesh == this._avatar || !mesh.checkCollisions) return false;\r\n            else return true;\r\n        }, true);\r\n\r\n        if (pi.hit) {\r\n            //postion the camera in front of the mesh that is obstructing camera\r\n            if (this._camera.checkCollisions) {\r\n                let newPos: Vector3 = this._camera.target.subtract(pi.pickedPoint).normalize().scale(this._cameraSkin);\r\n                pi.pickedPoint.addToRef(newPos, this._camera.position);\r\n            } else {\r\n                let nr: number = pi.pickedPoint.subtract(this._camera.target).length();\r\n                this._camera.radius = nr - this._cameraSkin;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _move: boolean = false;\r\n    public anyMovement(): boolean {\r\n        return (this._act.forward || this._act.backward || this._act.turnLeft || this._act.turnRight || this._act.stepLeft || this._act.stepRight);\r\n    }\r\n\r\n    private _onKeyDown(e: Event) {\r\n        let event: KeyboardEvent = <KeyboardEvent>e;\r\n        let code: number = event.keyCode;\r\n        let chr: string = String.fromCharCode(code);\r\n\r\n        if ((chr === this._jumpKey) || (code === this._jumpCode)) this._act.jump = true;\r\n        else if (code === 16) this._act.shift = true;\r\n        //WASD or arrow keys\r\n        else if ((chr === this._walkKey) || (code === this._walkCode)) this._act.forward = true;\r\n        else if ((chr === this._turnLeftKey) || (code === this._turnLeftCode)) { this._act.turnLeft = true; this._act.name = \"tl\" }\r\n        else if ((chr === this._turnRightKey) || (code === this._turnRightCode)) { this._act.turnRight = true; this._act.name = \"tr\" }\r\n        else if ((chr === this._walkBackKey) || (code === this._walkBackCode)) this._act.backward = true;\r\n        else if ((chr === this._strafeLeftKey) || (code === this._strafeLeftCode)) this._act.stepLeft = true;\r\n        else if ((chr === this._strafeRightKey) || (code === this._strafeRightCode)) this._act.stepRight = true;\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    private _onKeyUp(e: Event) {\r\n        let event: KeyboardEvent = <KeyboardEvent>e;\r\n        let code: number = event.keyCode;\r\n        let chr: string = String.fromCharCode(code);\r\n\r\n        if (code === 16) { this._act.shift = false; }\r\n        //WASD or arrow keys\r\n        else if ((chr === this._walkKey) || (code === this._walkCode)) this._act.forward = false;\r\n        else if ((chr === this._turnLeftKey) || (code === this._turnLeftCode)) { this._act.turnLeft = false; this._act.name = \"\"; this._act.prevName = \"\" }\r\n        else if ((chr === this._turnRightKey) || (code === this._turnRightCode)) { this._act.turnRight = false; this._act.name = \"\"; this._act.prevName = \"\" }\r\n        else if ((chr === this._walkBackKey) || (code === this._walkBackCode)) this._act.backward = false;\r\n        else if ((chr === this._strafeLeftKey) || (code === this._strafeLeftCode)) this._act.stepLeft = false;\r\n        else if ((chr === this._strafeRightKey) || (code === this._strafeRightCode)) this._act.stepRight = false;\r\n\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    // control movement by commands rather than keyboard.\r\n    public disableKeyBoard() {\r\n        window.removeEventListener(\"keyup\", this._handleKeyUp, false);\r\n        window.removeEventListener(\"keydown\", this._handleKeyDown, false);\r\n    }\r\n\r\n    public enableKeyBoard() {\r\n        window.addEventListener(\"keyup\", this._handleKeyUp, false);\r\n        window.addEventListener(\"keydown\", this._handleKeyDown, false);\r\n    }\r\n\r\n    public walk(b: boolean) {\r\n        this._act.forward = b;\r\n    }\r\n    public walkBack(b: boolean) {\r\n        this._act.backward = b;\r\n    }\r\n    public run(b: boolean) {\r\n        this._act.forward = b;\r\n        this._act.shift = b;\r\n    }\r\n    public turnLeft(b: boolean) {\r\n        this._act.turnLeft = b;\r\n    }\r\n    public turnRight(b: boolean) {\r\n        this._act.turnRight = b;\r\n    }\r\n    public strafeLeft(b: boolean) {\r\n        this._act.stepLeft = b;\r\n    }\r\n    public strafeRight(b: boolean) {\r\n        this._act.stepRight = b;\r\n    }\r\n    public jump(b: boolean) {\r\n        this._act.jump = b;\r\n    }\r\n    public idle() {\r\n        this._act.reset();\r\n    }\r\n\r\n\r\n\r\n    private _act: Action;\r\n    private _renderer: () => void;\r\n    private _handleKeyUp: (e) => void;\r\n    private _handleKeyDown: (e) => void;\r\n    private _isAG: boolean = false;\r\n    private _hasAnims: boolean = false;\r\n    /**\r\n     * \r\n     * @param avatar \r\n     * @param camera \r\n     * @param scene \r\n     * @param agMap map of animationRange name to animationRange\r\n     */\r\n    constructor(avatar: Mesh, camera: ArcRotateCamera, scene: Scene, agMap?: {}, faceForward?: boolean) {\r\n\r\n        this._avatar = avatar;\r\n\r\n        this._setRHS(avatar);\r\n        this.setFaceForward(faceForward);\r\n\r\n        this._scene = scene;\r\n\r\n        if (agMap != null) {\r\n            this._isAG = true;\r\n            this.setAnimationGroups(agMap);\r\n        }\r\n\r\n        if (this._isAG || this._skeleton !== null) {\r\n            this._hasAnims = true;\r\n        }\r\n\r\n        if (!this._isAG) this._skeleton = avatar.skeleton;\r\n\r\n        if (!this._isAG && this._skeleton != null) this.checkAnims(this._skeleton);\r\n        this._camera = camera;\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n\r\n        this._act = new Action();\r\n\r\n        this._renderer = () => { this._moveAVandCamera() };\r\n        this._handleKeyUp = (e) => { this._onKeyUp(e) };\r\n        this._handleKeyDown = (e) => { this._onKeyDown(e) };\r\n\r\n        window.addEventListener(\"keyup\", this._handleKeyUp, false);\r\n        window.addEventListener(\"keydown\", this._handleKeyDown, false);\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nexport class AnimData {\r\n    public name: string;\r\n    public loop: boolean = true;\r\n    public rate: number = 1;\r\n    public ag: AnimationGroup;\r\n    public exist: boolean = false;\r\n\r\n    public constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport class Action {\r\n    public forward: boolean;\r\n    public backward: boolean;\r\n    public turnRight: boolean;\r\n    public turnLeft: boolean;\r\n    public stepRight: boolean;\r\n    public stepLeft: boolean;\r\n    public jump: boolean;\r\n    public shift: boolean;\r\n\r\n    public name: string;\r\n    public prevName: string = \"\";\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    reset() {\r\n        this.forward = false;\r\n        this.backward = false;\r\n        this.turnRight = false;\r\n        this.turnLeft = false;\r\n        this.stepRight = false;\r\n        this.stepLeft = false;\r\n        this.jump = false;\r\n        this.shift = false;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n"],"sourceRoot":""}