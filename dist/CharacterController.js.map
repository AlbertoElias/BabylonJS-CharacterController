{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///external {\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\",\"root\":\"BABYLON\"}","webpack:///./src/CharacterController.ts"],"names":["root","factory","exports","module","require","define","amd","a","i","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","avatar","camera","scene","actionData","faceForward","_gravity","_minSlopeLimit","_maxSlopeLimit","_sl1","Math","PI","this","_sl2","_stepOffset","_vMoveTot","_vMovStartPos","Zero","_actionMap","_ActionMap","_cameraElastic","_cameraTarget","_noFirstPerson","_mode","_saveMode","_isRHS","_signRHS","_started","_stopAnim","_prevAnim","_avStartPos","_grounded","_freeFallDist","_fallFrameCountMin","_fallFrameCount","_inFreeFall","_wasWalking","_wasRunning","_jumpStartPosY","_jumpTime","_movFallTime","_sign","_isTurning","_noRot","_idleFallTime","_groundFrameCount","_groundFrameMax","_savedCameraCollision","_inFP","_ray","One","_rayDir","_cameraSkin","_skip","_move","_isAG","_hasAnims","setAvatar","console","error","_scene","setActionData","_skeleton","_checkAnimRanges","_camera","checkCollisions","_act","_Action","_renderer","_moveAVandCamera","_handleKeyUp","e","_onKeyUp","_handleKeyDown","_onKeyDown","getScene","setSlopeLimit","minSlopeLimit","maxSlopeLimit","setStepOffset","stepOffset","setWalkSpeed","walk","_speed","setRunSpeed","run","setBackSpeed","walkBack","setBackFastSpeed","walkBackFast","setJumpSpeed","idleJump","runJump","setLeftSpeed","strafeLeft","setLeftFastSpeed","strafeLeftFast","setRightSpeed","strafeRight","setRightFastSpeed","setTurnSpeed","turnLeft","turnRight","setTurnFastSpeed","turnLeftFast","turnRightFast","setGravity","setAnimationGroups","agMap","_exist","_ag","stop","setAnimationRanges","arMap","actmap","actData","keys","act","_ActionData","_id","_name","_loop","_rate","_checkFastAnims","getActionMap","map","data","_key","_sound","getSettings","ccs","CCSettings","cameraRotate","getMode","cameraTarget","clone","cameraElastic","gravity","keyboard","_ekb","noFirstPerson","turningOff","isTurningOff","setSettings","setMode","setCameraTarget","setCameraElasticity","enableKeyBoard","setNoFirstPerson","setTurningOff","_setAnim","anim","rangeName","rate","loop","speedRatio","getAnimationRange","enableBlending","targetedAnimations","ta","animation","blendingSpeed","disableBlending","setWalkAnim","setRunAnim","setWalkBackAnim","_copySlowAnims","setWalkBackFastAnim","setSlideBackAnim","slideBack","setIdleAnim","idle","setTurnRightAnim","setTurnRightFastAnim","setTurnLeftAnim","setTurnLeftFastAnim","setStrafeRightAnim","strafeRightFast","setStrafeRightFastAnim","setStrafeLeftAnim","setStrafeLeftFastAnim","setIdleJumpAnim","setRunJumpAnim","setFallAnim","fall","setWalkKey","toLowerCase","setWalkBackKey","setTurnLeftKey","setTurnRightKey","setStrafeLeftKey","setStrafeRightKey","setJumpKey","b","v","copyFrom","cameraCollisionChanged","skel","f","_setRHS","mesh","meshMatrix","getWorldMatrix","_localX","FromFloatArray","_localY","_localZ","actualZ","Cross","Dot","setFaceForward","_ff","_av2cam","_ffSign","isFaceForward","checkAGs","start","reset","_updateTargetValue","registerBeforeRender","unregisterBeforeRender","pauseAnim","resumeAnim","_isAvFacingCamera","_avatar","forward","position","subtract","dt","getEngine","getDeltaTime","_jump","_doJump","anyMovement","_doMove","_doIdle","beginAnimation","y","disp","forwardDist","jumpDist","rotation","alpha","_moveVector","normalize","scaleToRef","_calcJumpDist","moveWithCollisions","length","_endJump","actDisp","_areVectorsEqual","_verticalSlope","speed","v1","v2","abs","x","z","atan","sqrt","u","moving","sign","horizDist","_speedMod","calcMovePOV","_walk","_stepLeft","_stepRight","_turnLeft","_turnRight","turnAngle","_walkback","_slp","_endFreeFall","_groundIt","_unGroundIt","addToRef","target","radius","lowerRadiusLimit","_snapCamera","visibility","subtractToRef","origin","direction","pi","pickWithRay","hit","newPos","pickedPoint","scale","nr","repeat","canvas","getRenderingCanvas","addEventListener","removeEventListener","jump","isAg","_findSkel","_root","skeleton","ms","getChildMeshes","cm","tn","parent","rootNode","overrideMesh","getAvatar","setAvatarSkeleton","getSkeleton","id"],"mappings":"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","file":"CharacterController.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"babylonjs\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"babylonjs\")) : factory(root[\"BABYLON\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import {\r\n    Skeleton,\r\n    ArcRotateCamera,\r\n    Vector3,\r\n    Mesh,\r\n    Node,\r\n    Scene,\r\n    Ray,\r\n    PickingInfo,\r\n    AnimationGroup,\r\n    TransformNode,\r\n    Matrix\r\n} from \"babylonjs\"\r\n\r\nexport class CharacterController {\r\n\r\n    private _avatar: Mesh;\r\n    private _skeleton: Skeleton;\r\n    private _camera: ArcRotateCamera;\r\n    private _scene: Scene;\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n\r\n    private _gravity: number = 9.8;\r\n    //slopeLimit in degrees\r\n    private _minSlopeLimit: number = 30;\r\n    private _maxSlopeLimit: number = 45;\r\n    //slopeLimit in radians\r\n    private _sl1: number = Math.PI * this._minSlopeLimit / 180;\r\n    private _sl2: number = Math.PI * this._maxSlopeLimit / 180;\r\n\r\n    //The av will step up a stair only if it is closer to the ground than the indicated value.\r\n    private _stepOffset: number = 0.25;\r\n    //toal amount by which the av has moved up\r\n    private _vMoveTot: number = 0;\r\n    //position of av when it started moving up\r\n    private _vMovStartPos: Vector3 = Vector3.Zero();\r\n\r\n\r\n    private _actionMap: _ActionMap = new _ActionMap();\r\n\r\n    private _cameraElastic: boolean = true;\r\n    private _cameraTarget: Vector3 = Vector3.Zero();\r\n    //should we go into first person view when camera is near avatar (radius is lowerradius limit)\r\n    private _noFirstPerson: boolean = false;\r\n\r\n\r\n\r\n    public setSlopeLimit(minSlopeLimit: number, maxSlopeLimit: number) {\r\n        this._minSlopeLimit = minSlopeLimit;\r\n        this._maxSlopeLimit = maxSlopeLimit;\r\n\r\n        this._sl1 = Math.PI * this._minSlopeLimit / 180;\r\n        this._sl2 = Math.PI * this._maxSlopeLimit / 180;\r\n    }\r\n\r\n    /**\r\n     * The av will step up a stair only if it is closer to the ground than the indicated value.\r\n     * Default value is 0.25 m\r\n     */\r\n    public setStepOffset(stepOffset: number) {\r\n        this._stepOffset = stepOffset;\r\n    }\r\n\r\n    public setWalkSpeed(n: number) {\r\n        this._actionMap.walk._speed = n;\r\n    }\r\n    public setRunSpeed(n: number) {\r\n        this._actionMap.run._speed = n;\r\n    }\r\n    public setBackSpeed(n: number) {\r\n        this._actionMap.walkBack._speed = n;\r\n    }\r\n    public setBackFastSpeed(n: number) {\r\n        this._actionMap.walkBackFast._speed = n;\r\n    }\r\n    public setJumpSpeed(n: number) {\r\n        this._actionMap.idleJump._speed = n;\r\n        this._actionMap.runJump._speed = n;\r\n    }\r\n    public setLeftSpeed(n: number) {\r\n        this._actionMap.strafeLeft._speed = n;\r\n    }\r\n    public setLeftFastSpeed(n: number) {\r\n        this._actionMap.strafeLeftFast._speed = n;\r\n    }\r\n    public setRightSpeed(n: number) {\r\n        this._actionMap.strafeRight._speed = n;\r\n    }\r\n    public setRightFastSpeed(n: number) {\r\n        this._actionMap.strafeLeftFast._speed = n;\r\n    }\r\n    // get turnSpeed in degrees per second.\r\n    // store in radians per second\r\n    public setTurnSpeed(n: number) {\r\n        this._actionMap.turnLeft._speed = n * Math.PI / 180;\r\n        this._actionMap.turnRight._speed = n * Math.PI / 180;\r\n    }\r\n    public setTurnFastSpeed(n: number) {\r\n        this._actionMap.turnLeftFast._speed = n * Math.PI / 180;\r\n        this._actionMap.turnRightFast._speed = n * Math.PI / 180;\r\n    }\r\n    public setGravity(n: number) {\r\n        this._gravity = n;\r\n    }\r\n\r\n    /**\r\n     * Use this to provide animationGroups to the character controller.\r\n     * Provide the AnimationGroups using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animationGroup.\r\n     * Example:\r\n     * let myWalkAnimationGroup:AnimationGroup = ...;\r\n     * let agMap:{} = {\r\n     *  \"walk\":myWalkAnimationGroup,\r\n     *  \"run\" : {\"ag\":myRunAnimationGroup,\"rate\":1},\r\n     *  \"idle\" : {\"ag\":myIdleAnimationGroup,\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     *   ....\r\n     * }\r\n     * \r\n     * @param agMap a map of character controller animation name to animationGroup\r\n     */\r\n    public setAnimationGroups(agMap: {}) {\r\n        if (this._prevAnim != null && this._prevAnim._exist) this._prevAnim._ag.stop();\r\n        this._isAG = true;\r\n        this.setActionData(agMap);\r\n    }\r\n\r\n    /**\r\n     * Use this to provide AnimationRanges to the character controller.\r\n     * Provide the AnimationRanges using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animation range name or an object with animation range data.\r\n     * example:\r\n     * let arMap = {\r\n     *  \"walk\":\"myWalk\",\r\n     *  \"run\" : {\"name\":\"myRun\",\"rate\":1},\r\n     *  \"idle\" : {\"name\":\"myIdle\",\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     * }\r\n     * \r\n     * @param arMap a map of character controller animation name to animationRange data\r\n     */\r\n\r\n    public setAnimationRanges(arMap: {}) {\r\n        this._isAG = false;\r\n        this.setActionData(arMap);\r\n    }\r\n\r\n    /**\r\n     * sets the action data.\r\n     * \r\n     * return \"ar\" or \"ag\" depending on if the data provided\r\n     * was animation range or animation group data respt.\r\n     * \r\n     * TODO should validate provided data.\r\n     * In other words if animation range provided make sure\r\n     * the range exist in the skeleton\r\n     * or if animation group provided make sure the animation group\r\n     * can be played on this avataor\r\n     * \r\n     * @param actmap \r\n     * @returns \r\n     */\r\n    public setActionData(actmap: {}): string {\r\n        let agMap: boolean = false;\r\n        let actData: {};\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let act = this._actionMap[key];\r\n            if (!(act instanceof _ActionData)) continue;\r\n            act._exist = false;\r\n            actData = actmap[act._id];\r\n            if (actData != null) {\r\n                this._hasAnims = true;\r\n                act._exist = true;\r\n                if (actData instanceof AnimationGroup) {\r\n                    act._ag = actData;\r\n                    act._name = act._ag.name\r\n                    agMap = true;\r\n                } else {\r\n                    if (actData instanceof Object) {\r\n                        if (actData[\"ag\"]) {\r\n                            act._ag = actData[\"ag\"];\r\n                            agMap = true;\r\n                        }\r\n                        if (actData[\"name\"]) {\r\n                            act._name = actData[\"name\"];\r\n                        }\r\n                        if (actData[\"loop\"] != null) act._loop = actData[\"loop\"];\r\n                        if (actData[\"rate\"]) act._rate = actData[\"rate\"];\r\n                        if (actData[\"speed\"]) act._speed = actData[\"speed\"];\r\n                        if (actData[\"key\"]) act._speed = actData[\"key\"];\r\n                        if (actData[\"sound\"]) act._speed = actData[\"sound\"];\r\n                    } else {\r\n                        act._name = actData;\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n        this._checkFastAnims();\r\n        //force to play new anims\r\n        this._prevAnim = null;\r\n        if (agMap) return \"ag\"; else return \"ar\";\r\n    }\r\n\r\n    public getActionMap(): {} {\r\n        let map = {};\r\n\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let act = this._actionMap[key];\r\n            if (!(act instanceof _ActionData)) continue;\r\n            if (act._exist) {\r\n                let data = {};\r\n\r\n                if (this._isAG) data[\"ag\"] = act._ag;\r\n                else data[\"name\"] = act._name;\r\n\r\n                data[\"loop\"] = act._loop;\r\n                data[\"rate\"] = act._rate;\r\n                data[\"speed\"] = act._speed;\r\n                data[\"key\"] = act._key;\r\n                data[\"sound\"] = act._sound;\r\n\r\n                map[act._id] = data;\r\n            }\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    public getSettings(): CCSettings {\r\n        let ccs: CCSettings = new CCSettings();\r\n        ccs.cameraRotate = this.getMode() == 0 ? true : false;\r\n        ccs.cameraTarget = this._cameraTarget.clone();\r\n        ccs.cameraElastic = this._cameraElastic;\r\n        ccs.gravity = this._gravity;\r\n        ccs.keyboard = this._ekb;\r\n        ccs.maxSlopeLimit = this._maxSlopeLimit;\r\n        ccs.minSlopeLimit = this._minSlopeLimit;\r\n        ccs.noFirstPerson = this._noFirstPerson;\r\n        ccs.stepOffset = this._stepOffset;\r\n        ccs.turningOff = this.isTurningOff();\r\n        return ccs;\r\n    }\r\n\r\n    public setSettings(ccs: CCSettings) {\r\n        this.setMode(ccs.cameraRotate ? 0 : 1);\r\n        this.setCameraTarget(ccs.cameraTarget);\r\n        this.setCameraElasticity(ccs.cameraElastic);\r\n        this.setGravity(ccs.gravity);\r\n        this.enableKeyBoard(ccs.keyboard);\r\n        this.setSlopeLimit(ccs.minSlopeLimit, ccs.maxSlopeLimit);\r\n        this.setNoFirstPerson(ccs.noFirstPerson);\r\n        this.setStepOffset(ccs.stepOffset);\r\n        this.setTurningOff(ccs.turningOff);\r\n    }\r\n\r\n\r\n\r\n    private _setAnim(anim: _ActionData, rangeName?: string | AnimationGroup, rate?: number, loop?: boolean) {\r\n        if (!this._isAG && this._skeleton == null) return;\r\n        if (loop != null) anim._loop = loop;\r\n        if (!this._isAG) {\r\n            if (rangeName != null) anim._name = <string>rangeName;\r\n            if (rate != null) anim._rate = rate;\r\n            if (this._skeleton.getAnimationRange(anim._name) != null) {\r\n                anim._exist = true;\r\n            } else {\r\n                anim._exist = false;\r\n            }\r\n        } else {\r\n            if (rangeName != null) {\r\n                anim._ag = <AnimationGroup>rangeName;\r\n                anim._exist = true;\r\n            }\r\n            if (rate != null && anim._exist) {\r\n                anim._rate = rate;\r\n                anim._ag.speedRatio = rate;\r\n            }\r\n        }\r\n    }\r\n\r\n    public enableBlending(n: number) {\r\n        if (this._isAG) {\r\n            let keys: string[] = Object.keys(this._actionMap);\r\n            for (let key of keys) {\r\n                let act = this._actionMap[key];\r\n                if (!(act instanceof _ActionData)) continue;\r\n                if (act._exist) {\r\n                    let ar: AnimationGroup = act._ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = true;\r\n                        ta.animation.blendingSpeed = n;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            this._skeleton.enableBlending(n);\r\n        }\r\n    }\r\n\r\n    public disableBlending() {\r\n        if (this._isAG) {\r\n            let keys: string[] = Object.keys(this._actionMap);\r\n            for (let key of keys) {\r\n                let anim = this._actionMap[key];\r\n                if (!(anim instanceof _ActionData)) continue;\r\n                if (anim._exist) {\r\n                    let ar: AnimationGroup = anim._ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //setters for animations\r\n    public setWalkAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walk, rangeName, rate, loop);\r\n    }\r\n    public setRunAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.run, rangeName, rate, loop);\r\n    }\r\n    public setWalkBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walkBack, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.walkBackFast, this._actionMap.walkBack);\r\n    }\r\n    public setWalkBackFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walkBackFast, rangeName, rate, loop);\r\n    }\r\n    public setSlideBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.slideBack, rangeName, rate, loop);\r\n    }\r\n    public setIdleAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.idle, rangeName, rate, loop);\r\n    }\r\n    public setTurnRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnRight, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.turnRightFast, this._actionMap.turnRight);\r\n    }\r\n    public setTurnRightFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnRightFast, rangeName, rate, loop);\r\n    }\r\n    public setTurnLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnLeft, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.turnLeftFast, this._actionMap.turnLeft);\r\n    }\r\n    public setTurnLeftFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnLeftFast, rangeName, rate, loop);\r\n    }\r\n    public setStrafeRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeRight, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.strafeRightFast, this._actionMap.strafeRight);\r\n    }\r\n    public setStrafeRightFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeRightFast, rangeName, rate, loop);\r\n    }\r\n    public setStrafeLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeLeft, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.strafeLeftFast, this._actionMap.strafeLeft);\r\n    }\r\n    public setStrafeLeftFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeLeftFast, rangeName, rate, loop);\r\n    }\r\n    public setIdleJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.idleJump, rangeName, rate, loop);\r\n    }\r\n    public setRunJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.runJump, rangeName, rate, loop);\r\n    }\r\n    public setFallAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.fall, rangeName, rate, loop);\r\n    }\r\n\r\n    // setters for keys\r\n    public setWalkKey(key: string) {\r\n        this._actionMap.walk._key = key.toLowerCase();\r\n    }\r\n    public setWalkBackKey(key: string) {\r\n        this._actionMap.walkBack._key = key.toLowerCase();\r\n    }\r\n    public setTurnLeftKey(key: string) {\r\n        this._actionMap.turnLeft._key = key.toLowerCase();\r\n    }\r\n    public setTurnRightKey(key: string) {\r\n        this._actionMap.turnRight._key = key.toLowerCase();\r\n    }\r\n    public setStrafeLeftKey(key: string) {\r\n        this._actionMap.strafeLeft._key = key.toLowerCase();\r\n    }\r\n    public setStrafeRightKey(key: string) {\r\n        this._actionMap.strafeRight._key = key.toLowerCase();\r\n    }\r\n    public setJumpKey(key: string) {\r\n        this._actionMap.idleJump._key = key.toLowerCase();\r\n    }\r\n\r\n    public setCameraElasticity(b: boolean) {\r\n        this._cameraElastic = b;\r\n    }\r\n    public setCameraTarget(v: Vector3) {\r\n        this._cameraTarget.copyFrom(v);\r\n    }\r\n\r\n\r\n    /**\r\n     * user should call this whenever the user changes the camera checkCollision \r\n     * property\r\n     * \r\n     */\r\n    public cameraCollisionChanged() {\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n    }\r\n    public setNoFirstPerson(b: boolean) {\r\n        this._noFirstPerson = b;\r\n    }\r\n\r\n    /**\r\n     * if av has the required anim (walk, run etc) then \r\n     * mark that anim as existing\r\n     * \r\n     * @param skel \r\n     */\r\n\r\n    private _checkAnimRanges(skel: Skeleton) {\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let anim = this._actionMap[key];\r\n            if (!(anim instanceof _ActionData)) continue;\r\n            if (skel != null) {\r\n                if (skel.getAnimationRange(anim._name) != null) {\r\n                    anim._exist = true;\r\n                    this._hasAnims = true;\r\n                }\r\n            } else {\r\n                anim._exist = false;\r\n            }\r\n        }\r\n        this._checkFastAnims();\r\n    }\r\n\r\n    /**\r\n     * if fast anims do not exist then use their slow counterpart as them but double the rate at which they play\r\n     */\r\n    private _checkFastAnims() {\r\n        this._copySlowAnims(this._actionMap.walkBackFast, this._actionMap.walkBack)\r\n        this._copySlowAnims(this._actionMap.turnRightFast, this._actionMap.turnRight);\r\n        this._copySlowAnims(this._actionMap.turnLeftFast, this._actionMap.turnLeft);\r\n        this._copySlowAnims(this._actionMap.strafeRightFast, this._actionMap.strafeRight);\r\n        this._copySlowAnims(this._actionMap.strafeLeftFast, this._actionMap.strafeLeft);\r\n    }\r\n\r\n    private _copySlowAnims(f: _ActionData, s: _ActionData) {\r\n        if (f._exist) return;\r\n        if (!s._exist) return;\r\n        f._exist = true;\r\n        f._ag = s._ag;\r\n        f._name = s._name;\r\n        f._rate = s._rate * 2;\r\n    }\r\n\r\n    /**\r\n     * Use this to make the  character controller suitable for a isometeric/top down games or  fps/third person game.\r\n     * 1 In isometric/top down games the camera direction has no bearing on avatar movement.\r\n     * 0 In fps/third person game rotating the camera around the avatar , rotates the avatr too.\r\n     */\r\n    private _mode = 0;\r\n    private _saveMode = 0;\r\n    public setMode(n: number) {\r\n        this._mode = n;\r\n        this._saveMode = n;\r\n    }\r\n    public getMode() {\r\n        return this._mode;\r\n    }\r\n    /**\r\n     * Use this to set  turning off.\r\n     * When turining is off \r\n     * a) turn left or turn right keys result in avatar facing and moving left or right with respect to camera.\r\n     * b) walkback/runback key results in avatar facing back and walking/running towards camera.\r\n     * \r\n     * This setting has no effect when mode is 1.\r\n     * \r\n     * @param b \r\n     */\r\n    public setTurningOff(b: boolean) {\r\n        this._noRot = b;\r\n    }\r\n    public isTurningOff() {\r\n        return this._noRot;\r\n    }\r\n\r\n    /**\r\n        * checks if a have left hand , right hand issue.\r\n        * In other words if a mesh is a LHS mesh in RHS system or \r\n        * a RHS mesh in LHS system\r\n        * The X axis will be reversed in such cases.\r\n        * thus Cross product of X and Y should be inverse of Z.\r\n        * BABYLONJS GLB models are RHS and exhibit this behavior\r\n        * \r\n        */\r\n    private _isRHS = false;\r\n    private _signRHS = -1;\r\n    private _setRHS(mesh: TransformNode) {\r\n        const meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        const _localX = Vector3.FromFloatArray(meshMatrix.m, 0);\r\n        const _localY = Vector3.FromFloatArray(meshMatrix.m, 4);\r\n        const _localZ = Vector3.FromFloatArray(meshMatrix.m, 8);\r\n        const actualZ = Vector3.Cross(_localX, _localY);\r\n        //same direction or opposite direction of Z\r\n        if (Vector3.Dot(actualZ, _localZ) < 0) {\r\n            this._isRHS = true;\r\n            this._signRHS = 1;\r\n        }\r\n        else {\r\n            this._isRHS = false;\r\n            this._signRHS = -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use setFaceForward(true|false) to indicate that the avatar face  faces forward (true) or backward (false).\r\n     * The avatar face faces forward if its face points to positive local Z axis direction\r\n     */\r\n    private _ffSign: number;\r\n    private _ff: boolean;\r\n    //in mode 0, av2cam is used to align avatar with camera , with camera always facing avatar's back\r\n    //note:camera alpha is measured anti-clockwise , avatar rotation is measured clockwise \r\n    private _av2cam;\r\n    public setFaceForward(b: boolean) {\r\n        this._ff = b;\r\n        if (this._isRHS) {\r\n            this._av2cam = b ? Math.PI / 2 : 3 * Math.PI / 2;\r\n            this._ffSign = b ? 1 : -1;\r\n        } else {\r\n            this._av2cam = b ? 3 * Math.PI / 2 : Math.PI / 2;\r\n            this._ffSign = b ? -1 : 1;\r\n        }\r\n    }\r\n    public isFaceForward() {\r\n        return this._ff;\r\n    }\r\n\r\n    private checkAGs(agMap: {}) {\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let anim = this._actionMap[key];\r\n            if (!(anim instanceof _ActionData)) continue;\r\n            if (agMap[anim._name] != null) {\r\n                anim._ag = agMap[anim._name];\r\n                anim._exist = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _started: boolean = false;\r\n    public start() {\r\n        if (this._started) return;\r\n        this._started = true;\r\n        this._act.reset();\r\n        this._movFallTime = 0;\r\n        //first time we enter render loop, delta time is zero\r\n        this._idleFallTime = 0.001;\r\n        this._grounded = false;\r\n        this._updateTargetValue();\r\n        this.enableKeyBoard(true);\r\n        this._scene.registerBeforeRender(this._renderer);\r\n    }\r\n\r\n    public stop() {\r\n        if (!this._started) return;\r\n        this._started = false;\r\n        this._scene.unregisterBeforeRender(this._renderer);\r\n        this.enableKeyBoard(false);\r\n        this._prevAnim = null;\r\n    }\r\n\r\n    /**\r\n     * use pauseAnim to stop the charactere controller from playing\r\n     * any animation on the character\r\n     * use this when you want to play your animation instead\r\n     * see also resumeAnim()\r\n     */\r\n    private _stopAnim: boolean = false;\r\n    public pauseAnim() {\r\n        this._stopAnim = true;\r\n    }\r\n\r\n    /**\r\n     * use resumeAnim to resume the character controller playing\r\n     * animations on the character.\r\n     * see also pauseAnim()\r\n     */\r\n    public resumeAnim() {\r\n        this._stopAnim = false;\r\n    }\r\n\r\n    private _prevAnim: _ActionData = null;\r\n    private _avStartPos: Vector3 = Vector3.Zero();\r\n    private _grounded: boolean = false;\r\n    //distance by which AV would move down if in freefall\r\n    private _freeFallDist: number = 0;\r\n\r\n    //how many minimum contiguos frames should the AV have been in free fall\r\n    //before we assume AV is in big freefall.\r\n    //we will use this to remove animation flicker during move down a slope (fall, move, fall move etc)\r\n    //TODO: base this on slope - large slope large count\r\n    private _fallFrameCountMin: number = 50;\r\n    private _fallFrameCount: number = 0;\r\n\r\n    private _inFreeFall: boolean = false;\r\n    private _wasWalking: boolean = false;\r\n    private _wasRunning: boolean = false;\r\n    private _moveVector: Vector3;\r\n\r\n    //used only in mode 1\r\n    //value 1 or -1 , -1 if avatar is facing camera\r\n    //private _notFacingCamera = 1;\r\n\r\n    private _isAvFacingCamera(): number {\r\n        if (Vector3.Dot(this._avatar.forward, this._avatar.position.subtract(this._camera.position)) < 0) return 1\r\n        else return -1;\r\n    }\r\n\r\n    private _moveAVandCamera() {\r\n        this._avStartPos.copyFrom(this._avatar.position);\r\n        let anim: _ActionData = null;\r\n        const dt: number = this._scene.getEngine().getDeltaTime() / 1000;\r\n\r\n        if (this._act._jump && !this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            anim = this._doJump(dt);\r\n        } else if (this.anyMovement() || this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            anim = this._doMove(dt);\r\n        } else if (!this._inFreeFall) {\r\n            anim = this._doIdle(dt);\r\n        }\r\n        if (!this._stopAnim && this._hasAnims && anim != null) {\r\n            if (this._prevAnim !== anim) {\r\n                if (anim._exist) {\r\n                    if (this._isAG) {\r\n                        if (this._prevAnim != null && this._prevAnim._exist) this._prevAnim._ag.stop();\r\n                        //TODO use start instead of play ?\r\n                        //anim._ag.play(anim._loop);\r\n                        //anim._ag.speedRatio = anim._rate;\r\n                        anim._ag.start(anim._loop, anim._rate);\r\n                    } else {\r\n                        this._skeleton.beginAnimation(anim._name, anim._loop, anim._rate);\r\n                    }\r\n                }\r\n                this._prevAnim = anim;\r\n            }\r\n        }\r\n        this._updateTargetValue();\r\n        return;\r\n    }\r\n\r\n    //verical position of AV when it is about to start a jump\r\n    private _jumpStartPosY: number = 0;\r\n    //for how long the AV has been in the jump\r\n    private _jumpTime: number = 0;\r\n    private _doJump(dt: number): _ActionData {\r\n\r\n        let anim: _ActionData = null;\r\n        anim = this._actionMap.runJump;\r\n        if (this._jumpTime === 0) {\r\n            this._jumpStartPosY = this._avatar.position.y;\r\n        }\r\n\r\n        this._jumpTime = this._jumpTime + dt;\r\n\r\n        let forwardDist: number = 0;\r\n        let jumpDist: number = 0;\r\n        let disp: Vector3;\r\n        if (this._mode != 1 && !this._noRot) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        if (this._wasRunning || this._wasWalking) {\r\n            if (this._wasRunning) {\r\n                forwardDist = this._actionMap.run._speed * dt;\r\n            } else if (this._wasWalking) {\r\n                forwardDist = this._actionMap.walk._speed * dt;\r\n            }\r\n            //find out in which horizontal direction the AV was moving when it started the jump\r\n            disp = this._moveVector.clone();\r\n            disp.y = 0;\r\n            disp = disp.normalize();\r\n            disp.scaleToRef(forwardDist, disp);\r\n            jumpDist = this._calcJumpDist(this._actionMap.runJump._speed, dt);\r\n            disp.y = jumpDist;\r\n        } else {\r\n            jumpDist = this._calcJumpDist(this._actionMap.idleJump._speed, dt);\r\n            disp = new Vector3(0, jumpDist, 0);\r\n            anim = this._actionMap.idleJump;\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y/2;\r\n        }\r\n        //moveWithCollision only seems to happen if length of displacment is atleast 0.001\r\n        this._avatar.moveWithCollisions(disp);\r\n        if (jumpDist < 0) {\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y;\r\n            //check if going up a slope or back on flat ground \r\n            if ((this._avatar.position.y > this._avStartPos.y) || ((this._avatar.position.y === this._avStartPos.y) && (disp.length() > 0.001))) {\r\n                this._endJump();\r\n            } else if (this._avatar.position.y < this._jumpStartPosY) {\r\n                //the avatar is below the point from where it started the jump\r\n                //so it is either in free fall or is sliding along a downward slope\r\n                //\r\n                //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n                //else it is on a slope\r\n                const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                    //AV is on slope\r\n                    //Should AV continue to slide or stop?\r\n                    //if slope is less steeper than acceptable then stop else slide\r\n                    if (this._verticalSlope(actDisp) <= this._sl1) {\r\n                        this._endJump();\r\n                    }\r\n                } else {\r\n                    anim = this._actionMap.fall;\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _calcJumpDist(speed: number, dt: number): number {\r\n        //up velocity at the begining of the lastt frame (v=u+at)\r\n        let js: number = speed - this._gravity * this._jumpTime;\r\n        //distance travelled up since last frame to this frame (s=ut+1/2*at^2)\r\n        let jumpDist: number = js * dt - 0.5 * this._gravity * dt * dt;\r\n        return jumpDist;\r\n    }\r\n\r\n    /**\r\n     * does cleanup at the end of a jump\r\n     */\r\n    private _endJump() {\r\n        this._act._jump = false;\r\n        this._jumpTime = 0;\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n    }\r\n\r\n    /**\r\n     * checks if two vectors v1 and v2 are equal within a precision of p\r\n     */\r\n    private _areVectorsEqual(v1: Vector3, v2: Vector3, p: number) {\r\n        return ((Math.abs(v1.x - v2.x) < p) && (Math.abs(v1.y - v2.y) < p) && (Math.abs(v1.z - v2.z) < p));\r\n    }\r\n\r\n    /*\r\n     * returns the slope (in radians) of a vector in the vertical plane\r\n     */\r\n    private _verticalSlope(v: Vector3): number {\r\n        return Math.atan(Math.abs(v.y / Math.sqrt(v.x * v.x + v.z * v.z)));\r\n    }\r\n\r\n    //for how long has the av been falling while moving\r\n    private _movFallTime: number = 0;\r\n    private _sign = 1;\r\n    private _isTurning = false;\r\n    private _noRot = false;\r\n    private _doMove(dt: number): _ActionData {\r\n\r\n        //initial down velocity\r\n        const u: number = this._movFallTime * this._gravity\r\n        //calculate the distance by which av should fall down since last frame\r\n        //assuming it is in freefall\r\n        this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n\r\n        this._movFallTime = this._movFallTime + dt;\r\n\r\n        let moving: boolean = false;\r\n        let anim: _ActionData = null;\r\n\r\n        if (this._inFreeFall) {\r\n            this._moveVector.y = -this._freeFallDist;\r\n            moving = true;\r\n        } else {\r\n            this._wasWalking = false;\r\n            this._wasRunning = false;\r\n\r\n            let sign: number;\r\n            let horizDist: number = 0;\r\n            switch (true) {\r\n                case (this._act._stepLeft):\r\n                    sign = this._signRHS * this._isAvFacingCamera();\r\n                    horizDist = this._actionMap.strafeLeft._speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.strafeLeftFast._speed * dt;\r\n                        anim = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeftFast : this._actionMap.strafeRightFast;\r\n                    } else {\r\n                        anim = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeft : this._actionMap.strafeRight;\r\n                    }\r\n\r\n                    this._moveVector = this._avatar.calcMovePOV(sign * horizDist, -this._freeFallDist, 0);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._stepRight):\r\n                    sign = -this._signRHS * this._isAvFacingCamera();\r\n                    horizDist = this._actionMap.strafeRight._speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.strafeRightFast._speed * dt;\r\n                        anim = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeftFast : this._actionMap.strafeRightFast;\r\n                    } else {\r\n                        anim = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeft : this._actionMap.strafeRight;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(sign * horizDist, -this._freeFallDist, 0);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._walk || (this._noRot && this._mode == 0)):\r\n                    if (this._act._speedMod) {\r\n                        this._wasRunning = true;\r\n                        horizDist = this._actionMap.run._speed * dt;\r\n                        anim = this._actionMap.run;\r\n                    } else {\r\n                        this._wasWalking = true;\r\n                        horizDist = this._actionMap.walk._speed * dt;\r\n                        anim = this._actionMap.walk;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, this._ffSign * horizDist);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._walkback):\r\n                    horizDist = this._actionMap.walkBack._speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.walkBackFast._speed * dt;\r\n                        anim = this._actionMap.walkBackFast;\r\n                    } else {\r\n                        anim = this._actionMap.walkBack;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, -this._ffSign * horizDist);\r\n                    moving = true;\r\n                    break;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if (!(this._noRot && this._mode == 0) && (!this._act._stepLeft && !this._act._stepRight) && (this._act._turnLeft || this._act._turnRight)) {\r\n            let turnAngle = this._actionMap.turnLeft._speed * dt;\r\n            if (this._act._speedMod) {\r\n                turnAngle = 2 * turnAngle;\r\n            }\r\n            if (this._mode == 1) {\r\n                // while turining, the avatar could start facing away from camera and end up facing camera.\r\n                // we should not switch turning direction during this transition\r\n                if (!this._isTurning) {\r\n                    // if (this._act.name != this._act.prevName) {\r\n                    // this._act.prevName = this._act.name;\r\n                    this._sign = -this._ffSign * this._isAvFacingCamera();\r\n                    if (this._isRHS) this._sign = - this._sign;\r\n                    this._isTurning = true;\r\n                }\r\n                let a = this._sign;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._walk) { }\r\n                    else if (this._act._walkback) a = -this._sign;\r\n                    else {\r\n                        anim = (this._sign > 0) ? this._actionMap.turnRight : this._actionMap.turnLeft;\r\n                    }\r\n                } else {\r\n                    if (this._act._walk) a = -this._sign;\r\n                    else if (this._act._walkback) { }\r\n                    else {\r\n                        a = -this._sign;\r\n                        anim = (this._sign > 0) ? this._actionMap.turnLeft : this._actionMap.turnRight;\r\n                    }\r\n                }\r\n                this._avatar.rotation.y = this._avatar.rotation.y + turnAngle * a;\r\n            } else {\r\n                let a = 1;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._walkback) a = -1;\r\n                    if (!moving) anim = this._actionMap.turnLeft;\r\n                } else {\r\n                    if (this._act._walk) a = -1;\r\n                    if (!moving) { a = -1; anim = this._actionMap.turnRight; }\r\n                }\r\n                this._camera.alpha = this._camera.alpha + turnAngle * a;\r\n            }\r\n        }\r\n\r\n        if (this._mode != 1) {\r\n            if (this._noRot) {\r\n                switch (true) {\r\n                    case (this._act._walk && this._act._turnRight):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walk && this._act._turnLeft):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha - Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walkback && this._act._turnRight):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + 3 * Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walkback && this._act._turnLeft):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha - 3 * Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walk):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n                        break;\r\n                    case (this._act._walkback):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + Math.PI;\r\n                        break;\r\n                    case (this._act._turnRight):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + Math.PI / 2;\r\n                        break;\r\n                    case (this._act._turnLeft):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha - Math.PI / 2;\r\n                        break;\r\n                }\r\n            } else {\r\n                this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n            }\r\n        } else {\r\n\r\n        }\r\n\r\n        if (moving) {\r\n            if (this._moveVector.length() > 0.001) {\r\n                this._avatar.moveWithCollisions(this._moveVector);\r\n                //walking up a slope\r\n                if (this._avatar.position.y > this._avStartPos.y) {\r\n                    const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                    const _slp: number = this._verticalSlope(actDisp);\r\n                    if (_slp >= this._sl2) {\r\n                        //this._climbingSteps=true;\r\n                        //is av trying to go up steps\r\n                        if (this._stepOffset > 0) {\r\n                            if (this._vMoveTot == 0) {\r\n                                //if just started climbing note down the position\r\n                                this._vMovStartPos.copyFrom(this._avStartPos);\r\n                            }\r\n                            this._vMoveTot = this._vMoveTot + (this._avatar.position.y - this._avStartPos.y);\r\n                            if (this._vMoveTot > this._stepOffset) {\r\n                                //move av back to its position at begining of steps\r\n                                this._vMoveTot = 0;\r\n                                this._avatar.position.copyFrom(this._vMovStartPos);\r\n                                this._endFreeFall();\r\n                            }\r\n                        } else {\r\n                            //move av back to old position\r\n                            this._avatar.position.copyFrom(this._avStartPos);\r\n                            this._endFreeFall();\r\n                        }\r\n                    } else {\r\n                        this._vMoveTot = 0;\r\n                        if (_slp > this._sl1) {\r\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                            this._fallFrameCount = 0;\r\n                            this._inFreeFall = false;\r\n                        } else {\r\n                            //continue walking\r\n                            this._endFreeFall();\r\n                        }\r\n                    }\r\n                } else if ((this._avatar.position.y) < this._avStartPos.y) {\r\n                    const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                    if (!(this._areVectorsEqual(actDisp, this._moveVector, 0.001))) {\r\n                        //AV is on slope\r\n                        //Should AV continue to slide or walk?\r\n                        //if slope is less steeper than acceptable then walk else slide\r\n                        if (this._verticalSlope(actDisp) <= this._sl1) {\r\n                            this._endFreeFall();\r\n                        } else {\r\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                            this._fallFrameCount = 0;\r\n                            this._inFreeFall = false;\r\n                        }\r\n                    } else {\r\n                        this._inFreeFall = true;\r\n                        this._fallFrameCount++;\r\n                        //AV could be running down a slope which mean freefall,run,frefall run ...\r\n                        //to remove anim flicker, check if AV has been falling down continously for last few consecutive frames\r\n                        //before changing to free fall animation\r\n                        if (this._fallFrameCount > this._fallFrameCountMin) {\r\n                            anim = this._actionMap.fall;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this._endFreeFall();\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _endFreeFall(): void {\r\n        this._movFallTime = 0;\r\n        this._fallFrameCount = 0;\r\n        this._inFreeFall = false;\r\n    }\r\n\r\n    //for how long has the av been falling while idle (not moving)\r\n    private _idleFallTime: number = 0;\r\n    private _doIdle(dt: number): _ActionData {\r\n        if (this._grounded) {\r\n            return this._actionMap.idle;\r\n        }\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n        this._movFallTime = 0;\r\n        let anim: _ActionData = this._actionMap.idle;\r\n        this._fallFrameCount = 0;\r\n\r\n\r\n        if (dt === 0) {\r\n            this._freeFallDist = 5;\r\n        } else {\r\n            const u: number = this._idleFallTime * this._gravity\r\n            this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n            this._idleFallTime = this._idleFallTime + dt;\r\n        }\r\n        //if displacement is less than 0.01(? need to verify further) then \r\n        //moveWithDisplacement down against a surface seems to push the AV up by a small amount!!\r\n        if (this._freeFallDist < 0.01) return anim;\r\n        const disp: Vector3 = new Vector3(0, -this._freeFallDist, 0);\r\n        if (this._mode != 1 && !this._noRot) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        this._avatar.moveWithCollisions(disp);\r\n        if ((this._avatar.position.y > this._avStartPos.y) || (this._avatar.position.y === this._avStartPos.y)) {\r\n            //                this.grounded = true;\r\n            //                this.idleFallTime = 0;\r\n            this._groundIt();\r\n        } else if (this._avatar.position.y < this._avStartPos.y) {\r\n            //AV is going down. \r\n            //AV is either in free fall or is sliding along a downward slope\r\n            //\r\n            //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n            //else it is on a slope\r\n            const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n            if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                //AV is on slope\r\n                //Should AV continue to slide or stop?\r\n                //if slope is less steeper than accebtable then stop else slide\r\n                if (this._verticalSlope(actDisp) <= this._sl1) {\r\n                    //                        this.grounded = true;\r\n                    //                        this.idleFallTime = 0;\r\n                    this._groundIt();\r\n                    this._avatar.position.copyFrom(this._avStartPos);\r\n                } else {\r\n                    this._unGroundIt();\r\n                    anim = this._actionMap.slideBack;\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _groundFrameCount = 0;\r\n    private _groundFrameMax = 10;\r\n    /**\r\n     * donot ground immediately\r\n     * wait few more frames\r\n     */\r\n    private _groundIt(): void {\r\n        this._groundFrameCount++;\r\n        if (this._groundFrameCount > this._groundFrameMax) {\r\n            this._grounded = true;\r\n            this._idleFallTime = 0;\r\n        }\r\n    }\r\n    private _unGroundIt() {\r\n        this._grounded = false;\r\n        this._groundFrameCount = 0;\r\n    }\r\n\r\n    private _savedCameraCollision: boolean = true;\r\n    private _inFP = false;\r\n    private _updateTargetValue() {\r\n        //donot move camera if av is trying to clinb steps\r\n        if (this._vMoveTot == 0)\r\n            this._avatar.position.addToRef(this._cameraTarget, this._camera.target);\r\n\r\n        if (this._camera.radius > this._camera.lowerRadiusLimit) { if (this._cameraElastic) this._snapCamera(); }\r\n\r\n        if (this._camera.radius <= this._camera.lowerRadiusLimit) {\r\n            if (!this._noFirstPerson && !this._inFP) {\r\n                this._avatar.visibility = 0;\r\n                this._camera.checkCollisions = false;\r\n                this._saveMode = this._mode;\r\n                this._mode = 0;\r\n                this._inFP = true;\r\n            }\r\n        } else {\r\n            this._inFP = false;\r\n            this._mode = this._saveMode;\r\n            this._avatar.visibility = 1;\r\n            this._camera.checkCollisions = this._savedCameraCollision;\r\n        }\r\n    }\r\n\r\n    private _ray: Ray = new Ray(Vector3.Zero(), Vector3.One(), 1);\r\n    private _rayDir: Vector3 = Vector3.Zero();\r\n    //camera seems to get stuck into things\r\n    //should move camera away from things by a value of cameraSkin\r\n    private _cameraSkin: number = 0.5;\r\n    private _skip: number = 0;\r\n    private _snapCamera() {\r\n        //            if(this.skip<120) {\r\n        //                this.skip++;\r\n        //                return;\r\n        //            }\r\n        //            this.skip=0;\r\n        //get vector from av (camera.target) to camera\r\n        this._camera.position.subtractToRef(this._camera.target, this._rayDir);\r\n        //start ray from av to camera\r\n        this._ray.origin = this._camera.target;\r\n        this._ray.length = this._rayDir.length();\r\n        this._ray.direction = this._rayDir.normalize();\r\n\r\n        const pi: PickingInfo = this._scene.pickWithRay(this._ray, (mesh) => {\r\n            //if(mesh==this.avatar||!mesh.isPickable||!mesh.checkCollisions) return false;\r\n            if (mesh == this._avatar || !mesh.checkCollisions) return false;\r\n            else return true;\r\n        }, true);\r\n\r\n        if (pi.hit) {\r\n            //postion the camera in front of the mesh that is obstructing camera\r\n            if (this._camera.checkCollisions) {\r\n                const newPos: Vector3 = this._camera.target.subtract(pi.pickedPoint).normalize().scale(this._cameraSkin);\r\n                pi.pickedPoint.addToRef(newPos, this._camera.position);\r\n            } else {\r\n                const nr: number = pi.pickedPoint.subtract(this._camera.target).length();\r\n                this._camera.radius = nr - this._cameraSkin;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _move: boolean = false;\r\n    public anyMovement(): boolean {\r\n        return (this._act._walk || this._act._walkback || this._act._turnLeft || this._act._turnRight || this._act._stepLeft || this._act._stepRight);\r\n    }\r\n\r\n    private _onKeyDown(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        if (e.repeat) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case this._actionMap.idleJump._key:\r\n                this._act._jump = true;\r\n                break;\r\n            case \"capslock\":\r\n                this._act._speedMod = !this._act._speedMod;\r\n                break;\r\n            case \"shift\":\r\n                this._act._speedMod = true;\r\n                break;\r\n            case \"up\":\r\n            case \"arrowup\":\r\n            case this._actionMap.walk._key:\r\n                this._act._walk = true;\r\n                break;\r\n            case \"left\":\r\n            case \"arrowleft\":\r\n            case this._actionMap.turnLeft._key:\r\n                this._act._turnLeft = true;\r\n                break;\r\n            case \"right\":\r\n            case \"arrowright\":\r\n            case this._actionMap.turnRight._key:\r\n                this._act._turnRight = true;\r\n                break;\r\n            case \"down\":\r\n            case \"arrowdown\":\r\n            case this._actionMap.walkBack._key:\r\n                this._act._walkback = true;\r\n                break;\r\n            case this._actionMap.strafeLeft._key:\r\n                this._act._stepLeft = true;\r\n                break;\r\n            case this._actionMap.strafeRight._key:\r\n                this._act._stepRight = true;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    private _onKeyUp(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case \"shift\":\r\n                this._act._speedMod = false;\r\n                break;\r\n            case \"up\":\r\n            case \"arrowup\":\r\n            case this._actionMap.walk._key:\r\n                this._act._walk = false;\r\n                break;\r\n            case \"left\":\r\n            case \"arrowleft\":\r\n            case this._actionMap.turnLeft._key:\r\n                this._act._turnLeft = false;\r\n                this._isTurning = false;\r\n                break;\r\n            case \"right\":\r\n            case \"arrowright\":\r\n            case this._actionMap.turnRight._key:\r\n                this._act._turnRight = false;\r\n                this._isTurning = false;\r\n                break;\r\n            case \"down\":\r\n            case \"arrowdown\":\r\n            case this._actionMap.walkBack._key:\r\n                this._act._walkback = false;\r\n                break;\r\n            case this._actionMap.strafeLeft._key:\r\n                this._act._stepLeft = false;\r\n                break;\r\n            case this._actionMap.strafeRight._key:\r\n                this._act._stepRight = false;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    private _ekb: boolean;\r\n    public enableKeyBoard(b: boolean) {\r\n        this._ekb = b;\r\n        let canvas: HTMLCanvasElement = this._scene.getEngine().getRenderingCanvas();\r\n        if (b) {\r\n            canvas.addEventListener(\"keyup\", this._handleKeyUp, false);\r\n            canvas.addEventListener(\"keydown\", this._handleKeyDown, false);\r\n        } else {\r\n            canvas.removeEventListener(\"keyup\", this._handleKeyUp, false);\r\n            canvas.removeEventListener(\"keydown\", this._handleKeyDown, false);\r\n        }\r\n    }\r\n\r\n    // control movement by commands rather than keyboard.\r\n    public walk(b: boolean) {\r\n        this._act._walk = b;\r\n    }\r\n    public walkBack(b: boolean) {\r\n        this._act._walkback = b;\r\n    }\r\n    public walkBackFast(b: boolean) {\r\n        this._act._walkback = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public run(b: boolean) {\r\n        this._act._walk = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public turnLeft(b: boolean) {\r\n        this._act._turnLeft = b;\r\n        if (!b) this._isTurning = b;\r\n    }\r\n    public turnLeftFast(b: boolean) {\r\n        this._act._turnLeft = b;\r\n        if (!b) this._isTurning = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public turnRight(b: boolean) {\r\n        this._act._turnRight = b;\r\n        if (!b) this._isTurning = b;\r\n    }\r\n    public turnRightFast(b: boolean) {\r\n        this._act._turnRight = b;\r\n        if (!b) this._isTurning = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public strafeLeft(b: boolean) {\r\n        this._act._stepLeft = b;\r\n    }\r\n    public strafeLeftFast(b: boolean) {\r\n        this._act._stepLeft = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public strafeRight(b: boolean) {\r\n        this._act._stepRight = b;\r\n    }\r\n    public strafeRightFast(b: boolean) {\r\n        this._act._stepRight = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public jump() {\r\n        this._act._jump = true;\r\n    }\r\n    public idle() {\r\n        this._act.reset();\r\n    }\r\n\r\n    private _act: _Action;\r\n    private _renderer: () => void;\r\n    private _handleKeyUp: (e) => void;\r\n    private _handleKeyDown: (e) => void;\r\n    private _isAG: boolean = false;\r\n    public isAg() {\r\n        return this._isAG;\r\n    }\r\n\r\n\r\n\r\n\r\n    private _findSkel(n: Node): Skeleton {\r\n        let root = this._root(n);\r\n\r\n        if (root instanceof Mesh && root.skeleton) return root.skeleton;\r\n\r\n        //find all child meshes which have skeletons\r\n        let ms = root.getChildMeshes(\r\n            false,\r\n            (cm) => {\r\n                if (cm instanceof Mesh) {\r\n                    if (cm.skeleton) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            });\r\n\r\n        //return the skeleton of the first child mesh\r\n        if (ms.length > 0) return ms[0].skeleton; else return null;\r\n\r\n    }\r\n\r\n    private _root(tn: Node): Node {\r\n        if (tn.parent == null) return tn;\r\n        return this._root(tn.parent);\r\n    }\r\n\r\n    public setAvatar(avatar: Mesh, faceForward: boolean = false): boolean {\r\n\r\n        let rootNode = this._root(avatar);\r\n        if (rootNode instanceof Mesh) {\r\n            this._avatar = rootNode;\r\n        } else {\r\n            console.error(\"Cannot move this mesh. The root node of the mesh provided is not a mesh\");\r\n            return false;\r\n        }\r\n\r\n\r\n        this._skeleton = this._findSkel(avatar);\r\n        //skeletons animated by animation groups seem to have \"overrideMesh\" property\r\n        if (this._skeleton != null && this._skeleton.overrideMesh) this._isAG = true;\r\n\r\n        this._actionMap = new _ActionMap();\r\n\r\n        //animation ranges\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n\r\n        this._setRHS(avatar);\r\n        this.setFaceForward(faceForward);\r\n\r\n        return true;\r\n    }\r\n\r\n    public getAvatar() {\r\n        return this._avatar;\r\n    }\r\n\r\n    // force a skeleton to be the avatar skeleton\r\n    // should not be calling this normally\r\n    public setAvatarSkeleton(skeleton: Skeleton) {\r\n        this._skeleton = skeleton;\r\n\r\n        //skeletons animated by animation groups seem to have \"overrideMesh\" property\r\n        if (this._skeleton != null && this._skeleton.overrideMesh) this._isAG = true;\r\n\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n    }\r\n\r\n    public getSkeleton() {\r\n        return this._skeleton;\r\n    }\r\n\r\n    // does this character have any animations ?\r\n    // remember we can use meshes without anims as characters too\r\n    private _hasAnims: boolean = false;\r\n\r\n    /**\r\n     * The avatar/character can be made up of multiple meshes arranged in a hierarchy.\r\n     * As such we will pick the root of the hierarchy as the avatar.\r\n     * The root should be a mesh as otherwise we cannot move it with moveWithCollision() method.\r\n     * \r\n     * Mutiple meshes in the hierarchy may have skeletons (if two or more meshes have skeleton then\r\n     * the skeleton will mostly likely be the same). \r\n     * So we will pick as avatar skeleton, the  skeleton of the first mesh in the hierachy which has\r\n     * a skeleton \r\n     * \r\n     * @param avatar \r\n     * @param camera \r\n     * @param scene \r\n     * @param actionData - maps actions to animations and other data like speed,sound etc\r\n     * @param faceForward \r\n     */\r\n    constructor(avatar: Mesh, camera: ArcRotateCamera, scene: Scene, actionData?: {}, faceForward = false) {\r\n\r\n        let success = this.setAvatar(avatar, faceForward);\r\n        if (!success) {\r\n            console.error(\"unable to set avatar\");\r\n        }\r\n\r\n        this._scene = scene;\r\n\r\n        let dataType: string = null;\r\n        if (actionData != null) {\r\n            dataType = this.setActionData(actionData);\r\n        }\r\n\r\n        //try to use the existing avatar animations\r\n\r\n        //animation ranges\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n        //animation groups\r\n        if (this._isAG) {\r\n\r\n        }\r\n\r\n        this._camera = camera;\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n\r\n        this._act = new _Action();\r\n\r\n        this._renderer = () => { this._moveAVandCamera() };\r\n        this._handleKeyUp = (e) => { this._onKeyUp(e) };\r\n        this._handleKeyDown = (e) => { this._onKeyDown(e) };\r\n    }\r\n}\r\n\r\n\r\n\r\nclass _Action {\r\n\r\n    public _walk: boolean = false;\r\n    public _walkback: boolean = false;\r\n    public _turnRight: boolean = false;\r\n    public _turnLeft: boolean = false;\r\n    public _stepRight: boolean = false;\r\n    public _stepLeft: boolean = false;\r\n    public _jump: boolean = false;\r\n\r\n    // speed modifier - changes speed of movement\r\n    public _speedMod: boolean = false;\r\n\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    reset() {\r\n        this._walk = false;\r\n        this._walkback = false;\r\n        this._turnRight = false;\r\n        this._turnLeft = false;\r\n        this._stepRight = false;\r\n        this._stepLeft = false;\r\n        this._jump = false;\r\n        this._speedMod = false;\r\n    }\r\n}\r\n\r\nclass _ActionData {\r\n    public _id: string;\r\n    public _speed: number;\r\n    public _sound: string;\r\n    public _key: string;\r\n\r\n    //_name will be used to play animationrange\r\n    public _name: string;\r\n    public _ag: AnimationGroup;\r\n\r\n    public _loop: boolean = true;\r\n    public _rate: number = 1;\r\n\r\n    public _exist: boolean = false;\r\n\r\n    public constructor(id: string, speed = 1, key: string) {\r\n        this._id = id;\r\n        this._name = id;\r\n        this._speed = speed;\r\n        this._key = key;\r\n    }\r\n}\r\n\r\nclass _ActionMap {\r\n    public walk = new _ActionData(\"walk\", 3, \"w\");\r\n    public walkBack = new _ActionData(\"walkBack\", 1.5, \"s\");\r\n    public walkBackFast = new _ActionData(\"walkBackFast\", 3, \"na\");\r\n    public idle = new _ActionData(\"idle\", 0, \"na\");\r\n    public idleJump = new _ActionData(\"idleJump\", 6, \" \");\r\n    public run = new _ActionData(\"run\", 6, \"na\");\r\n    public runJump = new _ActionData(\"runJump\", 6, \"na\");\r\n    public fall = new _ActionData(\"fall\", 0, \"na\");\r\n    public turnLeft = new _ActionData(\"turnLeft\", Math.PI / 8, \"a\");\r\n    public turnLeftFast = new _ActionData(\"turnLeftFast\", Math.PI / 4, \"na\");\r\n    public turnRight = new _ActionData(\"turnRight\", Math.PI / 8, \"d\");\r\n    public turnRightFast = new _ActionData(\"turnRightFast\", Math.PI / 4, \"na\");\r\n    public strafeLeft = new _ActionData(\"strafeLeft\", 1.5, \"q\");\r\n    public strafeLeftFast = new _ActionData(\"strafeLeftFast\", 3, \"na\");\r\n    public strafeRight = new _ActionData(\"strafeRight\", 1.5, \"e\");\r\n    public strafeRightFast = new _ActionData(\"strafeRightFast\", 3, \"na\");\r\n    public slideBack = new _ActionData(\"slideBack\", 0, \"na\")\r\n};\r\n\r\nexport class CCSettings {\r\n    public gravity: number;\r\n    public minSlopeLimit: number;\r\n    public maxSlopeLimit: number;\r\n    public stepOffset: number;\r\n    public cameraElastic: boolean = true;\r\n    public cameraTarget: Vector3 = Vector3.Zero();\r\n    public noFirstPerson: boolean = false;\r\n    public turningOff: boolean = true;\r\n    public cameraRotate: boolean = true;\r\n    public keyboard: boolean = true;\r\n}\r\n"],"sourceRoot":""}