{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///external {\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\",\"root\":\"BABYLON\"}","webpack:///./src/CharacterController.ts"],"names":["root","factory","exports","module","require","define","amd","a","i","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","avatar","camera","scene","agMap","faceForward","_gravity","_minSlopeLimit","_maxSlopeLimit","_sl1","Math","PI","this","_sl2","_stepOffset","_vMoveTot","_vMovStartPos","Zero","_actMap","_ActMap","_walkKey","_walkBackKey","_turnLeftKey","_turnRightKey","_strafeLeftKey","_strafeRightKey","_jumpKey","_elasticCamera","_cameraTarget","_noFirstPerson","_saveMode","_isRHS","_signRHS","_started","_stopAnim","_prevAnim","_avStartPos","_grounded","_freeFallDist","_fallFrameCountMin","_fallFrameCount","_inFreeFall","_wasWalking","_wasRunning","_jumpStartPosY","_jumpTime","_movFallTime","_sign","_isTurning","_noRot","_idleFallTime","_groundFrameCount","_groundFrameMax","_savedCameraCollision","_inFP","_ray","One","_rayDir","_cameraSkin","_skip","_move","_isAG","_hasAnims","_avatar","_setRHS","setFaceForward","_scene","setAnimationGroups","_skeleton","skeleton","checkAnims","_camera","checkCollisions","_act","_Action","_renderer","_moveAVandCamera","_handleKeyUp","e","_onKeyUp","_handleKeyDown","_onKeyDown","setAvatar","setAvatarSkeleton","setSlopeLimit","minSlopeLimit","maxSlopeLimit","setStepOffset","stepOffset","setWalkSpeed","walk","_speed","setRunSpeed","run","setBackSpeed","walkBack","setBackFastSpeed","walkBackFast","setJumpSpeed","idleJump","runJump","setLeftSpeed","strafeLeft","setLeftFastSpeed","strafeLeftFast","setRightSpeed","strafeRight","setRightFastSpeed","setTurnSpeed","turnLeft","turnRight","setTurnFastSpeed","turnLeftFast","turnRightFast","setGravity","agData","_exist","_ag","stop","keys","anim","_AnimData","_id","_name","_loop","_rate","_checkFastAnims","setAnimationRanges","arMap","arData","getAnimationMap","map","data","_setAnim","rangeName","rate","loop","speedRatio","getAnimationRange","enableBlending","act","targetedAnimations","ta","animation","blendingSpeed","disableBlending","setWalkAnim","setRunAnim","setWalkBackAnim","_copySlowAnims","setWalkBackFastAnim","setSlideBackAnim","slideBack","setIdleAnim","idle","setTurnRightAnim","setTurnRightFastAnim","setTurnLeftAnim","setTurnLeftFastAnim","setStrafeRightAnim","strafeRightFast","setStrafeRightFastAnim","setStrafeLeftAnim","setStrafeLeftFastAnim","setIdleJumpAnim","setRunJumpAnim","setFallAnim","fall","setWalkKey","toLowerCase","setWalkBackKey","setTurnLeftKey","setTurnRightKey","setStrafeLeftKey","setStrafeRightKey","setJumpKey","setCameraElasticity","b","setCameraTarget","v","copyFrom","cameraCollisionChanged","setNoFirstPerson","skel","f","setMode","setTurningOff","mesh","meshMatrix","getWorldMatrix","_localX","FromFloatArray","_localY","_localZ","actualZ","Cross","Dot","_av2cam","_ffSign","checkAGs","start","reset","_updateTargetValue","enableKeyBoard","registerBeforeRender","unregisterBeforeRender","pauseAnim","resumeAnim","_isAvFacingCamera","forward","position","subtract","dt","getEngine","getDeltaTime","_jump","_doJump","anyMovement","_doMove","_doIdle","beginAnimation","y","disp","forwardDist","jumpDist","rotation","alpha","_moveVector","clone","normalize","scaleToRef","_calcJumpDist","moveWithCollisions","length","_endJump","actDisp","_areVectorsEqual","_verticalSlope","speed","v1","v2","abs","x","z","atan","sqrt","u","moving","sign","horizDist","_speedMod","calcMovePOV","_walk","_stepLeft","_stepRight","_turnLeft","_turnRight","turnAngle","_walkback","_slp","_endFreeFall","_groundIt","_unGroundIt","addToRef","target","radius","lowerRadiusLimit","_snapCamera","visibility","subtractToRef","origin","direction","pi","pickWithRay","hit","newPos","pickedPoint","scale","nr","repeat","canvas","getRenderingCanvas","addEventListener","removeEventListener","jump","id","_walkSpeed"],"mappings":"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","file":"CharacterController.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"babylonjs\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"babylonjs\")) : factory(root[\"BABYLON\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import {\r\n    Skeleton,\r\n    ArcRotateCamera,\r\n    Vector3,\r\n    Mesh,\r\n    Scene,\r\n    Ray,\r\n    PickingInfo,\r\n    AnimationGroup,\r\n    TransformNode,\r\n    Matrix\r\n} from \"babylonjs\"\r\n\r\nexport class CharacterController {\r\n\r\n    private _avatar: Mesh;\r\n    private _skeleton: Skeleton;\r\n    private _camera: ArcRotateCamera;\r\n    private _scene: Scene;\r\n\r\n\r\n    private _gravity: number = 9.8;\r\n    //slopeLimit in degrees\r\n    private _minSlopeLimit: number = 30;\r\n    private _maxSlopeLimit: number = 45;\r\n    //slopeLimit in radians\r\n    private _sl1: number = Math.PI * this._minSlopeLimit / 180;\r\n    private _sl2: number = Math.PI * this._maxSlopeLimit / 180;\r\n\r\n    //The av will step up a stair only if it is closer to the ground than the indicated value.\r\n    private _stepOffset: number = 0.25;\r\n    //toal amount by which the av has moved up\r\n    private _vMoveTot: number = 0;\r\n    //position of av when it started moving up\r\n    private _vMovStartPos: Vector3 = Vector3.Zero();\r\n\r\n    //avatar speed in meters/second\r\n    // private _walkSpeed: number = 3;\r\n    // private _walkFastSpeed: number = this._walkSpeed * 2;\r\n    // private _runSpeed: number = this._walkSpeed * 2;\r\n    // private _backSpeed: number = this._walkSpeed / 2;\r\n    // private _backFastSpeed: number = this._backSpeed * 2;\r\n    // private _jumpSpeed: number = this._walkSpeed * 2;\r\n    // private _leftSpeed: number = this._walkSpeed / 2;\r\n    // private _leftFastSpeed: number = this._leftSpeed * 2;\r\n    // private _rightSpeed: number = this._walkSpeed / 2;\r\n    // private _rightFastSpeed: number = this._rightSpeed * 2;\r\n    // //trun speed in radian per second (equivalent to 180 degree/second by default)\r\n    // private _turnSpeed: number = Math.PI / 8;\r\n    // private _turnFastSpeed: number = this._turnSpeed * 2;\r\n\r\n    //animations\r\n    //private _walk: _AnimData = new _AnimData(\"walk\",3);\r\n    // private _walkBack: _AnimData = new _AnimData(\"walkBack\",this._walk._speed/2);\r\n    // private _walkBackFast: _AnimData = new _AnimData(\"walkBackFast\",this._walk._speed);\r\n    // private _idle: _AnimData = new _AnimData(\"idle\",0);\r\n    // private _idleJump: _AnimData = new _AnimData(\"idleJump\",this._walk._speed*2);\r\n    // private _run: _AnimData = new _AnimData(\"run\",this._walk._speed*2);\r\n    // private _runJump: _AnimData = new _AnimData(\"runJump\",this._walk._speed*2);\r\n    // private _fall: _AnimData = new _AnimData(\"fall\",0);\r\n    // private _turnLeft: _AnimData = new _AnimData(\"turnLeft\",Math.PI / 8);\r\n    // private _turnLeftFast: _AnimData = new _AnimData(\"turnLeftFast\",Math.PI / 4);\r\n    // private _turnRight: _AnimData = new _AnimData(\"turnRight\",Math.PI / 8);\r\n    // private _turnRightFast: _AnimData = new _AnimData(\"turnRightFast\",Math.PI / 4);\r\n    // private _strafeLeft: _AnimData = new _AnimData(\"strafeLeft\",this._walk._speed/2);\r\n    // private _strafeLeftFast: _AnimData = new _AnimData(\"strafeLeftFast\",this._walk._speed);\r\n    // private _strafeRight: _AnimData = new _AnimData(\"strafeRight\",this._walk._speed/2);\r\n    // private _strafeRightFast: _AnimData = new _AnimData(\"strafeRightFast\",this._walk._speed);\r\n    // private _slideBack: _AnimData = new _AnimData(\"slideBack\",0);\r\n\r\n    // private _anims: _AnimData[] = [this._walk, this._walkBack, this._walkBackFast, this._idle, this._idleJump, this._run, this._runJump, this._fall, this._turnLeft, this._turnLeftFast, this._turnRight, this._turnRightFast, this._strafeLeft, this._strafeLeftFast, this._strafeRight, this._strafeRightFast, this._slideBack];\r\n\r\n    // private _actMap: {} = {\r\n    //     \"walk\":new _AnimData(\"walk\",3), \r\n    //     \"walkBack\":new _AnimData(\"walkBack\",this._walkSpeed/2), \r\n    //     \"walkBackFast\":new _AnimData(\"walkBackFast\",this._walkSpeed), \r\n    //     \"idle\":new _AnimData(\"idle\",0), \r\n    //     \"idleJump\":new _AnimData(\"idleJump\",this._walkSpeed*2), \r\n    //     \"run\":new _AnimData(\"run\",this._walkSpeed*2), \r\n    //     \"runJump\":new _AnimData(\"runJump\",this._walkSpeed*2), \r\n    //     \"fall\":new _AnimData(\"fall\",0), \r\n    //     \"turnLeft\":new _AnimData(\"turnLeft\",Math.PI / 8), \r\n    //     \"turnLeftFast\":new _AnimData(\"turnLeftFast\",Math.PI / 4), \r\n    //     \"turnRight\":new _AnimData(\"turnRight\",Math.PI / 8), \r\n    //     \"turnRightFast\":new _AnimData(\"turnRightFast\",Math.PI / 4), \r\n    //     \"strafeLeft\":new _AnimData(\"strafeLeft\",this._walkSpeed/2), \r\n    //     \"strafeLeftFast\":new _AnimData(\"strafeLeftFast\",this._walkSpeed), \r\n    //     \"strafeRight\":new _AnimData(\"strafeRight\",this._walkSpeed/2), \r\n    //     \"strafeRightFast\":new _AnimData(\"strafeRightFast\",this._walkSpeed), \r\n    //     \"slideBack\":new _AnimData(\"slideBack\",0)\r\n    // };\r\n\r\n    private _actMap: _ActMap = new _ActMap();\r\n\r\n\r\n    //move keys\r\n    private _walkKey: string = \"w\";\r\n    private _walkBackKey: string = \"s\";\r\n    private _turnLeftKey: string = \"a\";\r\n    private _turnRightKey: string = \"d\";\r\n    private _strafeLeftKey: string = \"q\";\r\n    private _strafeRightKey: string = \"e\";\r\n    private _jumpKey: string = \" \";\r\n\r\n    private _elasticCamera: boolean = true;\r\n    private _cameraTarget: Vector3 = Vector3.Zero();\r\n    //should we go into first person view when camera is near avatar (radius is lowerradius limit)\r\n    private _noFirstPerson: boolean = false;\r\n\r\n    public setAvatar(avatar: Mesh, faceForward: boolean = false) {\r\n        this._avatar = avatar;\r\n        this._setRHS(avatar);\r\n        this.setFaceForward(faceForward);\r\n    }\r\n\r\n    public setAvatarSkeleton(skeleton: Skeleton) {\r\n        this._skeleton = skeleton;\r\n        this.checkAnims(skeleton);\r\n    }\r\n\r\n    public setSlopeLimit(minSlopeLimit: number, maxSlopeLimit: number) {\r\n        this._minSlopeLimit = minSlopeLimit;\r\n        this._maxSlopeLimit = maxSlopeLimit;\r\n\r\n        this._sl1 = Math.PI * this._minSlopeLimit / 180;\r\n        this._sl2 = Math.PI * this._maxSlopeLimit / 180;\r\n    }\r\n\r\n    /**\r\n     * The av will step up a stair only if it is closer to the ground than the indicated value.\r\n     * Default value is 0.25 m\r\n     */\r\n    public setStepOffset(stepOffset: number) {\r\n        this._stepOffset = stepOffset;\r\n    }\r\n\r\n    public setWalkSpeed(n: number) {\r\n        this._actMap.walk._speed = n;\r\n    }\r\n    public setRunSpeed(n: number) {\r\n        this._actMap.run._speed = n;\r\n    }\r\n    public setBackSpeed(n: number) {\r\n        this._actMap.walkBack._speed = n;\r\n    }\r\n    public setBackFastSpeed(n: number) {\r\n        this._actMap.walkBackFast._speed = n;\r\n    }\r\n    public setJumpSpeed(n: number) {\r\n        this._actMap.idleJump._speed = n;\r\n        this._actMap.runJump._speed = n;\r\n    }\r\n    public setLeftSpeed(n: number) {\r\n        this._actMap.strafeLeft._speed = n;\r\n    }\r\n    public setLeftFastSpeed(n: number) {\r\n        this._actMap.strafeLeftFast._speed = n;\r\n    }\r\n    public setRightSpeed(n: number) {\r\n        this._actMap.strafeRight._speed = n;\r\n    }\r\n    public setRightFastSpeed(n: number) {\r\n        this._actMap.strafeLeftFast._speed = n;\r\n    }\r\n    // get turnSpeed in degrees per second.\r\n    // store in radians per second\r\n    public setTurnSpeed(n: number) {\r\n        this._actMap.turnLeft._speed = n * Math.PI / 180;\r\n        this._actMap.turnRight._speed = n * Math.PI / 180;\r\n    }\r\n    public setTurnFastSpeed(n: number) {\r\n        this._actMap.turnLeftFast._speed = n * Math.PI / 180;\r\n        this._actMap.turnRightFast._speed = n * Math.PI / 180;\r\n    }\r\n    public setGravity(n: number) {\r\n        this._gravity = n;\r\n    }\r\n\r\n    /**\r\n     * Use this to provide animationGroups to the character controller.\r\n     * Provide the AnimationGroups using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animationGroup.\r\n     * Example:\r\n     * let myWalkAnimationGroup:AnimationGroup = ...;\r\n     * let agMap:{} = {\r\n     *  \"walk\":myWalkAnimationGroup,\r\n     *  \"run\" : {\"ag\":myRunAnimationGroup,\"rate\":1},\r\n     *  \"idle\" : {\"ag\":myIdleAnimationGroup,\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     *   ....\r\n     * }\r\n     * \r\n     * @param agMap a map of character controller animation name to animationGroup\r\n     */\r\n    public setAnimationGroups(agMap: {}) {\r\n        if (this._prevAnim != null && this._prevAnim._exist) this._prevAnim._ag.stop();\r\n        this._isAG = true;\r\n        let agData: AnimationGroup | {};\r\n        let keys: string[] = Object.keys(this._actMap);\r\n        for (let key of keys) {\r\n            let anim = this._actMap[key];\r\n            if (!(anim instanceof _AnimData)) continue;\r\n            anim._exist = false;\r\n            agData = agMap[anim._id];\r\n            if (agData != null) {\r\n                if (agData instanceof AnimationGroup) {\r\n                    anim._ag = agData;\r\n                    anim._name = anim._ag.name\r\n                    anim._exist = true;\r\n                } else {\r\n                    if (agData[\"ag\"]) {\r\n                        anim._ag = agData[\"ag\"];\r\n                        if (agData[\"loop\"] != null) anim._loop = agData[\"loop\"];\r\n                        if (agData[\"rate\"]) anim._rate = agData[\"rate\"];\r\n                        if (agData[\"speed\"]) anim._speed = agData[\"speed\"];\r\n                        anim._exist = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._checkFastAnims();\r\n        //force to play new anims\r\n        this._prevAnim = null;\r\n    }\r\n    /**\r\n     * Use this to provide AnimationRanges to the character controller.\r\n     * Provide the AnimationRanges using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animation range name or an object with animation range data.\r\n     * example:\r\n     * let arMap = {\r\n     *  \"walk\":\"myWalk\",\r\n     *  \"run\" : {\"name\":\"myRun\",\"rate\":1},\r\n     *  \"idle\" : {\"name\":\"myIdle\",\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     * }\r\n     * \r\n     * @param arMap a map of character controller animation name to animationRange data\r\n     */\r\n\r\n    public setAnimationRanges(arMap: {}) {\r\n        this._isAG = false;\r\n        let arData: string | {};\r\n        let keys: string[] = Object.keys(this._actMap);\r\n        for (let key of keys) {\r\n            let anim = this._actMap[key];\r\n            if (!(anim instanceof _AnimData)) continue;\r\n            anim._exist = false;\r\n            arData = arMap[anim._id];\r\n            if (arData != null) {\r\n                if (arData instanceof Object) {\r\n                    if (arData[\"name\"]) {\r\n                        anim._name = arData[\"name\"];\r\n                        if (arData[\"loop\"] != null) anim._loop = arData[\"loop\"];\r\n                        if (arData[\"rate\"]) anim._rate = arData[\"rate\"];\r\n                        if (arData[\"speed\"]) anim._speed = arData[\"speed\"];\r\n                        anim._exist = true;\r\n                    }\r\n                } else {\r\n                    anim._name = arData;\r\n                    anim._exist = true;\r\n                }\r\n            }\r\n        }\r\n        this._checkFastAnims();\r\n        //force to play new anims\r\n        this._prevAnim = null;\r\n\r\n\r\n    }\r\n\r\n    public getAnimationMap(): {} {\r\n        let map = {};\r\n\r\n        let keys: string[] = Object.keys(this._actMap);\r\n        for (let key of keys) {\r\n            let anim = this._actMap[key];\r\n            if (!(anim instanceof _AnimData)) continue;\r\n            if (anim._exist) {\r\n                let data = {};\r\n\r\n                if (this._isAG) data[\"ag\"] = anim._ag;\r\n                else data[\"name\"] = anim._name;\r\n                data[\"loop\"] = anim._loop;\r\n                data[\"rate\"] = anim._rate;\r\n                data[\"speed\"] = anim._speed;\r\n\r\n                map[anim._id] = data;\r\n            }\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    private _setAnim(anim: _AnimData, rangeName?: string | AnimationGroup, rate?: number, loop?: boolean) {\r\n        if (!this._isAG && this._skeleton == null) return;\r\n        if (loop != null) anim._loop = loop;\r\n        if (!this._isAG) {\r\n            if (rangeName != null) anim._name = <string>rangeName;\r\n            if (rate != null) anim._rate = rate;\r\n            if (this._skeleton.getAnimationRange(anim._name) != null) {\r\n                anim._exist = true;\r\n            } else {\r\n                anim._exist = false;\r\n            }\r\n        } else {\r\n            if (rangeName != null) {\r\n                anim._ag = <AnimationGroup>rangeName;\r\n                anim._exist = true;\r\n            }\r\n            if (rate != null && anim._exist) {\r\n                anim._rate = rate;\r\n                anim._ag.speedRatio = rate;\r\n            }\r\n        }\r\n    }\r\n\r\n    public enableBlending(n: number) {\r\n        if (this._isAG) {\r\n            let keys: string[] = Object.keys(this._actMap);\r\n            for (let key of keys) {\r\n                let act = this._actMap[key];\r\n                if (!(act instanceof _AnimData)) continue;\r\n                if (act._exist) {\r\n                    let ar: AnimationGroup = act._ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = true;\r\n                        ta.animation.blendingSpeed = n;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            this._skeleton.enableBlending(n);\r\n        }\r\n    }\r\n\r\n    public disableBlending() {\r\n        if (this._isAG) {\r\n            let keys: string[] = Object.keys(this._actMap);\r\n            for (let key of keys) {\r\n                let anim = this._actMap[key];\r\n                if (!(anim instanceof _AnimData)) continue;\r\n                if (anim._exist) {\r\n                    let ar: AnimationGroup = anim._ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //setters for animations\r\n    public setWalkAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.walk, rangeName, rate, loop);\r\n    }\r\n    public setRunAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.run, rangeName, rate, loop);\r\n    }\r\n    public setWalkBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.walkBack, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actMap.walkBackFast, this._actMap.walkBack);\r\n    }\r\n    public setWalkBackFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.walkBackFast, rangeName, rate, loop);\r\n    }\r\n    public setSlideBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.slideBack, rangeName, rate, loop);\r\n    }\r\n    public setIdleAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.idle, rangeName, rate, loop);\r\n    }\r\n    public setTurnRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.turnRight, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actMap.turnRightFast, this._actMap.turnRight);\r\n    }\r\n    public setTurnRightFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.turnRightFast, rangeName, rate, loop);\r\n    }\r\n    public setTurnLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.turnLeft, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actMap.turnLeftFast, this._actMap.turnLeft);\r\n    }\r\n    public setTurnLeftFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.turnLeftFast, rangeName, rate, loop);\r\n    }\r\n    public setStrafeRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.strafeRight, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actMap.strafeRightFast, this._actMap.strafeRight);\r\n    }\r\n    public setStrafeRightFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.strafeRightFast, rangeName, rate, loop);\r\n    }\r\n    public setStrafeLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.strafeLeft, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actMap.strafeLeftFast, this._actMap.strafeLeft);\r\n    }\r\n    public setStrafeLeftFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.strafeLeftFast, rangeName, rate, loop);\r\n    }\r\n    public setIdleJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.idleJump, rangeName, rate, loop);\r\n    }\r\n    public setRunJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.runJump, rangeName, rate, loop);\r\n    }\r\n    public setFallAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actMap.fall, rangeName, rate, loop);\r\n    }\r\n\r\n    // setters for keys\r\n    public setWalkKey(key: string) {\r\n        this._walkKey = key.toLowerCase();\r\n    }\r\n    public setWalkBackKey(key: string) {\r\n        this._walkBackKey = key.toLowerCase();\r\n    }\r\n    public setTurnLeftKey(key: string) {\r\n        this._turnLeftKey = key.toLowerCase();\r\n    }\r\n    public setTurnRightKey(key: string) {\r\n        this._turnRightKey = key.toLowerCase();\r\n    }\r\n    public setStrafeLeftKey(key: string) {\r\n        this._strafeLeftKey = key.toLowerCase();\r\n    }\r\n    public setStrafeRightKey(key: string) {\r\n        this._strafeRightKey = key.toLowerCase();\r\n    }\r\n    public setJumpKey(key: string) {\r\n        this._jumpKey = key.toLowerCase();\r\n    }\r\n\r\n    public setCameraElasticity(b: boolean) {\r\n        this._elasticCamera = b;\r\n    }\r\n    public setCameraTarget(v: Vector3) {\r\n        this._cameraTarget.copyFrom(v);\r\n    }\r\n\r\n\r\n    /**\r\n     * user should call this whenever the user changes the camera checkCollision \r\n     * property\r\n     * \r\n     */\r\n    public cameraCollisionChanged() {\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n    }\r\n    public setNoFirstPerson(b: boolean) {\r\n        this._noFirstPerson = b;\r\n    }\r\n\r\n\r\n    private checkAnims(skel: Skeleton) {\r\n        let keys: string[] = Object.keys(this._actMap);\r\n        for (let key of keys) {\r\n            let anim = this._actMap[key];\r\n            if (!(anim instanceof _AnimData)) continue;\r\n            if (skel != null) {\r\n                if (skel.getAnimationRange(anim._name) != null) anim._exist = true;\r\n            } else {\r\n                anim._exist = false;\r\n            }\r\n        }\r\n        this._checkFastAnims();\r\n    }\r\n\r\n    /**\r\n     * if fast anims do not exist then use their slow counterpart as them but double the rate at which they play\r\n     */\r\n    private _checkFastAnims() {\r\n        this._copySlowAnims(this._actMap.walkBackFast, this._actMap.walkBack)\r\n        this._copySlowAnims(this._actMap.turnRightFast, this._actMap.turnRight);\r\n        this._copySlowAnims(this._actMap.turnLeftFast, this._actMap.turnLeft);\r\n        this._copySlowAnims(this._actMap.strafeRightFast, this._actMap.strafeRight);\r\n        this._copySlowAnims(this._actMap.strafeLeftFast, this._actMap.strafeLeft);\r\n    }\r\n\r\n    private _copySlowAnims(f: _AnimData, s: _AnimData) {\r\n        if (f._exist) return;\r\n        if (!s._exist) return;\r\n        f._exist = true;\r\n        f._ag = s._ag;\r\n        f._name = s._name;\r\n        f._rate = s._rate * 2;\r\n    }\r\n\r\n    /**\r\n     * Use this to make the  character controller suitable for a isometeric/top down games or  fps/third person game.\r\n     * 1 In isometric/top down games the camera direction has no bearing on avatar movement.\r\n     * 0 In fps/third person game rotating the camera around the avatar , rotates the avatr too.\r\n     */\r\n    private mode = 0;\r\n    private _saveMode = 0;\r\n    public setMode(n: number) {\r\n        this.mode = n;\r\n        this._saveMode = n;\r\n    }\r\n    /**\r\n     * Use this to set  turning off.\r\n     * When turining is off \r\n     * a) turn left or turn right keys result in avatar facing and moving left or right with respect to camera.\r\n     * b) walkback/runback key results in avatar facing back and walking/running towards camera.\r\n     * \r\n     * This setting has no effect when mode is 1.\r\n     * \r\n     * @param b \r\n     */\r\n    public setTurningOff(b: boolean) {\r\n        this._noRot = b;\r\n    }\r\n\r\n    /**\r\n        * checks if a have left hand , right hand issue.\r\n        * In other words if a mesh is a LHS mesh in RHS system or \r\n        * a RHS mesh in LHS system\r\n        * The X axis will be reversed in such cases.\r\n        * thus Cross product of X and Y should be inverse of Z.\r\n        * BABYLONJS GLB models are RHS and exhibit this behavior\r\n        * \r\n        */\r\n    private _isRHS = false;\r\n    private _signRHS = -1;\r\n    private _setRHS(mesh: TransformNode) {\r\n        const meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        const _localX = Vector3.FromFloatArray(meshMatrix.m, 0);\r\n        const _localY = Vector3.FromFloatArray(meshMatrix.m, 4);\r\n        const _localZ = Vector3.FromFloatArray(meshMatrix.m, 8);\r\n        const actualZ = Vector3.Cross(_localX, _localY);\r\n        //same direction or opposite direction of Z\r\n        if (Vector3.Dot(actualZ, _localZ) < 0) {\r\n            this._isRHS = true;\r\n            this._signRHS = 1;\r\n        }\r\n        else {\r\n            this._isRHS = false;\r\n            this._signRHS = -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use setFaceForward(true|false) to indicate that the avatar face  faces forward (true) or backward (false).\r\n     * The avatar face faces forward if its face points to positive local Z axis direction\r\n     */\r\n    private _ffSign;\r\n    //in mode 0, av2cam is used to align avatar with camera , with camera always facing avatar's back\r\n    //note:camera alpha is measured anti-clockwise , avatar rotation is measured clockwise \r\n    private _av2cam;\r\n    public setFaceForward(b: boolean) {\r\n        if (this._isRHS) {\r\n            this._av2cam = b ? Math.PI / 2 : 3 * Math.PI / 2;\r\n            this._ffSign = b ? 1 : -1;\r\n        } else {\r\n            this._av2cam = b ? 3 * Math.PI / 2 : Math.PI / 2;\r\n            this._ffSign = b ? -1 : 1;\r\n        }\r\n    }\r\n\r\n    private checkAGs(agMap: {}) {\r\n        let keys: string[] = Object.keys(this._actMap);\r\n        for (let key of keys) {\r\n            let anim = this._actMap[key];\r\n            if (!(anim instanceof _AnimData)) continue;\r\n            if (agMap[anim._name] != null) {\r\n                anim._ag = agMap[anim._name];\r\n                anim._exist = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _started: boolean = false;\r\n    public start() {\r\n        if (this._started) return;\r\n        this._started = true;\r\n        this._act.reset();\r\n        this._movFallTime = 0;\r\n        //first time we enter render loop, delta time is zero\r\n        this._idleFallTime = 0.001;\r\n        this._grounded = false;\r\n        this._updateTargetValue();\r\n        this.enableKeyBoard(true);\r\n        this._scene.registerBeforeRender(this._renderer);\r\n    }\r\n\r\n    public stop() {\r\n        if (!this._started) return;\r\n        this._started = false;\r\n        this._scene.unregisterBeforeRender(this._renderer);\r\n        this.enableKeyBoard(false);\r\n        this._prevAnim = null;\r\n    }\r\n\r\n    /**\r\n     * use pauseAnim to stop the charactere controller from playing\r\n     * any animation on the character\r\n     * use this when you want to play your animation instead\r\n     * see also resumeAnim()\r\n     */\r\n    private _stopAnim: boolean = false;\r\n    public pauseAnim() {\r\n        this._stopAnim = true;\r\n    }\r\n\r\n    /**\r\n     * use resumeAnim to resume the character controller playing\r\n     * animations on the character.\r\n     * see also pauseAnim()\r\n     */\r\n    public resumeAnim() {\r\n        this._stopAnim = false;\r\n    }\r\n\r\n    private _prevAnim: _AnimData = null;\r\n    private _avStartPos: Vector3 = Vector3.Zero();\r\n    private _grounded: boolean = false;\r\n    //distance by which AV would move down if in freefall\r\n    private _freeFallDist: number = 0;\r\n\r\n    //how many minimum contiguos frames should the AV have been in free fall\r\n    //before we assume AV is in big freefall.\r\n    //we will use this to remove animation flicker during move down a slope (fall, move, fall move etc)\r\n    //TODO: base this on slope - large slope large count\r\n    private _fallFrameCountMin: number = 50;\r\n    private _fallFrameCount: number = 0;\r\n\r\n    private _inFreeFall: boolean = false;\r\n    private _wasWalking: boolean = false;\r\n    private _wasRunning: boolean = false;\r\n    private _moveVector: Vector3;\r\n\r\n    //used only in mode 1\r\n    //value 1 or -1 , -1 if avatar is facing camera\r\n    //private _notFacingCamera = 1;\r\n\r\n    private _isAvFacingCamera(): number {\r\n        if (Vector3.Dot(this._avatar.forward, this._avatar.position.subtract(this._camera.position)) < 0) return 1\r\n        else return -1;\r\n    }\r\n\r\n    private _moveAVandCamera() {\r\n        this._avStartPos.copyFrom(this._avatar.position);\r\n        let anim: _AnimData = null;\r\n        const dt: number = this._scene.getEngine().getDeltaTime() / 1000;\r\n\r\n        if (this._act._jump && !this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            anim = this._doJump(dt);\r\n        } else if (this.anyMovement() || this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            anim = this._doMove(dt);\r\n        } else if (!this._inFreeFall) {\r\n            anim = this._doIdle(dt);\r\n        }\r\n        if (!this._stopAnim && this._hasAnims && anim != null) {\r\n            if (this._prevAnim !== anim) {\r\n                if (anim._exist) {\r\n                    if (this._isAG) {\r\n                        if (this._prevAnim != null && this._prevAnim._exist) this._prevAnim._ag.stop();\r\n                        //TODO use start instead of play ?\r\n                        //anim._ag.play(anim._loop);\r\n                        //anim._ag.speedRatio = anim._rate;\r\n                        anim._ag.start(anim._loop, anim._rate);\r\n                    } else {\r\n                        this._skeleton.beginAnimation(anim._name, anim._loop, anim._rate);\r\n                    }\r\n                }\r\n                this._prevAnim = anim;\r\n            }\r\n        }\r\n        this._updateTargetValue();\r\n        return;\r\n    }\r\n\r\n    //verical position of AV when it is about to start a jump\r\n    private _jumpStartPosY: number = 0;\r\n    //for how long the AV has been in the jump\r\n    private _jumpTime: number = 0;\r\n    private _doJump(dt: number): _AnimData {\r\n\r\n        let anim: _AnimData = null;\r\n        anim = this._actMap.runJump;\r\n        if (this._jumpTime === 0) {\r\n            this._jumpStartPosY = this._avatar.position.y;\r\n        }\r\n\r\n        this._jumpTime = this._jumpTime + dt;\r\n\r\n        let forwardDist: number = 0;\r\n        let jumpDist: number = 0;\r\n        let disp: Vector3;\r\n        if (this.mode != 1 && !this._noRot) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        if (this._wasRunning || this._wasWalking) {\r\n            if (this._wasRunning) {\r\n                forwardDist = this._actMap.run._speed * dt;\r\n            } else if (this._wasWalking) {\r\n                forwardDist = this._actMap.walk._speed * dt;\r\n            }\r\n            //find out in which horizontal direction the AV was moving when it started the jump\r\n            disp = this._moveVector.clone();\r\n            disp.y = 0;\r\n            disp = disp.normalize();\r\n            disp.scaleToRef(forwardDist, disp);\r\n            jumpDist = this._calcJumpDist(this._actMap.runJump._speed, dt);\r\n            disp.y = jumpDist;\r\n        } else {\r\n            jumpDist = this._calcJumpDist(this._actMap.idleJump._speed, dt);\r\n            disp = new Vector3(0, jumpDist, 0);\r\n            anim = this._actMap.idleJump;\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y/2;\r\n        }\r\n        //moveWithCollision only seems to happen if length of displacment is atleast 0.001\r\n        this._avatar.moveWithCollisions(disp);\r\n        if (jumpDist < 0) {\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y;\r\n            //check if going up a slope or back on flat ground \r\n            if ((this._avatar.position.y > this._avStartPos.y) || ((this._avatar.position.y === this._avStartPos.y) && (disp.length() > 0.001))) {\r\n                this._endJump();\r\n            } else if (this._avatar.position.y < this._jumpStartPosY) {\r\n                //the avatar is below the point from where it started the jump\r\n                //so it is either in free fall or is sliding along a downward slope\r\n                //\r\n                //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n                //else it is on a slope\r\n                const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                    //AV is on slope\r\n                    //Should AV continue to slide or stop?\r\n                    //if slope is less steeper than acceptable then stop else slide\r\n                    if (this._verticalSlope(actDisp) <= this._sl1) {\r\n                        this._endJump();\r\n                    }\r\n                } else {\r\n                    anim = this._actMap.fall;\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _calcJumpDist(speed: number, dt: number): number {\r\n        //up velocity at the begining of the lastt frame (v=u+at)\r\n        let js: number = speed - this._gravity * this._jumpTime;\r\n        //distance travelled up since last frame to this frame (s=ut+1/2*at^2)\r\n        let jumpDist: number = js * dt - 0.5 * this._gravity * dt * dt;\r\n        return jumpDist;\r\n    }\r\n\r\n    /**\r\n     * does cleanup at the end of a jump\r\n     */\r\n    private _endJump() {\r\n        this._act._jump = false;\r\n        this._jumpTime = 0;\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n    }\r\n\r\n    /**\r\n     * checks if two vectors v1 and v2 are equal within a precision of p\r\n     */\r\n    private _areVectorsEqual(v1: Vector3, v2: Vector3, p: number) {\r\n        return ((Math.abs(v1.x - v2.x) < p) && (Math.abs(v1.y - v2.y) < p) && (Math.abs(v1.z - v2.z) < p));\r\n    }\r\n\r\n    /*\r\n     * returns the slope (in radians) of a vector in the vertical plane\r\n     */\r\n    private _verticalSlope(v: Vector3): number {\r\n        return Math.atan(Math.abs(v.y / Math.sqrt(v.x * v.x + v.z * v.z)));\r\n    }\r\n\r\n    //for how long has the av been falling while moving\r\n    private _movFallTime: number = 0;\r\n    private _sign = 1;\r\n    private _isTurning = false;\r\n    private _noRot = false;\r\n    private _doMove(dt: number): _AnimData {\r\n\r\n        //initial down velocity\r\n        const u: number = this._movFallTime * this._gravity\r\n        //calculate the distance by which av should fall down since last frame\r\n        //assuming it is in freefall\r\n        this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n\r\n        this._movFallTime = this._movFallTime + dt;\r\n\r\n        let moving: boolean = false;\r\n        let anim: _AnimData = null;\r\n\r\n        if (this._inFreeFall) {\r\n            this._moveVector.y = -this._freeFallDist;\r\n            moving = true;\r\n        } else {\r\n            this._wasWalking = false;\r\n            this._wasRunning = false;\r\n\r\n            let sign: number;\r\n            let horizDist: number = 0;\r\n            switch (true) {\r\n                case (this._act._stepLeft):\r\n                    sign = this._signRHS * this._isAvFacingCamera();\r\n                    horizDist = this._actMap.strafeLeft._speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actMap.strafeLeftFast._speed * dt;\r\n                        anim = (-this._ffSign * sign > 0) ? this._actMap.strafeLeftFast : this._actMap.strafeRightFast;\r\n                    } else {\r\n                        anim = (-this._ffSign * sign > 0) ? this._actMap.strafeLeft : this._actMap.strafeRight;\r\n                    }\r\n\r\n                    this._moveVector = this._avatar.calcMovePOV(sign * horizDist, -this._freeFallDist, 0);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._stepRight):\r\n                    sign = -this._signRHS * this._isAvFacingCamera();\r\n                    horizDist = this._actMap.strafeRight._speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actMap.strafeRightFast._speed * dt;\r\n                        anim = (-this._ffSign * sign > 0) ? this._actMap.strafeLeftFast : this._actMap.strafeRightFast;\r\n                    } else {\r\n                        anim = (-this._ffSign * sign > 0) ? this._actMap.strafeLeft : this._actMap.strafeRight;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(sign * horizDist, -this._freeFallDist, 0);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._walk || (this._noRot && this.mode == 0)):\r\n                    if (this._act._speedMod) {\r\n                        this._wasRunning = true;\r\n                        horizDist = this._actMap.run._speed * dt;\r\n                        anim = this._actMap.run;\r\n                    } else {\r\n                        this._wasWalking = true;\r\n                        horizDist = this._actMap.walk._speed * dt;\r\n                        anim = this._actMap.walk;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, this._ffSign * horizDist);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._walkback):\r\n                    horizDist = this._actMap.walkBack._speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actMap.walkBackFast._speed * dt;\r\n                        anim = this._actMap.walkBackFast;\r\n                    } else {\r\n                        anim = this._actMap.walkBack;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, -this._ffSign * horizDist);\r\n                    moving = true;\r\n                    break;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if (!(this._noRot && this.mode == 0) && (!this._act._stepLeft && !this._act._stepRight) && (this._act._turnLeft || this._act._turnRight)) {\r\n            let turnAngle = this._actMap.turnLeft._speed * dt;\r\n            if (this._act._speedMod) {\r\n                turnAngle = 2 * turnAngle;\r\n            }\r\n            if (this.mode == 1) {\r\n                // while turining, the avatar could start facing away from camera and end up facing camera.\r\n                // we should not switch turning direction during this transition\r\n                if (!this._isTurning) {\r\n                    // if (this._act.name != this._act.prevName) {\r\n                    // this._act.prevName = this._act.name;\r\n                    this._sign = -this._ffSign * this._isAvFacingCamera();\r\n                    if (this._isRHS) this._sign = - this._sign;\r\n                    this._isTurning = true;\r\n                }\r\n                let a = this._sign;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._walk) { }\r\n                    else if (this._act._walkback) a = -this._sign;\r\n                    else {\r\n                        anim = (this._sign > 0) ? this._actMap.turnRight : this._actMap.turnLeft;\r\n                    }\r\n                } else {\r\n                    if (this._act._walk) a = -this._sign;\r\n                    else if (this._act._walkback) { }\r\n                    else {\r\n                        a = -this._sign;\r\n                        anim = (this._sign > 0) ? this._actMap.turnLeft : this._actMap.turnRight;\r\n                    }\r\n                }\r\n                this._avatar.rotation.y = this._avatar.rotation.y + turnAngle * a;\r\n            } else {\r\n                let a = 1;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._walkback) a = -1;\r\n                    if (!moving) anim = this._actMap.turnLeft;\r\n                } else {\r\n                    if (this._act._walk) a = -1;\r\n                    if (!moving) { a = -1; anim = this._actMap.turnRight; }\r\n                }\r\n                this._camera.alpha = this._camera.alpha + turnAngle * a;\r\n            }\r\n        }\r\n\r\n        if (this.mode != 1) {\r\n            if (this._noRot) {\r\n                switch (true) {\r\n                    case (this._act._walk && this._act._turnRight):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walk && this._act._turnLeft):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha - Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walkback && this._act._turnRight):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + 3 * Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walkback && this._act._turnLeft):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha - 3 * Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walk):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n                        break;\r\n                    case (this._act._walkback):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + Math.PI;\r\n                        break;\r\n                    case (this._act._turnRight):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + Math.PI / 2;\r\n                        break;\r\n                    case (this._act._turnLeft):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha - Math.PI / 2;\r\n                        break;\r\n                }\r\n            } else {\r\n                this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n            }\r\n        } else {\r\n\r\n        }\r\n\r\n        if (moving) {\r\n            if (this._moveVector.length() > 0.001) {\r\n                this._avatar.moveWithCollisions(this._moveVector);\r\n                //walking up a slope\r\n                if (this._avatar.position.y > this._avStartPos.y) {\r\n                    const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                    const _slp: number = this._verticalSlope(actDisp);\r\n                    if (_slp >= this._sl2) {\r\n                        //this._climbingSteps=true;\r\n                        //is av trying to go up steps\r\n                        if (this._stepOffset > 0) {\r\n                            if (this._vMoveTot == 0) {\r\n                                //if just started climbing note down the position\r\n                                this._vMovStartPos.copyFrom(this._avStartPos);\r\n                            }\r\n                            this._vMoveTot = this._vMoveTot + (this._avatar.position.y - this._avStartPos.y);\r\n                            if (this._vMoveTot > this._stepOffset) {\r\n                                //move av back to its position at begining of steps\r\n                                this._vMoveTot = 0;\r\n                                this._avatar.position.copyFrom(this._vMovStartPos);\r\n                                this._endFreeFall();\r\n                            }\r\n                        } else {\r\n                            //move av back to old position\r\n                            this._avatar.position.copyFrom(this._avStartPos);\r\n                            this._endFreeFall();\r\n                        }\r\n                    } else {\r\n                        this._vMoveTot = 0;\r\n                        if (_slp > this._sl1) {\r\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                            this._fallFrameCount = 0;\r\n                            this._inFreeFall = false;\r\n                        } else {\r\n                            //continue walking\r\n                            this._endFreeFall();\r\n                        }\r\n                    }\r\n                } else if ((this._avatar.position.y) < this._avStartPos.y) {\r\n                    const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                    if (!(this._areVectorsEqual(actDisp, this._moveVector, 0.001))) {\r\n                        //AV is on slope\r\n                        //Should AV continue to slide or walk?\r\n                        //if slope is less steeper than acceptable then walk else slide\r\n                        if (this._verticalSlope(actDisp) <= this._sl1) {\r\n                            this._endFreeFall();\r\n                        } else {\r\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                            this._fallFrameCount = 0;\r\n                            this._inFreeFall = false;\r\n                        }\r\n                    } else {\r\n                        this._inFreeFall = true;\r\n                        this._fallFrameCount++;\r\n                        //AV could be running down a slope which mean freefall,run,frefall run ...\r\n                        //to remove anim flicker, check if AV has been falling down continously for last few consecutive frames\r\n                        //before changing to free fall animation\r\n                        if (this._fallFrameCount > this._fallFrameCountMin) {\r\n                            anim = this._actMap.fall;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this._endFreeFall();\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _endFreeFall(): void {\r\n        this._movFallTime = 0;\r\n        this._fallFrameCount = 0;\r\n        this._inFreeFall = false;\r\n    }\r\n\r\n    //for how long has the av been falling while idle (not moving)\r\n    private _idleFallTime: number = 0;\r\n    private _doIdle(dt: number): _AnimData {\r\n        if (this._grounded) {\r\n            return this._actMap.idle;\r\n        }\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n        this._movFallTime = 0;\r\n        let anim: _AnimData = this._actMap.idle;\r\n        this._fallFrameCount = 0;\r\n\r\n\r\n        if (dt === 0) {\r\n            this._freeFallDist = 5;\r\n        } else {\r\n            const u: number = this._idleFallTime * this._gravity\r\n            this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n            this._idleFallTime = this._idleFallTime + dt;\r\n        }\r\n        //if displacement is less than 0.01(? need to verify further) then \r\n        //moveWithDisplacement down against a surface seems to push the AV up by a small amount!!\r\n        if (this._freeFallDist < 0.01) return anim;\r\n        const disp: Vector3 = new Vector3(0, -this._freeFallDist, 0);\r\n        if (this.mode != 1 && !this._noRot) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        this._avatar.moveWithCollisions(disp);\r\n        if ((this._avatar.position.y > this._avStartPos.y) || (this._avatar.position.y === this._avStartPos.y)) {\r\n            //                this.grounded = true;\r\n            //                this.idleFallTime = 0;\r\n            this._groundIt();\r\n        } else if (this._avatar.position.y < this._avStartPos.y) {\r\n            //AV is going down. \r\n            //AV is either in free fall or is sliding along a downward slope\r\n            //\r\n            //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n            //else it is on a slope\r\n            const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n            if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                //AV is on slope\r\n                //Should AV continue to slide or stop?\r\n                //if slope is less steeper than accebtable then stop else slide\r\n                if (this._verticalSlope(actDisp) <= this._sl1) {\r\n                    //                        this.grounded = true;\r\n                    //                        this.idleFallTime = 0;\r\n                    this._groundIt();\r\n                    this._avatar.position.copyFrom(this._avStartPos);\r\n                } else {\r\n                    this._unGroundIt();\r\n                    anim = this._actMap.slideBack;\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _groundFrameCount = 0;\r\n    private _groundFrameMax = 10;\r\n    /**\r\n     * donot ground immediately\r\n     * wait few more frames\r\n     */\r\n    private _groundIt(): void {\r\n        this._groundFrameCount++;\r\n        if (this._groundFrameCount > this._groundFrameMax) {\r\n            this._grounded = true;\r\n            this._idleFallTime = 0;\r\n        }\r\n    }\r\n    private _unGroundIt() {\r\n        this._grounded = false;\r\n        this._groundFrameCount = 0;\r\n    }\r\n\r\n    private _savedCameraCollision: boolean = true;\r\n    private _inFP = false;\r\n    private _updateTargetValue() {\r\n        //donot move camera if av is trying to clinb steps\r\n        if (this._vMoveTot == 0)\r\n            this._avatar.position.addToRef(this._cameraTarget, this._camera.target);\r\n\r\n        if (this._camera.radius > this._camera.lowerRadiusLimit) { if (this._elasticCamera) this._snapCamera(); }\r\n\r\n        if (this._camera.radius <= this._camera.lowerRadiusLimit) {\r\n            if (!this._noFirstPerson && !this._inFP) {\r\n                this._avatar.visibility = 0;\r\n                this._camera.checkCollisions = false;\r\n                this._saveMode = this.mode;\r\n                this.mode = 0;\r\n                this._inFP = true;\r\n            }\r\n        } else {\r\n            this._inFP = false;\r\n            this.mode = this._saveMode;\r\n            this._avatar.visibility = 1;\r\n            this._camera.checkCollisions = this._savedCameraCollision;\r\n        }\r\n    }\r\n\r\n    private _ray: Ray = new Ray(Vector3.Zero(), Vector3.One(), 1);\r\n    private _rayDir: Vector3 = Vector3.Zero();\r\n    //camera seems to get stuck into things\r\n    //should move camera away from things by a value of cameraSkin\r\n    private _cameraSkin: number = 0.5;\r\n    private _skip: number = 0;\r\n    private _snapCamera() {\r\n        //            if(this.skip<120) {\r\n        //                this.skip++;\r\n        //                return;\r\n        //            }\r\n        //            this.skip=0;\r\n        //get vector from av (camera.target) to camera\r\n        this._camera.position.subtractToRef(this._camera.target, this._rayDir);\r\n        //start ray from av to camera\r\n        this._ray.origin = this._camera.target;\r\n        this._ray.length = this._rayDir.length();\r\n        this._ray.direction = this._rayDir.normalize();\r\n\r\n        const pi: PickingInfo = this._scene.pickWithRay(this._ray, (mesh) => {\r\n            //if(mesh==this.avatar||!mesh.isPickable||!mesh.checkCollisions) return false;\r\n            if (mesh == this._avatar || !mesh.checkCollisions) return false;\r\n            else return true;\r\n        }, true);\r\n\r\n        if (pi.hit) {\r\n            //postion the camera in front of the mesh that is obstructing camera\r\n            if (this._camera.checkCollisions) {\r\n                const newPos: Vector3 = this._camera.target.subtract(pi.pickedPoint).normalize().scale(this._cameraSkin);\r\n                pi.pickedPoint.addToRef(newPos, this._camera.position);\r\n            } else {\r\n                const nr: number = pi.pickedPoint.subtract(this._camera.target).length();\r\n                this._camera.radius = nr - this._cameraSkin;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _move: boolean = false;\r\n    public anyMovement(): boolean {\r\n        return (this._act._walk || this._act._walkback || this._act._turnLeft || this._act._turnRight || this._act._stepLeft || this._act._stepRight);\r\n    }\r\n\r\n    private _onKeyDown(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        if (e.repeat) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case this._jumpKey:\r\n                this._act._jump = true;\r\n                break;\r\n            case \"capslock\":\r\n                this._act._speedMod = !this._act._speedMod;\r\n                break;\r\n            case \"shift\":\r\n                this._act._speedMod = true;\r\n                break;\r\n            case \"up\":\r\n            case \"arrowup\":\r\n            case this._walkKey:\r\n                this._act._walk = true;\r\n                break;\r\n            case \"left\":\r\n            case \"arrowleft\":\r\n            case this._turnLeftKey:\r\n                this._act._turnLeft = true;\r\n                break;\r\n            case \"right\":\r\n            case \"arrowright\":\r\n            case this._turnRightKey:\r\n                this._act._turnRight = true;\r\n                break;\r\n            case \"down\":\r\n            case \"arrowdown\":\r\n            case this._walkBackKey:\r\n                this._act._walkback = true;\r\n                break;\r\n            case this._strafeLeftKey:\r\n                this._act._stepLeft = true;\r\n                break;\r\n            case this._strafeRightKey:\r\n                this._act._stepRight = true;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    private _onKeyUp(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case \"shift\":\r\n                this._act._speedMod = false;\r\n                break;\r\n            case \"up\":\r\n            case \"arrowup\":\r\n            case this._walkKey:\r\n                this._act._walk = false;\r\n                break;\r\n            case \"left\":\r\n            case \"arrowleft\":\r\n            case this._turnLeftKey:\r\n                this._act._turnLeft = false;\r\n                this._isTurning = false;\r\n                break;\r\n            case \"right\":\r\n            case \"arrowright\":\r\n            case this._turnRightKey:\r\n                this._act._turnRight = false;\r\n                this._isTurning = false;\r\n                break;\r\n            case \"down\":\r\n            case \"arrowdown\":\r\n            case this._walkBackKey:\r\n                this._act._walkback = false;\r\n                break;\r\n            case this._strafeLeftKey:\r\n                this._act._stepLeft = false;\r\n                break;\r\n            case this._strafeRightKey:\r\n                this._act._stepRight = false;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n\r\n    public enableKeyBoard(b: boolean) {\r\n        let canvas: HTMLCanvasElement = this._scene.getEngine().getRenderingCanvas();\r\n        if (b) {\r\n            canvas.addEventListener(\"keyup\", this._handleKeyUp, false);\r\n            canvas.addEventListener(\"keydown\", this._handleKeyDown, false);\r\n        } else {\r\n            canvas.removeEventListener(\"keyup\", this._handleKeyUp, false);\r\n            canvas.removeEventListener(\"keydown\", this._handleKeyDown, false);\r\n        }\r\n    }\r\n\r\n    // control movement by commands rather than keyboard.\r\n    public walk(b: boolean) {\r\n        this._act._walk = b;\r\n    }\r\n    public walkBack(b: boolean) {\r\n        this._act._walkback = b;\r\n    }\r\n    public walkBackFast(b: boolean) {\r\n        this._act._walkback = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public run(b: boolean) {\r\n        this._act._walk = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public turnLeft(b: boolean) {\r\n        this._act._turnLeft = b;\r\n        if (!b) this._isTurning = b;\r\n    }\r\n    public turnLeftFast(b: boolean) {\r\n        this._act._turnLeft = b;\r\n        if (!b) this._isTurning = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public turnRight(b: boolean) {\r\n        this._act._turnRight = b;\r\n        if (!b) this._isTurning = b;\r\n    }\r\n    public turnRightFast(b: boolean) {\r\n        this._act._turnRight = b;\r\n        if (!b) this._isTurning = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public strafeLeft(b: boolean) {\r\n        this._act._stepLeft = b;\r\n    }\r\n    public strafeLeftFast(b: boolean) {\r\n        this._act._stepLeft = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public strafeRight(b: boolean) {\r\n        this._act._stepRight = b;\r\n    }\r\n    public strafeRightFast(b: boolean) {\r\n        this._act._stepRight = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public jump() {\r\n        this._act._jump = true;\r\n    }\r\n    public idle() {\r\n        this._act.reset();\r\n    }\r\n\r\n    private _act: _Action;\r\n    private _renderer: () => void;\r\n    private _handleKeyUp: (e) => void;\r\n    private _handleKeyDown: (e) => void;\r\n    private _isAG: boolean = false;\r\n    private _hasAnims: boolean = false;\r\n    /**\r\n     * \r\n     * @param avatar \r\n     * @param camera \r\n     * @param scene \r\n     * @param agMap map of animationRange name to animationRange\r\n     * @param faceForward \r\n     */\r\n    constructor(avatar: Mesh, camera: ArcRotateCamera, scene: Scene, agMap?: {}, faceForward = false) {\r\n\r\n        this._avatar = avatar;\r\n\r\n        this._setRHS(avatar);\r\n        this.setFaceForward(faceForward);\r\n\r\n        this._scene = scene;\r\n\r\n        if (agMap != null) {\r\n            this._isAG = true;\r\n            this.setAnimationGroups(agMap);\r\n        }\r\n\r\n        if (this._isAG || this._skeleton !== null) {\r\n            this._hasAnims = true;\r\n        }\r\n\r\n        if (!this._isAG) this._skeleton = avatar.skeleton;\r\n\r\n        if (!this._isAG && this._skeleton != null) this.checkAnims(this._skeleton);\r\n        this._camera = camera;\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n\r\n        this._act = new _Action();\r\n\r\n        this._renderer = () => { this._moveAVandCamera() };\r\n        this._handleKeyUp = (e) => { this._onKeyUp(e) };\r\n        this._handleKeyDown = (e) => { this._onKeyDown(e) };\r\n    }\r\n}\r\n\r\nclass _AnimData {\r\n    public _id: string;\r\n    public _speed: number;\r\n    public _sound: string;\r\n\r\n    //_name will be used to play animationrange\r\n    public _name: string;\r\n    public _ag: AnimationGroup;\r\n\r\n    public _loop: boolean = true;\r\n    public _rate: number = 1;\r\n\r\n    public _exist: boolean = false;\r\n\r\n    public constructor(id: string, speed = 1) {\r\n        this._id = id;\r\n        this._name = id;\r\n        this._speed = speed;\r\n    }\r\n}\r\n\r\nclass _Action {\r\n    public _walk: boolean = false;\r\n    public _walkback: boolean = false;\r\n    // speed modifier - changes speed of movement\r\n    public _speedMod: boolean = false;\r\n    public _turnRight: boolean = false;\r\n    public _turnLeft: boolean = false;\r\n    public _stepRight: boolean = false;\r\n    public _stepLeft: boolean = false;\r\n    public _jump: boolean = false;\r\n\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    reset() {\r\n        this._walk = false;\r\n        this._walkback = false;\r\n        this._turnRight = false;\r\n        this._turnLeft = false;\r\n        this._stepRight = false;\r\n        this._stepLeft = false;\r\n        this._jump = false;\r\n        this._speedMod = false;\r\n    }\r\n}\r\n\r\nclass _ActMap {\r\n    private _walkSpeed = 3;\r\n    public walk = new _AnimData(\"walk\", 3);\r\n    public walkBack = new _AnimData(\"walkBack\", this._walkSpeed / 2);\r\n    public walkBackFast = new _AnimData(\"walkBackFast\", this._walkSpeed);\r\n    public idle = new _AnimData(\"idle\", 0);\r\n    public idleJump = new _AnimData(\"idleJump\", this._walkSpeed * 2);\r\n    public run = new _AnimData(\"run\", this._walkSpeed * 2);\r\n    public runJump = new _AnimData(\"runJump\", this._walkSpeed * 2);\r\n    public fall = new _AnimData(\"fall\", 0);\r\n    public turnLeft = new _AnimData(\"turnLeft\", Math.PI / 8);\r\n    public turnLeftFast = new _AnimData(\"turnLeftFast\", Math.PI / 4);\r\n    public turnRight = new _AnimData(\"turnRight\", Math.PI / 8);\r\n    public turnRightFast = new _AnimData(\"turnRightFast\", Math.PI / 4);\r\n    public strafeLeft = new _AnimData(\"strafeLeft\", this._walkSpeed / 2);\r\n    public strafeLeftFast = new _AnimData(\"strafeLeftFast\", this._walkSpeed);\r\n    public strafeRight = new _AnimData(\"strafeRight\", this._walkSpeed / 2);\r\n    public strafeRightFast = new _AnimData(\"strafeRightFast\", this._walkSpeed);\r\n    public slideBack = new _AnimData(\"slideBack\", 0)\r\n};\r\n"],"sourceRoot":""}