{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///external {\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\",\"root\":\"BABYLON\"}","webpack:///./src/CharacterController.ts"],"names":["root","factory","exports","module","require","define","amd","a","i","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","avatar","camera","scene","actionMap","faceForward","_avatar","_skeleton","_gravity","_minSlopeLimit","_maxSlopeLimit","_sl1","Math","PI","this","_sl2","_stepOffset","_vMoveTot","_vMovStartPos","Zero","_actionMap","ActionMap","_cameraElastic","_cameraTarget","_noFirstPerson","_mode","_saveMode","_isLHS_RHS","_signLHS_RHS","_started","_stopAnim","_prevActData","_avStartPos","_grounded","_freeFallDist","_fallFrameCountMin","_fallFrameCount","_inFreeFall","_wasWalking","_wasRunning","_soundLoopTime","_sndId","_ae","console","log","_currentActData","sound","play","_jumpStartPosY","_jumpTime","_movFallTime","_sign","_isTurning","_noRot","_idleFallTime","_groundFrameCount","_groundFrameMax","_savedCameraCollision","_inFP","_ray","One","_rayDir","_cameraSkin","_pickedMeshes","Array","_makeInvisible","_elasticSteps","_move","_isAG","_hasAnims","_camera","_scene","setAvatar","error","setActionMap","_checkAnimRanges","checkCollisions","_act","_Action","_renderer","_moveAVandCamera","_handleKeyUp","e","_onKeyUp","_handleKeyDown","_onKeyDown","getScene","setSlopeLimit","minSlopeLimit","maxSlopeLimit","setStepOffset","stepOffset","setWalkSpeed","walk","speed","setRunSpeed","run","setBackSpeed","walkBack","setBackFastSpeed","walkBackFast","setJumpSpeed","idleJump","runJump","setLeftSpeed","strafeLeft","setLeftFastSpeed","strafeLeftFast","setRightSpeed","strafeRight","setRightFastSpeed","setTurnSpeed","turnLeft","turnRight","setTurnFastSpeed","turnLeftFast","turnRightFast","setGravity","setAnimationGroups","agMap","exist","ag","stop","setAnimationRanges","arMap","inActMap","inActData","keys","ccActionName","ccActData","ActionData","id","loop","rate","_checkFastAnims","getActionMap","map","actDataI","actDataO","getSettings","ccs","CCSettings","isFaceForward","topDown","getMode","turningOff","isTurningOff","cameraTarget","clone","cameraElastic","elasticSteps","makeInvisble","gravity","keyboard","_ekb","noFirstPerson","_stepSound","setSettings","setFaceForward","setMode","setTurningOff","setCameraTarget","setCameraElasticity","setElasticiSteps","makeObstructionInvisible","enableKeyBoard","setNoFirstPerson","setSound","_setAnim","anim","animName","getAnimationRange","enableBlending","act","targetedAnimations","ta","animation","blendingSpeed","disableBlending","setWalkAnim","rangeName","setRunAnim","setWalkBackAnim","_copySlowAnims","setWalkBackFastAnim","setSlideBackAnim","slideBack","setIdleAnim","idle","setTurnRightAnim","setTurnRightFastAnim","setTurnLeftAnim","setTurnLeftFastAnim","setStrafeRightAnim","strafeRightFast","setStrafeRightFastAnim","setStrafeLeftAnim","setStrafeLeftFastAnim","setIdleJumpAnim","setRunJumpAnim","setFallAnim","fall","ccActionNames","attachToMesh","setWalkKey","toLowerCase","setWalkBackKey","setTurnLeftKey","setTurnRightKey","setStrafeLeftKey","setStrafeRightKey","setJumpKey","b","v","copyFrom","cameraCollisionChanged","skel","f","_setRHS","mesh","meshMatrix","getWorldMatrix","_localX","FromArray","_localY","_localZ","actualZ","Cross","Dot","_ff","_rhsSign","useRightHandedSystem","_av2cam","_ffSign","checkAGs","_containsAG","node","ags","fromRoot","_getRoot","getChildren","indexOf","target","tn","parent","start","reset","_updateTargetValue","registerBeforeRender","unregisterBeforeRender","pauseAnim","resumeAnim","_isAvFacingCamera","forward","position","subtract","actData","dt","getEngine","getDeltaTime","_jump","_doJump","anyMovement","_doMove","_doIdle","fps","framePerSecond","to","from","beginAnimation","getAnimations","clearInterval","setInterval","y","disp","forwardDist","jumpDist","rotation","alpha","_moveVector","normalize","scaleToRef","_calcJumpDist","moveWithCollisions","length","_endJump","actDisp","_areVectorsEqual","_verticalSlope","v1","v2","abs","x","z","atan","sqrt","u","moving","actdata","_rotateC2AV","_rotateAV2C","sign","horizDist","_speedMod","calcMovePOV","_walk","_slp","_endFreeFall","_turnRight","_turnLeft","_walkback","_stepLeft","_stepRight","turnAngle","_groundIt","_unGroundIt","addToRef","radius","lowerRadiusLimit","_handleObstruction","visibility","subtractToRef","origin","direction","pis","multiPickWithRay","_prevPickedMeshes","pi","pickedMesh","isVisible","includes","push","pm","_isSeeAble","pp","pickedPoint","c2p","step","addInPlace","normalizeToNew","scaleInPlace","material","alphaMode","repeat","canvas","getRenderingCanvas","addEventListener","removeEventListener","jump","isAg","_findSkel","_root","skeleton","ms","getChildMeshes","cm","rootNode","animationGroups","getAvatar","setAvatarSkeleton","_skelDrivenByAG","animations","some","sa","children","getSkeleton","ds","dk"],"mappings":"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","file":"CharacterController.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"babylonjs\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"babylonjs\")) : factory(root[\"BABYLON\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import {\r\n    Skeleton,\r\n    ArcRotateCamera,\r\n    Vector3,\r\n    Mesh,\r\n    Node,\r\n    Scene,\r\n    Ray,\r\n    PickingInfo,\r\n    AnimationGroup,\r\n    TransformNode,\r\n    TargetedAnimation,\r\n    Matrix,\r\n    DeepImmutable,\r\n    AbstractMesh,\r\n    PlaySoundAction,\r\n    InstancedMesh,\r\n    Sound,\r\n    AnimationRange,\r\n    Animatable,\r\n    AnimationEvent\r\n} from \"babylonjs\";\r\nimport { SubSurfaceConfiguration } from \"babylonjs/Rendering/subSurfaceConfiguration\";\r\n\r\nexport class CharacterController {\r\n\r\n    private _avatar: Mesh = null;;\r\n    private _skeleton: Skeleton = null;\r\n    private _camera: ArcRotateCamera;\r\n    private _scene: Scene;\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n\r\n    private _gravity: number = 9.8;\r\n    //slopeLimit in degrees\r\n    private _minSlopeLimit: number = 30;\r\n    private _maxSlopeLimit: number = 45;\r\n    //slopeLimit in radians\r\n    private _sl1: number = Math.PI * this._minSlopeLimit / 180;\r\n    private _sl2: number = Math.PI * this._maxSlopeLimit / 180;\r\n\r\n    //The av will step up a stair only if it is closer to the ground than the indicated value.\r\n    private _stepOffset: number = 0.25;\r\n    //toal amount by which the av has moved up\r\n    private _vMoveTot: number = 0;\r\n    //position of av when it started moving up\r\n    private _vMovStartPos: Vector3 = Vector3.Zero();\r\n\r\n\r\n    private _actionMap: ActionMap = new ActionMap();\r\n\r\n    private _cameraElastic: boolean = true;\r\n    private _cameraTarget: Vector3 = Vector3.Zero();\r\n    //should we go into first person view when camera is near avatar (radius is lowerradius limit)\r\n    private _noFirstPerson: boolean = false;\r\n\r\n\r\n\r\n    public setSlopeLimit(minSlopeLimit: number, maxSlopeLimit: number) {\r\n        this._minSlopeLimit = minSlopeLimit;\r\n        this._maxSlopeLimit = maxSlopeLimit;\r\n\r\n        this._sl1 = Math.PI * this._minSlopeLimit / 180;\r\n        this._sl2 = Math.PI * this._maxSlopeLimit / 180;\r\n    }\r\n\r\n    /**\r\n     * The av will step up a stair only if it is closer to the ground than the indicated value.\r\n     * Default value is 0.25 m\r\n     */\r\n    public setStepOffset(stepOffset: number) {\r\n        this._stepOffset = stepOffset;\r\n    }\r\n\r\n    public setWalkSpeed(n: number) {\r\n        this._actionMap.walk.speed = n;\r\n    }\r\n    public setRunSpeed(n: number) {\r\n        this._actionMap.run.speed = n;\r\n    }\r\n    public setBackSpeed(n: number) {\r\n        this._actionMap.walkBack.speed = n;\r\n    }\r\n    public setBackFastSpeed(n: number) {\r\n        this._actionMap.walkBackFast.speed = n;\r\n    }\r\n    public setJumpSpeed(n: number) {\r\n        this._actionMap.idleJump.speed = n;\r\n        this._actionMap.runJump.speed = n;\r\n    }\r\n    public setLeftSpeed(n: number) {\r\n        this._actionMap.strafeLeft.speed = n;\r\n    }\r\n    public setLeftFastSpeed(n: number) {\r\n        this._actionMap.strafeLeftFast.speed = n;\r\n    }\r\n    public setRightSpeed(n: number) {\r\n        this._actionMap.strafeRight.speed = n;\r\n    }\r\n    public setRightFastSpeed(n: number) {\r\n        this._actionMap.strafeLeftFast.speed = n;\r\n    }\r\n    // get turnSpeed in degrees per second.\r\n    // store in radians per second\r\n    public setTurnSpeed(n: number) {\r\n        this._actionMap.turnLeft.speed = n * Math.PI / 180;\r\n        this._actionMap.turnRight.speed = n * Math.PI / 180;\r\n    }\r\n    public setTurnFastSpeed(n: number) {\r\n        this._actionMap.turnLeftFast.speed = n * Math.PI / 180;\r\n        this._actionMap.turnRightFast.speed = n * Math.PI / 180;\r\n    }\r\n    public setGravity(n: number) {\r\n        this._gravity = n;\r\n    }\r\n\r\n    /**\r\n     * Use this to provide animationGroups to the character controller.\r\n     * Provide the AnimationGroups using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animationGroup.\r\n     * Example:\r\n     * let myWalkAnimationGroup:AnimationGroup = ...;\r\n     * let agMap:{} = {\r\n     *  \"walk\":myWalkAnimationGroup,\r\n     *  \"run\" : {\"ag\":myRunAnimationGroup,\"rate\":1},\r\n     *  \"idle\" : {\"ag\":myIdleAnimationGroup,\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     *   ....\r\n     * }\r\n     * \r\n     * @param agMap a map of character controller animation name to animationGroup\r\n     */\r\n    public setAnimationGroups(agMap: {}) {\r\n        if (this._prevActData != null && this._prevActData.exist) this._prevActData.ag.stop();\r\n        this._isAG = true;\r\n        this.setActionMap(<ActionMap>agMap);\r\n    }\r\n\r\n    /**\r\n     * Use this to provide AnimationRanges to the character controller.\r\n     * Provide the AnimationRanges using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animation range name or an object with animation range data.\r\n     * example:\r\n     * let arMap = {\r\n     *  \"walk\":\"myWalk\",\r\n     *  \"run\" : {\"name\":\"myRun\",\"rate\":1},\r\n     *  \"idle\" : {\"name\":\"myIdle\",\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     * }\r\n     * \r\n     * @param arMap a map of character controller animation name to animationRange data\r\n     */\r\n\r\n    public setAnimationRanges(arMap: {}) {\r\n        this._isAG = false;\r\n        this.setActionMap(<ActionMap>arMap);\r\n    }\r\n\r\n    /**\r\n     * updates action data in the cc actionMap\r\n     * with action data from the provided/input actionMap \r\n     * \r\n     * \r\n     * return \"ar\" or \"ag\" depending on if the data provided\r\n     * was animation range or animation group data respt.\r\n     * \r\n     * TODO should validate provided data.\r\n     * In other words if animation range provided make sure\r\n     * the range exist in the skeleton\r\n     * or if animation group provided make sure the animation group\r\n     * can be played on this avataor\r\n     * \r\n     * @param inActMap \r\n     * @returns \r\n     */\r\n    public setActionMap(inActMap: ActionMap): string {\r\n        let agMap: boolean = false;\r\n        let inActData: ActionData;\r\n\r\n\r\n        let ccActionNames: string[] = Object.keys(this._actionMap);\r\n        for (let ccActionName of ccActionNames) {\r\n            let ccActData = this._actionMap[ccActionName];\r\n            //some keys could map to functions (like reset())\r\n            if (!(ccActData instanceof ActionData)) continue;\r\n            ccActData.exist = false;\r\n\r\n            inActData = inActMap[ccActData.id];\r\n            //in previous version of cc the key value was AnimationGroup rather than ActionData\r\n            //lets accomodate that for backward compatibility\r\n            if (inActData != null) {\r\n                if (inActData instanceof AnimationGroup) {\r\n                    ccActData.ag = inActData;\r\n                    ccActData.name = ccActData.ag.name;\r\n                    ccActData.exist = true;\r\n                    agMap = true;\r\n                    this._hasAnims = true;\r\n                } else if (inActData.exist) {\r\n                    this._hasAnims = true;\r\n                    ccActData.exist = true;\r\n                    if (inActData instanceof Object) {\r\n                        if (inActData.ag) {\r\n                            ccActData.ag = inActData.ag;\r\n                            agMap = true;\r\n                        }\r\n                        if (inActData.name) {\r\n                            ccActData.name = inActData.name;\r\n                        }\r\n                        if (inActData.loop != null) ccActData.loop = inActData.loop;\r\n                        if (inActData.rate) ccActData.rate = inActData.rate;\r\n                        if (inActData.speed) ccActData.speed = inActData.speed;\r\n                        // if (actDataI.key) actDataO.key = actDataI.key;\r\n                        if (inActData.sound) ccActData.sound = inActData.sound;\r\n                    } else {\r\n                        ccActData.name = inActData;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._checkFastAnims();\r\n        //force to play new anims\r\n        this._prevActData = null;\r\n        if (agMap) return \"ag\"; else return \"ar\";\r\n    }\r\n\r\n    public getActionMap(): ActionMap {\r\n        let map: ActionMap = new ActionMap();\r\n\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let actDataI = this._actionMap[key];\r\n\r\n            if (!(actDataI instanceof ActionData)) continue;\r\n            if (!actDataI.exist) continue;\r\n\r\n            let actDataO: ActionData = map[actDataI.id];\r\n            actDataO.ag = actDataI.ag;\r\n            actDataO.name = actDataI.name;\r\n            actDataO.loop = actDataI.loop;\r\n            actDataO.rate = actDataI.rate;\r\n            actDataO.speed = actDataI.speed;\r\n            actDataO.key = actDataI.key;\r\n            actDataO.sound = actDataI.sound;\r\n            actDataO.exist = actDataI.exist;\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    public getSettings(): CCSettings {\r\n        let ccs: CCSettings = new CCSettings();\r\n        ccs.faceForward = this.isFaceForward();\r\n        ccs.topDown = this.getMode() == 1 ? true : false;\r\n        ccs.turningOff = this.isTurningOff();\r\n        ccs.cameraTarget = this._cameraTarget.clone();\r\n        ccs.cameraElastic = this._cameraElastic;\r\n        ccs.elasticSteps = this._elasticSteps;\r\n        ccs.makeInvisble = this._makeInvisible;\r\n        ccs.gravity = this._gravity;\r\n        ccs.keyboard = this._ekb;\r\n        ccs.maxSlopeLimit = this._maxSlopeLimit;\r\n        ccs.minSlopeLimit = this._minSlopeLimit;\r\n        ccs.noFirstPerson = this._noFirstPerson;\r\n        ccs.stepOffset = this._stepOffset;\r\n        ccs.sound = this._stepSound;\r\n\r\n        return ccs;\r\n    }\r\n\r\n    public setSettings(ccs: CCSettings) {\r\n        this.setFaceForward(ccs.faceForward);\r\n        this.setMode(ccs.topDown ? 1 : 0);\r\n        this.setTurningOff(ccs.turningOff);\r\n        this.setCameraTarget(ccs.cameraTarget);\r\n        this.setCameraElasticity(ccs.cameraElastic);\r\n        this.setElasticiSteps(ccs.elasticSteps);\r\n        this.makeObstructionInvisible(ccs.makeInvisble);\r\n        this.setGravity(ccs.gravity);\r\n        this.enableKeyBoard(ccs.keyboard);\r\n        this.setSlopeLimit(ccs.minSlopeLimit, ccs.maxSlopeLimit);\r\n        this.setNoFirstPerson(ccs.noFirstPerson);\r\n        this.setStepOffset(ccs.stepOffset);\r\n        this.setSound(ccs.sound);\r\n\r\n    }\r\n\r\n    private _setAnim(anim: ActionData, animName?: string | AnimationGroup, rate?: number, loop?: boolean) {\r\n\r\n        //animation range need skeleton\r\n        if (!this._isAG && this._skeleton == null) return;\r\n\r\n        if (animName != null) {\r\n            if (this._isAG) {\r\n                if (!(animName instanceof AnimationGroup)) return;\r\n                anim.ag = <AnimationGroup>animName;\r\n                anim.exist = true;\r\n            } else {\r\n                if (this._skeleton.getAnimationRange(anim.name) != null) {\r\n                    anim.name = <string>animName;\r\n                    anim.exist = true;\r\n                } else {\r\n                    anim.exist = false;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (loop != null) anim.loop = loop;\r\n        if (rate != null) anim.rate = rate;\r\n    }\r\n\r\n    public enableBlending(n: number) {\r\n        if (this._isAG) {\r\n            let keys: string[] = Object.keys(this._actionMap);\r\n            for (let key of keys) {\r\n                let act = this._actionMap[key];\r\n                if (!(act instanceof ActionData)) continue;\r\n                if (act.exist) {\r\n                    let ar: AnimationGroup = act.ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = true;\r\n                        ta.animation.blendingSpeed = n;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (this._skeleton !== null)\r\n                this._skeleton.enableBlending(n);\r\n        }\r\n    }\r\n\r\n    public disableBlending() {\r\n        if (this._isAG) {\r\n            let keys: string[] = Object.keys(this._actionMap);\r\n            for (let key of keys) {\r\n                let anim = this._actionMap[key];\r\n                if (!(anim instanceof ActionData)) continue;\r\n                if (anim.exist) {\r\n                    let ar: AnimationGroup = anim.ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //setters for animations\r\n    public setWalkAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walk, rangeName, rate, loop);\r\n    }\r\n    public setRunAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.run, rangeName, rate, loop);\r\n    }\r\n    public setWalkBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walkBack, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.walkBackFast, this._actionMap.walkBack);\r\n    }\r\n    public setWalkBackFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walkBackFast, rangeName, rate, loop);\r\n    }\r\n    public setSlideBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.slideBack, rangeName, rate, loop);\r\n    }\r\n    public setIdleAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.idle, rangeName, rate, loop);\r\n    }\r\n    public setTurnRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnRight, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.turnRightFast, this._actionMap.turnRight);\r\n    }\r\n    public setTurnRightFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnRightFast, rangeName, rate, loop);\r\n    }\r\n    public setTurnLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnLeft, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.turnLeftFast, this._actionMap.turnLeft);\r\n    }\r\n    public setTurnLeftFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnLeftFast, rangeName, rate, loop);\r\n    }\r\n    public setStrafeRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeRight, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.strafeRightFast, this._actionMap.strafeRight);\r\n    }\r\n    public setStrafeRightFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeRightFast, rangeName, rate, loop);\r\n    }\r\n    public setStrafeLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeLeft, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.strafeLeftFast, this._actionMap.strafeLeft);\r\n    }\r\n    public setStrafeLeftFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeLeftFast, rangeName, rate, loop);\r\n    }\r\n    public setIdleJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.idleJump, rangeName, rate, loop);\r\n    }\r\n    public setRunJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.runJump, rangeName, rate, loop);\r\n    }\r\n    public setFallAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.fall, rangeName, rate, loop);\r\n    }\r\n\r\n\r\n    _stepSound: Sound;\r\n    // setters for sound\r\n    public setSound(sound: Sound) {\r\n        if (sound == null) return;\r\n        this._stepSound = sound;\r\n        let ccActionNames: string[] = Object.keys(this._actionMap);\r\n        sound.loop = false;\r\n        for (let ccActionName of ccActionNames) {\r\n            let ccActData = this._actionMap[ccActionName];\r\n            //some keys could map to functions (like reset())\r\n            if (!(ccActData instanceof ActionData)) continue;\r\n            ccActData.sound = sound;\r\n            ccActData.sound.attachToMesh(this._avatar);\r\n        }\r\n        this._actionMap.idle.sound = null;\r\n        this._actionMap.fall.sound = null;\r\n        this._actionMap.slideBack.sound = null;\r\n    }\r\n\r\n\r\n    // setters for keys\r\n    public setWalkKey(key: string) {\r\n        this._actionMap.walk.key = key.toLowerCase();\r\n    }\r\n    public setWalkBackKey(key: string) {\r\n        this._actionMap.walkBack.key = key.toLowerCase();\r\n    }\r\n    public setTurnLeftKey(key: string) {\r\n        this._actionMap.turnLeft.key = key.toLowerCase();\r\n    }\r\n    public setTurnRightKey(key: string) {\r\n        this._actionMap.turnRight.key = key.toLowerCase();\r\n    }\r\n    public setStrafeLeftKey(key: string) {\r\n        this._actionMap.strafeLeft.key = key.toLowerCase();\r\n    }\r\n    public setStrafeRightKey(key: string) {\r\n        this._actionMap.strafeRight.key = key.toLowerCase();\r\n    }\r\n    public setJumpKey(key: string) {\r\n        this._actionMap.idleJump.key = key.toLowerCase();\r\n    }\r\n\r\n    public setCameraElasticity(b: boolean) {\r\n        this._cameraElastic = b;\r\n    }\r\n\r\n    public setElasticiSteps(n: number) {\r\n        this._elasticSteps = n;\r\n    }\r\n\r\n    public makeObstructionInvisible(b: boolean) {\r\n        this._makeInvisible = b;\r\n    }\r\n    public setCameraTarget(v: Vector3) {\r\n        this._cameraTarget.copyFrom(v);\r\n    }\r\n\r\n\r\n    /**\r\n     * user should call this whenever the user changes the camera checkCollision \r\n     * property\r\n     * \r\n     */\r\n    public cameraCollisionChanged() {\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n    }\r\n    public setNoFirstPerson(b: boolean) {\r\n        this._noFirstPerson = b;\r\n    }\r\n\r\n    /**\r\n     * if av has the required anim (walk, run etc) then \r\n     * mark that anim as existing\r\n     * \r\n     * @param skel \r\n     */\r\n\r\n    private _checkAnimRanges(skel: Skeleton) {\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let anim = this._actionMap[key];\r\n            if (!(anim instanceof ActionData)) continue;\r\n            if (skel != null) {\r\n                if (skel.getAnimationRange(anim.id) != null) {\r\n                    anim.name = anim.id;\r\n                    anim.exist = true;\r\n                    this._hasAnims = true;\r\n                }\r\n            } else {\r\n                anim.exist = false;\r\n            }\r\n        }\r\n        this._checkFastAnims();\r\n    }\r\n\r\n    /**\r\n     * if fast anims do not exist then use their slow counterpart as them but double the rate at which they play\r\n     */\r\n    private _checkFastAnims() {\r\n        this._copySlowAnims(this._actionMap.walkBackFast, this._actionMap.walkBack)\r\n        this._copySlowAnims(this._actionMap.turnRightFast, this._actionMap.turnRight);\r\n        this._copySlowAnims(this._actionMap.turnLeftFast, this._actionMap.turnLeft);\r\n        this._copySlowAnims(this._actionMap.strafeRightFast, this._actionMap.strafeRight);\r\n        this._copySlowAnims(this._actionMap.strafeLeftFast, this._actionMap.strafeLeft);\r\n    }\r\n\r\n    private _copySlowAnims(f: ActionData, s: ActionData) {\r\n        if (f.exist) return;\r\n        if (!s.exist) return;\r\n        f.exist = true;\r\n        f.ag = s.ag;\r\n        f.name = s.name;\r\n        f.rate = s.rate * 2;\r\n    }\r\n\r\n    /**\r\n     * Use this to make the  character controller suitable for a isometeric/top down games or  fps/third person game.\r\n     * 1 In isometric/top down games the camera direction has no bearing on avatar movement.\r\n     * 0 In fps/third person game rotating the camera around the avatar , rotates the avatr too.\r\n     */\r\n    private _mode = 0;\r\n    private _saveMode = 0;\r\n    public setMode(n: number) {\r\n        this._mode = n;\r\n        this._saveMode = n;\r\n    }\r\n    public getMode() {\r\n        return this._mode;\r\n    }\r\n    /**\r\n     * Use this to set  turning off.\r\n     * When turining is off \r\n     * a) turn left or turn right keys result in avatar facing and moving left or right with respect to camera.\r\n     * b) walkback/runback key results in avatar facing back and walking/running towards camera.\r\n     * \r\n     * This setting has no effect when mode is 1.\r\n     * \r\n     * @param b \r\n     */\r\n    public setTurningOff(b: boolean) {\r\n        this._noRot = b;\r\n    }\r\n    public isTurningOff() {\r\n        return this._noRot;\r\n    }\r\n\r\n    /**\r\n        * checks if a have left hand , right hand issue.\r\n        * In other words if a mesh is a LHS mesh in RHS system or \r\n        * a RHS mesh in LHS system\r\n        * The X axis will be reversed in such cases.\r\n        * thus Cross product of X and Y should be inverse of Z.\r\n        * BABYLONJS GLB models are RHS and exhibit this behavior\r\n        * \r\n        */\r\n    private _isLHS_RHS = false;\r\n    private _signLHS_RHS = -1;\r\n    private _setRHS(mesh: TransformNode) {\r\n        const meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        const _localX = Vector3.FromArray(<DeepImmutable<Float32Array>>meshMatrix.m, 0);\r\n        const _localY = Vector3.FromArray(<DeepImmutable<Float32Array>>meshMatrix.m, 4);\r\n        const _localZ = Vector3.FromArray(<DeepImmutable<Float32Array>>meshMatrix.m, 8);\r\n        const actualZ = Vector3.Cross(_localX, _localY);\r\n        //same direction or opposite direction of Z\r\n        if (Vector3.Dot(actualZ, _localZ) < 0) {\r\n            this._isLHS_RHS = true;\r\n            this._signLHS_RHS = 1;\r\n        }\r\n        else {\r\n            this._isLHS_RHS = false;\r\n            this._signLHS_RHS = -1;\r\n        }\r\n        console.log(\"have rhs lhs issue \" + this._isLHS_RHS);\r\n    }\r\n\r\n    /**\r\n     * Use setFaceForward(true|false) to indicate that the avatar's face  points forward (true) or backward (false).\r\n     * The avatar's face  points forward if its face is looking in positive local Z axis direction\r\n     */\r\n    private _ffSign: number;\r\n    private _rhsSign: number;\r\n    private _ff: boolean;\r\n    //in mode 0, av2cam is used to align avatar with camera , with camera always facing avatar's back\r\n    //note:camera alpha is measured anti-clockwise , avatar rotation is measured clockwise \r\n    private _av2cam;\r\n    public setFaceForward(b: boolean) {\r\n        this._ff = b;\r\n\r\n        this._rhsSign = this._scene.useRightHandedSystem ? -1 : 1;\r\n\r\n        if (this._isLHS_RHS) {\r\n            this._av2cam = b ? Math.PI / 2 : 3 * Math.PI / 2;\r\n            this._ffSign = b ? 1 : -1;\r\n        } else {\r\n            this._av2cam = b ? 3 * Math.PI / 2 : Math.PI / 2;\r\n            this._ffSign = b ? -1 : 1;\r\n        }\r\n\r\n    }\r\n\r\n    public isFaceForward() {\r\n        return this._ff;\r\n    }\r\n\r\n    private checkAGs(agMap: {}) {\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let anim = this._actionMap[key];\r\n            if (!(anim instanceof ActionData)) continue;\r\n            if (agMap[anim.name] != null) {\r\n                anim.ag = agMap[anim.name];\r\n                anim.exist = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // check if any of the mesh on the node tree is refrenced by any animation group\r\n    private _containsAG(node: Node, ags: AnimationGroup[], fromRoot: boolean) {\r\n        let r: Node;\r\n        let ns: Node[];\r\n\r\n        if (fromRoot) {\r\n            r = this._getRoot(node);\r\n            ns = r.getChildren((n) => { return (n instanceof TransformNode) }, false);\r\n        } else {\r\n            r = node;\r\n            ns = [r];\r\n        }\r\n\r\n        for (let ag of ags) {\r\n            let tas: TargetedAnimation[] = ag.targetedAnimations;\r\n            for (let ta of tas) {\r\n                if (ns.indexOf(ta.target) > -1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //get the root of Node\r\n    private _getRoot(tn: Node): Node {\r\n        if (tn.parent == null) return tn;\r\n        return this._getRoot(tn.parent);\r\n    }\r\n\r\n    private _started: boolean = false;\r\n    public start() {\r\n        if (this._started) return;\r\n        this._started = true;\r\n        this._act.reset();\r\n        this._movFallTime = 0;\r\n        //first time we enter render loop, delta time is zero\r\n        this._idleFallTime = 0.001;\r\n        this._grounded = false;\r\n        this._updateTargetValue();\r\n        this.enableKeyBoard(true);\r\n        this._scene.registerBeforeRender(this._renderer);\r\n    }\r\n\r\n    public stop() {\r\n        if (!this._started) return;\r\n        this._started = false;\r\n        this._scene.unregisterBeforeRender(this._renderer);\r\n        this.enableKeyBoard(false);\r\n        this._prevActData = null;\r\n    }\r\n\r\n    /**\r\n     * use pauseAnim to stop the charactere controller from playing\r\n     * any animation on the character\r\n     * use this when you want to play your animation instead\r\n     * see also resumeAnim()\r\n     */\r\n    private _stopAnim: boolean = false;\r\n    public pauseAnim() {\r\n        this._stopAnim = true;\r\n    }\r\n\r\n    /**\r\n     * use resumeAnim to resume the character controller playing\r\n     * animations on the character.\r\n     * see also pauseAnim()\r\n     */\r\n    public resumeAnim() {\r\n        this._stopAnim = false;\r\n    }\r\n\r\n    private _prevActData: ActionData = null;\r\n    private _avStartPos: Vector3 = Vector3.Zero();\r\n    private _grounded: boolean = false;\r\n    //distance by which AV would move down if in freefall\r\n    private _freeFallDist: number = 0;\r\n\r\n    //how many minimum contiguos frames should the AV have been in free fall\r\n    //before we assume AV is in big freefall.\r\n    //we will use this to remove animation flicker during move down a slope (fall, move, fall move etc)\r\n    //TODO: base this on slope - large slope large count\r\n    private _fallFrameCountMin: number = 50;\r\n    private _fallFrameCount: number = 0;\r\n\r\n    private _inFreeFall: boolean = false;\r\n    private _wasWalking: boolean = false;\r\n    private _wasRunning: boolean = false;\r\n    private _moveVector: Vector3;\r\n\r\n    //used only in mode 1\r\n    //value 1 or -1 , -1 if avatar is facing camera\r\n    //private _notFacingCamera = 1;\r\n\r\n    private _isAvFacingCamera(): number {\r\n        if (Vector3.Dot(this._avatar.forward, this._avatar.position.subtract(this._camera.position)) < 0) return 1\r\n        else return -1;\r\n    }\r\n\r\n    _currentActData: ActionData;\r\n    private _moveAVandCamera() {\r\n        this._avStartPos.copyFrom(this._avatar.position);\r\n        let actData: ActionData = null;\r\n        const dt: number = this._scene.getEngine().getDeltaTime() / 1000;\r\n\r\n        if (this._act._jump && !this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            actData = this._doJump(dt);\r\n        } else if (this.anyMovement() || this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            actData = this._doMove(dt);\r\n        } else if (!this._inFreeFall) {\r\n            actData = this._doIdle(dt);\r\n        }\r\n        if (!this._stopAnim && this._hasAnims && actData != null) {\r\n            if (this._prevActData !== actData) {\r\n                if (actData.exist) {\r\n\r\n                    //animation frame counts\r\n                    let c: number;\r\n                    let fps: number = 30;\r\n\r\n                    if (this._isAG) {\r\n                        if (this._prevActData != null && this._prevActData.exist) this._prevActData.ag.stop();\r\n                        //TODO use start instead of play ?\r\n                        //anim._ag.play(anim._loop);\r\n                        //anim._ag.speedRatio = anim._rate;\r\n                        actData.ag.start(actData.loop, actData.rate);\r\n                        //ag returns normalized frame values between 0 and 1\r\n                        fps = actData.ag.targetedAnimations[0].animation.framePerSecond\r\n                        c = (actData.ag.to - actData.ag.from) * fps;\r\n                    } else {\r\n                        let a: Animatable = this._skeleton.beginAnimation(actData.name, actData.loop, actData.rate);\r\n                        //a.onAnimationLoop = () => { if (actData.sound != null) actData.sound.play(); };\r\n                        this._currentActData = actData;\r\n                        c = this._skeleton.getAnimationRange(actData.name).to - this._skeleton.getAnimationRange(actData.name).from;\r\n                        fps = a.getAnimations()[0].animation.framePerSecond\r\n                    }\r\n\r\n                    //SOUND\r\n                    //TODO do sound as animationevent.\r\n                    if (this._prevActData != null && this._prevActData.sound != null) {\r\n                        this._prevActData.sound.stop();\r\n                    }\r\n                    clearInterval(this._sndId);\r\n                    if (actData.sound != null) {\r\n                        actData.sound.play();\r\n                        //play sound twice during the animation\r\n                        this._sndId = setInterval(() => { actData.sound.play(); }, c * 1000 / (fps * actData.rate * 2));\r\n                    }\r\n                }\r\n                this._prevActData = actData;\r\n            }\r\n        }\r\n        this._updateTargetValue();\r\n        return;\r\n    }\r\n\r\n    private _soundLoopTime = 700;\r\n    private _sndId = null;\r\n    private _ae: AnimationEvent = new AnimationEvent(0, () => { console.log(\"anim event playing\"); if (this._currentActData.sound != null) this._currentActData.sound.play(); });\r\n\r\n    //verical position of AV when it is about to start a jump\r\n    private _jumpStartPosY: number = 0;\r\n    //for how long the AV has been in the jump\r\n    private _jumpTime: number = 0;\r\n    private _doJump(dt: number): ActionData {\r\n\r\n        let actData: ActionData = null;\r\n        actData = this._actionMap.runJump;\r\n        if (this._jumpTime === 0) {\r\n            this._jumpStartPosY = this._avatar.position.y;\r\n        }\r\n\r\n        this._jumpTime = this._jumpTime + dt;\r\n\r\n        let forwardDist: number = 0;\r\n        let jumpDist: number = 0;\r\n        let disp: Vector3;\r\n        if (this._mode != 1 && !this._noRot) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        if (this._wasRunning || this._wasWalking) {\r\n            if (this._wasRunning) {\r\n                forwardDist = this._actionMap.run.speed * dt;\r\n            } else if (this._wasWalking) {\r\n                forwardDist = this._actionMap.walk.speed * dt;\r\n            }\r\n            //find out in which horizontal direction the AV was moving when it started the jump\r\n            disp = this._moveVector.clone();\r\n            disp.y = 0;\r\n            disp = disp.normalize();\r\n            disp.scaleToRef(forwardDist, disp);\r\n            jumpDist = this._calcJumpDist(this._actionMap.runJump.speed, dt);\r\n            disp.y = jumpDist;\r\n        } else {\r\n            jumpDist = this._calcJumpDist(this._actionMap.idleJump.speed, dt);\r\n            disp = new Vector3(0, jumpDist, 0);\r\n            actData = this._actionMap.idleJump;\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y/2;\r\n        }\r\n        //moveWithCollision only seems to happen if length of displacment is atleast 0.001\r\n        this._avatar.moveWithCollisions(disp);\r\n        if (jumpDist < 0) {\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y;\r\n            //check if going up a slope or back on flat ground \r\n            if ((this._avatar.position.y > this._avStartPos.y) || ((this._avatar.position.y === this._avStartPos.y) && (disp.length() > 0.001))) {\r\n                this._endJump();\r\n            } else if (this._avatar.position.y < this._jumpStartPosY) {\r\n                //the avatar is below the point from where it started the jump\r\n                //so it is either in free fall or is sliding along a downward slope\r\n                //\r\n                //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n                //else it is on a slope\r\n                const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                    //AV is on slope\r\n                    //Should AV continue to slide or stop?\r\n                    //if slope is less steeper than acceptable then stop else slide\r\n                    if (this._verticalSlope(actDisp) <= this._sl1) {\r\n                        this._endJump();\r\n                    }\r\n                } else {\r\n                    actData = this._actionMap.fall;\r\n                }\r\n            }\r\n        }\r\n        return actData;\r\n    }\r\n\r\n    private _calcJumpDist(speed: number, dt: number): number {\r\n        //up velocity at the begining of the lastt frame (v=u+at)\r\n        let js: number = speed - this._gravity * this._jumpTime;\r\n        //distance travelled up since last frame to this frame (s=ut+1/2*at^2)\r\n        let jumpDist: number = js * dt - 0.5 * this._gravity * dt * dt;\r\n        return jumpDist;\r\n    }\r\n\r\n    /**\r\n     * does cleanup at the end of a jump\r\n     */\r\n    private _endJump() {\r\n        this._act._jump = false;\r\n        this._jumpTime = 0;\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n    }\r\n\r\n    /**\r\n     * checks if two vectors v1 and v2 are equal within a precision of p\r\n     */\r\n    private _areVectorsEqual(v1: Vector3, v2: Vector3, p: number) {\r\n        return ((Math.abs(v1.x - v2.x) < p) && (Math.abs(v1.y - v2.y) < p) && (Math.abs(v1.z - v2.z) < p));\r\n    }\r\n\r\n    /*\r\n     * returns the slope (in radians) of a vector in the vertical plane\r\n     */\r\n    private _verticalSlope(v: Vector3): number {\r\n        return Math.atan(Math.abs(v.y / Math.sqrt(v.x * v.x + v.z * v.z)));\r\n    }\r\n\r\n    //for how long has the av been falling while moving\r\n    private _movFallTime: number = 0;\r\n    private _sign = 1;\r\n    private _isTurning = false;\r\n    private _noRot = false;\r\n    private _doMove(dt: number): ActionData {\r\n\r\n        //initial down velocity\r\n        const u: number = this._movFallTime * this._gravity\r\n        //calculate the distance by which av should fall down since last frame\r\n        //assuming it is in freefall\r\n        this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n\r\n        this._movFallTime = this._movFallTime + dt;\r\n\r\n        let moving: boolean = false;\r\n        let actdata: ActionData = null;\r\n\r\n        if (this._inFreeFall) {\r\n            this._moveVector.y = -this._freeFallDist;\r\n            moving = true;\r\n        }\r\n\r\n        //in case avatar was rotated by player, rotate camera around avatar to align with avatar\r\n        actdata = this._rotateC2AV(actdata, moving, dt);\r\n\r\n\r\n        //in case camera was rotated around avatar by player, rotate avatar to align with camera\r\n        this._rotateAV2C();\r\n\r\n        //now that avatar is rotated properly, construct the vector to move the avatar \r\n        //donot move the avatar if avatar is in freefall\r\n\r\n        if (!this._inFreeFall) {\r\n            this._wasWalking = false;\r\n            this._wasRunning = false;\r\n\r\n            let sign: number;\r\n            let horizDist: number = 0;\r\n            switch (true) {\r\n                case (this._act._stepLeft):\r\n                    sign = this._signLHS_RHS * this._isAvFacingCamera();\r\n                    horizDist = this._actionMap.strafeLeft.speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.strafeLeftFast.speed * dt;\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeftFast : this._actionMap.strafeRightFast;\r\n                    } else {\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeft : this._actionMap.strafeRight;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(sign * horizDist, -this._freeFallDist, 0);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._stepRight):\r\n                    sign = -this._signLHS_RHS * this._isAvFacingCamera();\r\n                    horizDist = this._actionMap.strafeRight.speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.strafeRightFast.speed * dt;\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeftFast : this._actionMap.strafeRightFast;\r\n                    } else {\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeft : this._actionMap.strafeRight;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(sign * horizDist, -this._freeFallDist, 0);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._walk || (this._noRot && this._mode == 0)):\r\n                    if (this._act._speedMod) {\r\n                        this._wasRunning = true;\r\n                        horizDist = this._actionMap.run.speed * dt;\r\n                        actdata = this._actionMap.run;\r\n                    } else {\r\n                        this._wasWalking = true;\r\n                        horizDist = this._actionMap.walk.speed * dt;\r\n                        actdata = this._actionMap.walk;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, this._ffSign * horizDist);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._walkback):\r\n                    horizDist = this._actionMap.walkBack.speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.walkBackFast.speed * dt;\r\n                        actdata = this._actionMap.walkBackFast;\r\n                    } else {\r\n                        actdata = this._actionMap.walkBack;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, -this._ffSign * horizDist);\r\n                    moving = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // move the avatar\r\n\r\n        if (moving) {\r\n            if (this._moveVector.length() > 0.001) {\r\n                this._avatar.moveWithCollisions(this._moveVector);\r\n                //walking up a slope\r\n                if (this._avatar.position.y > this._avStartPos.y) {\r\n                    const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                    const _slp: number = this._verticalSlope(actDisp);\r\n                    if (_slp >= this._sl2) {\r\n                        //this._climbingSteps=true;\r\n                        //is av trying to go up steps\r\n                        if (this._stepOffset > 0) {\r\n                            if (this._vMoveTot == 0) {\r\n                                //if just started climbing note down the position\r\n                                this._vMovStartPos.copyFrom(this._avStartPos);\r\n                            }\r\n                            this._vMoveTot = this._vMoveTot + (this._avatar.position.y - this._avStartPos.y);\r\n                            if (this._vMoveTot > this._stepOffset) {\r\n                                //move av back to its position at begining of steps\r\n                                this._vMoveTot = 0;\r\n                                this._avatar.position.copyFrom(this._vMovStartPos);\r\n                                this._endFreeFall();\r\n                            }\r\n                        } else {\r\n                            //move av back to old position\r\n                            this._avatar.position.copyFrom(this._avStartPos);\r\n                            this._endFreeFall();\r\n                        }\r\n                    } else {\r\n                        this._vMoveTot = 0;\r\n                        if (_slp > this._sl1) {\r\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                            this._fallFrameCount = 0;\r\n                            this._inFreeFall = false;\r\n                        } else {\r\n                            //continue walking\r\n                            this._endFreeFall();\r\n                        }\r\n                    }\r\n                } else if ((this._avatar.position.y) < this._avStartPos.y) {\r\n                    const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                    if (!(this._areVectorsEqual(actDisp, this._moveVector, 0.001))) {\r\n                        //AV is on slope\r\n                        //Should AV continue to slide or walk?\r\n                        //if slope is less steeper than acceptable then walk else slide\r\n                        if (this._verticalSlope(actDisp) <= this._sl1) {\r\n                            this._endFreeFall();\r\n                        } else {\r\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                            this._fallFrameCount = 0;\r\n                            this._inFreeFall = false;\r\n                        }\r\n                    } else {\r\n                        this._inFreeFall = true;\r\n                        this._fallFrameCount++;\r\n                        //AV could be running down a slope which mean freefall,run,frefall run ...\r\n                        //to remove anim flicker, check if AV has been falling down continously for last few consecutive frames\r\n                        //before changing to free fall animation\r\n                        if (this._fallFrameCount > this._fallFrameCountMin) {\r\n                            actdata = this._actionMap.fall;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this._endFreeFall();\r\n                }\r\n            }\r\n        }\r\n        return actdata;\r\n    }\r\n\r\n    /**\r\n     * rotate avatar to camera in case player is rotating camera around avatar\r\n     */\r\n\r\n\r\n    private _rotateAV2C() {\r\n        if (this._mode != 1) {\r\n            if (this._noRot) {\r\n                switch (true) {\r\n                    case (this._act._walk && this._act._turnRight):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + this._rhsSign * Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walk && this._act._turnLeft):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha - this._rhsSign * Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walkback && this._act._turnRight):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + this._rhsSign * 3 * Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walkback && this._act._turnLeft):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha - this._rhsSign * 3 * Math.PI / 4;\r\n                        break;\r\n                    case (this._act._walk):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n                        break;\r\n                    case (this._act._walkback):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + Math.PI;\r\n                        break;\r\n                    case (this._act._turnRight):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha + this._rhsSign * Math.PI / 2;\r\n                        break;\r\n                    case (this._act._turnLeft):\r\n                        this._avatar.rotation.y = this._av2cam - this._camera.alpha - this._rhsSign * Math.PI / 2;\r\n                        break;\r\n                }\r\n            } else {\r\n                this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n            }\r\n        }\r\n    }\r\n\r\n    //rotate camera around Avatar in case player is rotating avatar.\r\n    private _rotateC2AV(anim: ActionData, moving: boolean, dt: number): ActionData {\r\n        if (!(this._noRot && this._mode == 0) && (!this._act._stepLeft && !this._act._stepRight) && (this._act._turnLeft || this._act._turnRight)) {\r\n            let turnAngle = this._actionMap.turnLeft.speed * dt;\r\n            if (this._act._speedMod) {\r\n                turnAngle = 2 * turnAngle;\r\n            }\r\n            if (this._mode == 1) {\r\n                // while turining, the avatar could start facing away from camera and end up facing camera.\r\n                // we should not switch turning direction during this transition\r\n                if (!this._isTurning) {\r\n                    // if (this._act.name != this._act.prevName) {\r\n                    // this._act.prevName = this._act.name;\r\n                    this._sign = -this._ffSign * this._isAvFacingCamera();\r\n                    if (this._isLHS_RHS) this._sign = - this._sign;\r\n                    this._isTurning = true;\r\n                }\r\n                let a = this._sign;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._walk) { }\r\n                    else if (this._act._walkback) a = -this._sign;\r\n                    else {\r\n                        anim = (this._sign > 0) ? this._actionMap.turnRight : this._actionMap.turnLeft;\r\n                    }\r\n                } else {\r\n                    if (this._act._walk) a = -this._sign;\r\n                    else if (this._act._walkback) { }\r\n                    else {\r\n                        a = -this._sign;\r\n                        anim = (this._sign > 0) ? this._actionMap.turnLeft : this._actionMap.turnRight;\r\n                    }\r\n                }\r\n                this._avatar.rotation.y = this._avatar.rotation.y + turnAngle * a;\r\n            } else {\r\n                let a = 1;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._walkback) a = -1;\r\n                    if (!moving) anim = this._actionMap.turnLeft;\r\n                } else {\r\n                    if (this._act._walk) a = -1;\r\n                    if (!moving) { a = -1; anim = this._actionMap.turnRight; }\r\n                }\r\n                this._camera.alpha = this._camera.alpha + this._rhsSign * turnAngle * a;\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _endFreeFall(): void {\r\n        this._movFallTime = 0;\r\n        this._fallFrameCount = 0;\r\n        this._inFreeFall = false;\r\n    }\r\n\r\n    //for how long has the av been falling while idle (not moving)\r\n    private _idleFallTime: number = 0;\r\n    private _doIdle(dt: number): ActionData {\r\n        if (this._grounded) {\r\n            return this._actionMap.idle;\r\n        }\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n        this._movFallTime = 0;\r\n        let anim: ActionData = this._actionMap.idle;\r\n        this._fallFrameCount = 0;\r\n\r\n\r\n        if (dt === 0) {\r\n            this._freeFallDist = 5;\r\n        } else {\r\n            const u: number = this._idleFallTime * this._gravity\r\n            this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n            this._idleFallTime = this._idleFallTime + dt;\r\n        }\r\n        //if displacement is less than 0.01(? need to verify further) then \r\n        //moveWithDisplacement down against a surface seems to push the AV up by a small amount!!\r\n        if (this._freeFallDist < 0.01) return anim;\r\n        const disp: Vector3 = new Vector3(0, -this._freeFallDist, 0);\r\n        if (this._mode != 1 && !this._noRot) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        this._avatar.moveWithCollisions(disp);\r\n        if ((this._avatar.position.y > this._avStartPos.y) || (this._avatar.position.y === this._avStartPos.y)) {\r\n            //                this.grounded = true;\r\n            //                this.idleFallTime = 0;\r\n            this._groundIt();\r\n        } else if (this._avatar.position.y < this._avStartPos.y) {\r\n            //AV is going down. \r\n            //AV is either in free fall or is sliding along a downward slope\r\n            //\r\n            //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n            //else it is on a slope\r\n            const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n            if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                //AV is on slope\r\n                //Should AV continue to slide or stop?\r\n                //if slope is less steeper than accebtable then stop else slide\r\n                if (this._verticalSlope(actDisp) <= this._sl1) {\r\n                    //                        this.grounded = true;\r\n                    //                        this.idleFallTime = 0;\r\n                    this._groundIt();\r\n                    this._avatar.position.copyFrom(this._avStartPos);\r\n                } else {\r\n                    this._unGroundIt();\r\n                    anim = this._actionMap.slideBack;\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _groundFrameCount = 0;\r\n    private _groundFrameMax = 10;\r\n    /**\r\n     * donot ground immediately\r\n     * wait few more frames\r\n     */\r\n    private _groundIt(): void {\r\n        this._groundFrameCount++;\r\n        if (this._groundFrameCount > this._groundFrameMax) {\r\n            this._grounded = true;\r\n            this._idleFallTime = 0;\r\n        }\r\n    }\r\n    private _unGroundIt() {\r\n        this._grounded = false;\r\n        this._groundFrameCount = 0;\r\n    }\r\n\r\n    private _savedCameraCollision: boolean = true;\r\n    private _inFP = false;\r\n    private _updateTargetValue() {\r\n        //donot move camera if av is trying to clinb steps\r\n        if (this._vMoveTot == 0)\r\n            this._avatar.position.addToRef(this._cameraTarget, this._camera.target);\r\n\r\n        if (this._camera.radius > this._camera.lowerRadiusLimit) { if (this._cameraElastic || this._makeInvisible) this._handleObstruction(); }\r\n\r\n        if (this._camera.radius <= this._camera.lowerRadiusLimit) {\r\n            if (!this._noFirstPerson && !this._inFP) {\r\n                this._avatar.visibility = 0;\r\n                this._camera.checkCollisions = false;\r\n                this._saveMode = this._mode;\r\n                this._mode = 0;\r\n                this._inFP = true;\r\n            }\r\n        } else {\r\n            this._inFP = false;\r\n            this._mode = this._saveMode;\r\n            this._avatar.visibility = 1;\r\n            this._camera.checkCollisions = this._savedCameraCollision;\r\n        }\r\n    }\r\n\r\n    private _ray: Ray = new Ray(Vector3.Zero(), Vector3.One(), 1);\r\n    private _rayDir: Vector3 = Vector3.Zero();\r\n    //camera seems to get stuck into things\r\n    //should move camera away from things by a value of cameraSkin\r\n    private _cameraSkin: number = 0.5;\r\n    private _prevPickedMeshes: AbstractMesh[];\r\n    private _pickedMeshes: AbstractMesh[] = new Array();;\r\n    private _makeInvisible = false;\r\n    private _elasticSteps = 50;\r\n    private _alreadyInvisible: AbstractMesh[];\r\n\r\n    /**\r\n     * The following method handles the use case wherein some mesh\r\n     * comes between the avatar and the camera thus obstructing the view\r\n     * of the avatar.\r\n     * Two ways this can be handled\r\n     * a) make the obstructing  mesh invisible\r\n     *   instead of invisible a better option would have been to make semi transparent.\r\n     *   Unfortunately, unlike mesh, mesh instances do not \"visibility\" setting)\r\n     *   Every alternate frame make mesh visible and invisible to give the impression of semi-transparent.\r\n     * b) move the camera in front of the obstructing mesh\r\n     */\r\n    private _handleObstruction() {\r\n\r\n        //get vector from av (camera.target) to camera\r\n        this._camera.position.subtractToRef(this._camera.target, this._rayDir);\r\n        //start ray from av to camera\r\n        this._ray.origin = this._camera.target;\r\n        this._ray.length = this._rayDir.length();\r\n        this._ray.direction = this._rayDir.normalize();\r\n\r\n        //TODO \r\n        //handle case were pick is with a child of avatar, avatar atatchment. etc\r\n        const pis: PickingInfo[] = this._scene.multiPickWithRay(this._ray, (mesh) => {\r\n            if (mesh == this._avatar) return false;\r\n            else return true;\r\n        });\r\n\r\n\r\n        if (this._makeInvisible) {\r\n            this._prevPickedMeshes = this._pickedMeshes;\r\n            if (pis.length > 0) {\r\n                this._pickedMeshes = new Array();\r\n                for (let pi of pis) {\r\n                    if (pi.pickedMesh.isVisible || this._prevPickedMeshes.includes(pi.pickedMesh)) {\r\n                        pi.pickedMesh.isVisible = false;\r\n                        this._pickedMeshes.push(pi.pickedMesh);\r\n                    }\r\n                }\r\n                for (let pm of this._prevPickedMeshes) {\r\n                    if (!this._pickedMeshes.includes(pm)) {\r\n                        pm.isVisible = true;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let pm of this._prevPickedMeshes) {\r\n                    pm.isVisible = true;\r\n                }\r\n                this._prevPickedMeshes.length = 0;\r\n            }\r\n        }\r\n\r\n        if (this._cameraElastic) {\r\n            if (pis.length > 0) {\r\n                // postion the camera in front of the mesh that is obstructing camera\r\n\r\n                //if only one obstruction and it is invisible then if it is not collidable or our camera is not collidable then do nothing\r\n                if ((pis.length == 1 && !this._isSeeAble(pis[0].pickedMesh)) && (!pis[0].pickedMesh.checkCollisions || !this._camera.checkCollisions)) return;\r\n\r\n                //if our camera is collidable then we donot want it to get stuck behind another collidable obsrtucting mesh\r\n                let pp: Vector3 = null;\r\n\r\n                //we will asume the order of picked meshes is from closest to avatar to furthest\r\n                //we should get the first one which is visible or invisible and collidable\r\n                for (let i = 0; i < pis.length; i++) {\r\n                    let pm = pis[i].pickedMesh;\r\n                    if (this._isSeeAble(pm)) {\r\n                        pp = pis[i].pickedPoint;\r\n                        break;\r\n                    } else if (pm.checkCollisions) {\r\n                        pp = pis[i].pickedPoint;\r\n                        break;\r\n                    }\r\n                }\r\n                if (pp == null) return;\r\n\r\n                const c2p: Vector3 = this._camera.position.subtract(pp);\r\n                //note that when camera is collidable, changing the orbital camera radius may not work.\r\n                //changing the radius moves the camera forward (with collision?) and collision can interfere with movement\r\n                //\r\n                //in every cylce we are dividing the distance to tarvel by same number of steps.\r\n                //as we get closer to destination the speed will thus slow down.\r\n                //when just 1 unit distance left, lets snap to the final position.\r\n                //when calculating final position make sure the camera does not get stuck at the pickposition especially\r\n                //if collision is on\r\n\r\n                const l: number = c2p.length();\r\n                if (this._camera.checkCollisions) {\r\n                    let step: Vector3;\r\n                    if (l <= 1) {\r\n                        step = c2p.addInPlace(c2p.normalizeToNew().scaleInPlace(this._cameraSkin));\r\n                    } else {\r\n                        step = c2p.normalize().scaleInPlace(l / this._elasticSteps);\r\n                    }\r\n                    this._camera.position = this._camera.position.subtract(step);\r\n                } else {\r\n                    let step: number;\r\n                    if (l <= 1) step = l + this._cameraSkin; else step = l / this._elasticSteps;\r\n                    this._camera.radius = this._camera.radius - (step);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //how many ways can a mesh be invisible?\r\n    private _isSeeAble(mesh: AbstractMesh): boolean {\r\n        if (!mesh.isVisible) return false;\r\n        if (mesh.visibility == 0) return false;\r\n        if (mesh.material != null && mesh.material.alphaMode != 0 && mesh.material.alpha == 0) return false;\r\n        return true;\r\n        //what about vertex color? groan!\r\n    }\r\n\r\n\r\n    private _move: boolean = false;\r\n    public anyMovement(): boolean {\r\n        return (this._act._walk || this._act._walkback || this._act._turnLeft || this._act._turnRight || this._act._stepLeft || this._act._stepRight);\r\n    }\r\n\r\n    private _onKeyDown(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        if (e.repeat) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case this._actionMap.idleJump.key:\r\n                this._act._jump = true;\r\n                break;\r\n            case \"capslock\":\r\n                this._act._speedMod = !this._act._speedMod;\r\n                break;\r\n            case \"shift\":\r\n                this._act._speedMod = true;\r\n                break;\r\n            case \"up\":\r\n            case \"arrowup\":\r\n            case this._actionMap.walk.key:\r\n                this._act._walk = true;\r\n                break;\r\n            case \"left\":\r\n            case \"arrowleft\":\r\n            case this._actionMap.turnLeft.key:\r\n                this._act._turnLeft = true;\r\n                break;\r\n            case \"right\":\r\n            case \"arrowright\":\r\n            case this._actionMap.turnRight.key:\r\n                this._act._turnRight = true;\r\n                break;\r\n            case \"down\":\r\n            case \"arrowdown\":\r\n            case this._actionMap.walkBack.key:\r\n                this._act._walkback = true;\r\n                break;\r\n            case this._actionMap.strafeLeft.key:\r\n                this._act._stepLeft = true;\r\n                break;\r\n            case this._actionMap.strafeRight.key:\r\n                this._act._stepRight = true;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    private _onKeyUp(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case \"shift\":\r\n                this._act._speedMod = false;\r\n                break;\r\n            case \"up\":\r\n            case \"arrowup\":\r\n            case this._actionMap.walk.key:\r\n                this._act._walk = false;\r\n                break;\r\n            case \"left\":\r\n            case \"arrowleft\":\r\n            case this._actionMap.turnLeft.key:\r\n                this._act._turnLeft = false;\r\n                this._isTurning = false;\r\n                break;\r\n            case \"right\":\r\n            case \"arrowright\":\r\n            case this._actionMap.turnRight.key:\r\n                this._act._turnRight = false;\r\n                this._isTurning = false;\r\n                break;\r\n            case \"down\":\r\n            case \"arrowdown\":\r\n            case this._actionMap.walkBack.key:\r\n                this._act._walkback = false;\r\n                break;\r\n            case this._actionMap.strafeLeft.key:\r\n                this._act._stepLeft = false;\r\n                break;\r\n            case this._actionMap.strafeRight.key:\r\n                this._act._stepRight = false;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    private _ekb: boolean;\r\n    public enableKeyBoard(b: boolean) {\r\n        this._ekb = b;\r\n        let canvas: HTMLCanvasElement = this._scene.getEngine().getRenderingCanvas();\r\n        if (b) {\r\n            canvas.addEventListener(\"keyup\", this._handleKeyUp, false);\r\n            canvas.addEventListener(\"keydown\", this._handleKeyDown, false);\r\n        } else {\r\n            canvas.removeEventListener(\"keyup\", this._handleKeyUp, false);\r\n            canvas.removeEventListener(\"keydown\", this._handleKeyDown, false);\r\n        }\r\n    }\r\n\r\n    // control movement by commands rather than keyboard.\r\n    public walk(b: boolean) {\r\n        this._act._walk = b;\r\n    }\r\n    public walkBack(b: boolean) {\r\n        this._act._walkback = b;\r\n    }\r\n    public walkBackFast(b: boolean) {\r\n        this._act._walkback = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public run(b: boolean) {\r\n        this._act._walk = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public turnLeft(b: boolean) {\r\n        this._act._turnLeft = b;\r\n        if (!b) this._isTurning = b;\r\n    }\r\n    public turnLeftFast(b: boolean) {\r\n        this._act._turnLeft = b;\r\n        if (!b) this._isTurning = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public turnRight(b: boolean) {\r\n        this._act._turnRight = b;\r\n        if (!b) this._isTurning = b;\r\n    }\r\n    public turnRightFast(b: boolean) {\r\n        this._act._turnRight = b;\r\n        if (!b) this._isTurning = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public strafeLeft(b: boolean) {\r\n        this._act._stepLeft = b;\r\n    }\r\n    public strafeLeftFast(b: boolean) {\r\n        this._act._stepLeft = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public strafeRight(b: boolean) {\r\n        this._act._stepRight = b;\r\n    }\r\n    public strafeRightFast(b: boolean) {\r\n        this._act._stepRight = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public jump() {\r\n        this._act._jump = true;\r\n    }\r\n    public idle() {\r\n        this._act.reset();\r\n    }\r\n\r\n    private _act: _Action;\r\n    private _renderer: () => void;\r\n    private _handleKeyUp: (e) => void;\r\n    private _handleKeyDown: (e) => void;\r\n    private _isAG: boolean = false;\r\n    public isAg() {\r\n        return this._isAG;\r\n    }\r\n\r\n\r\n\r\n\r\n    private _findSkel(n: Node): Skeleton {\r\n        let root = this._root(n);\r\n\r\n        if (root instanceof Mesh && root.skeleton) return root.skeleton;\r\n\r\n        //find all child meshes which have skeletons\r\n        let ms = root.getChildMeshes(\r\n            false,\r\n            (cm) => {\r\n                if (cm instanceof Mesh) {\r\n                    if (cm.skeleton) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            });\r\n\r\n        //return the skeleton of the first child mesh\r\n        if (ms.length > 0) return ms[0].skeleton; else return null;\r\n\r\n    }\r\n\r\n    private _root(tn: Node): Node {\r\n        if (tn.parent == null) return tn;\r\n        return this._root(tn.parent);\r\n    }\r\n\r\n    public setAvatar(avatar: Mesh, faceForward: boolean = false): boolean {\r\n\r\n        let rootNode = this._root(avatar);\r\n        if (rootNode instanceof Mesh) {\r\n            this._avatar = rootNode;\r\n        } else {\r\n            console.error(\"Cannot move this mesh. The root node of the mesh provided is not a mesh\");\r\n            return false;\r\n        }\r\n\r\n        this._skeleton = this._findSkel(avatar);\r\n        this._isAG = this._containsAG(avatar, this._scene.animationGroups, true);\r\n\r\n        this._actionMap.reset();\r\n\r\n        //animation ranges\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n\r\n        this._setRHS(avatar);\r\n        this.setFaceForward(faceForward);\r\n\r\n        return true;\r\n    }\r\n\r\n    public getAvatar() {\r\n        return this._avatar;\r\n    }\r\n\r\n    // force a skeleton to be the avatar skeleton\r\n    // should not be calling this normally\r\n    public setAvatarSkeleton(skeleton: Skeleton) {\r\n        this._skeleton = skeleton;\r\n\r\n\r\n        if (this._skeleton != null && this._skelDrivenByAG(skeleton)) this._isAG = true; else this._isAG = false;\r\n\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n    }\r\n\r\n\r\n    // this check if any of this skeleton animations is referenced by any targetedAnimation in any of the animationgroup in the scene.\r\n    private _skelDrivenByAG(skeleton: Skeleton) {\r\n        return skeleton.animations.some(sa => this._scene.animationGroups.some(ag => ag.children.some(ta => ta.animation == sa)));\r\n    }\r\n\r\n    public getSkeleton() {\r\n        return this._skeleton;\r\n    }\r\n\r\n    // does this character have any animations ?\r\n    // remember we can use meshes without anims as characters too\r\n    private _hasAnims: boolean = false;\r\n\r\n    /**\r\n     * The avatar/character can be made up of multiple meshes arranged in a hierarchy.\r\n     * As such we will pick the root of the hierarchy as the avatar.\r\n     * The root should be a mesh as otherwise we cannot move it with moveWithCollision() method.\r\n     * \r\n     * Mutiple meshes in the hierarchy may have skeletons (if two or more meshes have skeleton then\r\n     * the skeleton will mostly likely be the same). \r\n     * So we will pick as avatar skeleton, the  skeleton of the first mesh in the hierachy which has\r\n     * a skeleton \r\n     * \r\n     * @param avatar \r\n     * @param camera \r\n     * @param scene \r\n     * @param actionMap/animationGroupMap \r\n     *        maps actions to animations and other data like speed,sound etc \r\n     *        or \r\n     *        for backward compatibility could be AnimationGroup Map\r\n     * @param faceForward \r\n     */\r\n    constructor(avatar: Mesh, camera: ArcRotateCamera, scene: Scene, actionMap?: {}, faceForward = false) {\r\n\r\n        this._camera = camera;\r\n        this._scene = scene;\r\n\r\n        let success = this.setAvatar(avatar, faceForward);\r\n        if (!success) {\r\n            console.error(\"unable to set avatar\");\r\n        }\r\n\r\n\r\n        let dataType: string = null;\r\n        if (actionMap != null) {\r\n            dataType = this.setActionMap(<ActionMap>actionMap);\r\n        }\r\n\r\n        //try to use the existing avatar animations\r\n\r\n        //animation ranges\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n        //animation groups\r\n        if (this._isAG) {\r\n            //TODO\r\n        }\r\n\r\n\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n\r\n        this._act = new _Action();\r\n\r\n        this._renderer = () => { this._moveAVandCamera() };\r\n        this._handleKeyUp = (e) => { this._onKeyUp(e) };\r\n        this._handleKeyDown = (e) => { this._onKeyDown(e) };\r\n    }\r\n}\r\n\r\n\r\n\r\nclass _Action {\r\n\r\n    public _walk: boolean = false;\r\n    public _walkback: boolean = false;\r\n    public _turnRight: boolean = false;\r\n    public _turnLeft: boolean = false;\r\n    public _stepRight: boolean = false;\r\n    public _stepLeft: boolean = false;\r\n    public _jump: boolean = false;\r\n\r\n    // speed modifier - changes speed of movement\r\n    public _speedMod: boolean = false;\r\n\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    reset() {\r\n        this._walk = false;\r\n        this._walkback = false;\r\n        this._turnRight = false;\r\n        this._turnLeft = false;\r\n        this._stepRight = false;\r\n        this._stepLeft = false;\r\n        this._jump = false;\r\n        this._speedMod = false;\r\n    }\r\n}\r\n\r\nexport class ActionData {\r\n    public id: string;\r\n    public speed: number;\r\n    //_ds default speed.  speed is set to this on reset\r\n    public ds: number;\r\n    public sound: Sound;\r\n    public key: string;\r\n    //_dk defailt key\r\n    public dk: string;\r\n\r\n    //animation data\r\n    //if _ag is null then assuming animation range and use _name to play animationrange\r\n    //instead of name maybe call it arName?\r\n    public name: string = \"\";\r\n    public ag: AnimationGroup;\r\n    public loop: boolean = true;\r\n    public rate: number = 1;\r\n\r\n    public exist: boolean = false;\r\n\r\n    public constructor(id?: string, speed = 1, key?: string) {\r\n        this.id = id;\r\n        this.speed = speed;\r\n        this.ds = speed;\r\n        this.key = key;\r\n        this.dk = key;\r\n    }\r\n\r\n    public reset() {\r\n        this.name = \"\";\r\n        this.speed = this.ds;\r\n        this.key = this.dk;\r\n        this.loop = true;\r\n        this.rate = 1;\r\n        this.sound = null;\r\n        this.exist = false;\r\n    }\r\n\r\n}\r\n\r\n//not really a \"Map\"\r\nexport class ActionMap {\r\n    public walk = new ActionData(\"walk\", 3, \"w\");\r\n    public walkBack = new ActionData(\"walkBack\", 1.5, \"s\");\r\n    public walkBackFast = new ActionData(\"walkBackFast\", 3, \"na\");\r\n    public idle = new ActionData(\"idle\", 0, \"na\");\r\n    public idleJump = new ActionData(\"idleJump\", 6, \" \");\r\n    public run = new ActionData(\"run\", 6, \"na\");\r\n    public runJump = new ActionData(\"runJump\", 6, \"na\");\r\n    public fall = new ActionData(\"fall\", 0, \"na\");\r\n    public turnLeft = new ActionData(\"turnLeft\", Math.PI / 8, \"a\");\r\n    public turnLeftFast = new ActionData(\"turnLeftFast\", Math.PI / 4, \"na\");\r\n    public turnRight = new ActionData(\"turnRight\", Math.PI / 8, \"d\");\r\n    public turnRightFast = new ActionData(\"turnRightFast\", Math.PI / 4, \"na\");\r\n    public strafeLeft = new ActionData(\"strafeLeft\", 1.5, \"q\");\r\n    public strafeLeftFast = new ActionData(\"strafeLeftFast\", 3, \"na\");\r\n    public strafeRight = new ActionData(\"strafeRight\", 1.5, \"e\");\r\n    public strafeRightFast = new ActionData(\"strafeRightFast\", 3, \"na\");\r\n    public slideBack = new ActionData(\"slideBack\", 0, \"na\");\r\n\r\n    public reset() {\r\n        let keys: string[] = Object.keys(this);\r\n        for (let key of keys) {\r\n            let act = this[key];\r\n            if (!(act instanceof ActionData)) continue;\r\n            act.reset()\r\n        }\r\n    }\r\n};\r\n\r\nexport class CCSettings {\r\n    public faceForward: boolean;\r\n    public gravity: number;\r\n    public minSlopeLimit: number;\r\n    public maxSlopeLimit: number;\r\n    public stepOffset: number;\r\n    public cameraElastic: boolean = true;\r\n    public elasticSteps: number;\r\n    public makeInvisble: boolean = true;\r\n    public cameraTarget: Vector3 = Vector3.Zero();\r\n    public noFirstPerson: boolean = false;\r\n    public topDown: boolean = true;\r\n    //turningOff takes effect only when topDown is false\r\n    public turningOff: boolean = true;\r\n    public keyboard: boolean = true;\r\n    public sound: Sound;\r\n}\r\n"],"sourceRoot":""}