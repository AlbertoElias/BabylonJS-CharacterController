{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///external {\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\",\"root\":\"BABYLON\"}","webpack:///./src/CharacterController.ts"],"names":["root","factory","exports","module","require","define","amd","a","i","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","avatar","camera","scene","agMap","faceForward","_walkSpeed","_runSpeed","this","_backSpeed","_jumpSpeed","_leftSpeed","_rightSpeed","_turnSpeed","Math","PI","_gravity","_minSlopeLimit","_maxSlopeLimit","_sl","_sl2","_stepOffset","_vMoveTot","_vMovStartPos","Zero","_walk","AnimData","_walkBack","_idle","_idleJump","_run","_runJump","_fall","_turnLeft","_turnRight","_strafeLeft","_strafeRight","_slideBack","_anims","_walkKey","_walkBackKey","_turnLeftKey","_turnRightKey","_strafeLeftKey","_strafeRightKey","_jumpKey","_elasticCamera","_cameraTarget","_noFirstPerson","_saveMode","_isRHS","_signRHS","_started","_stopAnim","_prevAnim","_avStartPos","_grounded","_freeFallDist","_fallFrameCountMin","_fallFrameCount","_inFreeFall","_wasWalking","_wasRunning","_jumpStartPosY","_jumpTime","_movFallTime","_sign","_idleFallTime","_groundFrameCount","_groundFrameMax","_savedCameraCollision","_inFP","_ray","One","_rayDir","_cameraSkin","_skip","_move","_isAG","_hasAnims","_avatar","_setRHS","setFaceForward","_scene","setAnimationGroups","_skeleton","skeleton","checkAnims","_camera","checkCollisions","_act","Action","_renderer","_moveAVandCamera","_handleKeyUp","e","_onKeyUp","_handleKeyDown","_onKeyDown","setAvatar","setAvatarSkeleton","setSlopeLimit","minSlopeLimit","maxSlopeLimit","setStepOffset","stepOffset","setWalkSpeed","setRunSpeed","setBackSpeed","setJumpSpeed","setLeftSpeed","setRightSpeed","setTurnSpeed","setGravity","anim","ag","exist","setAnimationRanges","arMap","arData","loop","setAnim","rangeName","rate","speedRatio","getAnimationRange","enableBlending","targetedAnimations","ta","animation","blendingSpeed","disableBlending","setWalkAnim","setRunAnim","setWalkBackAnim","setSlideBackAnim","setIdleAnim","setTurnRightAnim","setTurnLeftAnim","setStrafeRightAnim","setStrafeLeftAnim","setIdleJumpAnim","setRunJumpAnim","setFallAnim","setWalkKey","toLowerCase","setWalkBackKey","setTurnLeftKey","setTurnRightKey","setStrafeLeftKey","setStrafeRightKey","setJumpKey","setCameraElasticity","b","setCameraTarget","v","copyFrom","cameraCollisionChanged","setNoFirstPerson","skel","setMode","mesh","meshMatrix","getWorldMatrix","_localX","FromFloatArray","_localY","_localZ","actualZ","Cross","Dot","_av2cam","_ffSign","checkAGs","start","reset","_updateTargetValue","enableKeyBoard","registerBeforeRender","stop","unregisterBeforeRender","disableKeyBoard","pauseAnim","resumeAnim","_isAvFacingCamera","forward","position","subtract","dt","getEngine","getDeltaTime","_jump","_doJump","anyMovement","_doMove","_doIdle","play","beginAnimation","y","jumpDist","disp","forwardDist","rotation","alpha","_moveVector","clone","normalize","scaleToRef","moveWithCollisions","length","_endJump","actDisp","_areVectorsEqual","_verticalSlope","v1","v2","abs","x","z","atan","sqrt","u","moving","_forward","_shift","calcMovePOV","_backward","_stepLeft","sign","_stepRight","prevName","_endFreeFall","_groundIt","_unGroundIt","addToRef","target","radius","lowerRadiusLimit","_snapCamera","visibility","subtractToRef","origin","direction","pi","pickWithRay","hit","newPos","pickedPoint","scale","nr","repeat","removeEventListener","addEventListener","walk","walkBack","run","turnLeft","turnRight","strafeLeft","strafeRight","jump","idle"],"mappings":"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","file":"CharacterController.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"babylonjs\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"babylonjs\")) : factory(root[\"BABYLON\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import {\r\n    Skeleton,\r\n    ArcRotateCamera,\r\n    Vector3,\r\n    Mesh,\r\n    Scene,\r\n    Ray,\r\n    PickingInfo,\r\n    AnimationGroup,\r\n    TransformNode,\r\n    Matrix\r\n} from \"babylonjs\"\r\n\r\nexport class CharacterController {\r\n\r\n    private _avatar: Mesh;\r\n    private _skeleton: Skeleton;\r\n    private _camera: ArcRotateCamera;\r\n    private _scene: Scene;\r\n\r\n    //avatar speed in meters/second\r\n    private _walkSpeed: number = 3;\r\n    private _runSpeed: number = this._walkSpeed * 2;\r\n    private _backSpeed: number = this._walkSpeed / 2;\r\n    private _jumpSpeed: number = this._walkSpeed * 2;\r\n    private _leftSpeed: number = this._walkSpeed / 2;\r\n    private _rightSpeed: number = this._walkSpeed / 2;\r\n    //trun speed in radian per second (equivalent to 180 degree/second by default)\r\n    private _turnSpeed: number = Math.PI;\r\n    private _gravity: number = 9.8;\r\n    //slopeLimit in degrees\r\n    private _minSlopeLimit: number = 30;\r\n    private _maxSlopeLimit: number = 45;\r\n    //slopeLimit in radians\r\n    private _sl: number = Math.PI * this._minSlopeLimit / 180;\r\n    private _sl2: number = Math.PI * this._maxSlopeLimit / 180;\r\n\r\n    //The av will step up a stair only if it is closer to the ground than the indicated value.\r\n    private _stepOffset: number = 0.25;\r\n    //toal amount by which the av has moved up\r\n    private _vMoveTot: number = 0;\r\n    //position of av when it started moving up\r\n    private _vMovStartPos: Vector3 = Vector3.Zero();\r\n\r\n    //animations\r\n    private _walk: AnimData = new AnimData(\"walk\");\r\n    private _walkBack: AnimData = new AnimData(\"walkBack\");\r\n    private _idle: AnimData = new AnimData(\"idle\");\r\n    private _idleJump: AnimData = new AnimData(\"idleJump\");\r\n    private _run: AnimData = new AnimData(\"run\");\r\n    private _runJump: AnimData = new AnimData(\"runJump\");\r\n    private _fall: AnimData = new AnimData(\"fall\");\r\n    private _turnLeft: AnimData = new AnimData(\"turnLeft\");\r\n    private _turnRight: AnimData = new AnimData(\"turnRight\");\r\n    private _strafeLeft: AnimData = new AnimData(\"strafeLeft\");\r\n    private _strafeRight: AnimData = new AnimData(\"strafeRight\");\r\n    private _slideBack: AnimData = new AnimData(\"slideBack\");\r\n\r\n    private _anims: AnimData[] = [this._walk, this._walkBack, this._idle, this._idleJump, this._run, this._runJump, this._fall, this._turnLeft, this._turnRight, this._strafeLeft, this._strafeRight, this._slideBack];\r\n\r\n    //move keys\r\n    private _walkKey: string = \"w\";\r\n    private _walkBackKey: string = \"s\";\r\n    private _turnLeftKey: string = \"a\";\r\n    private _turnRightKey: string = \"d\";\r\n    private _strafeLeftKey: string = \"q\";\r\n    private _strafeRightKey: string = \"e\";\r\n    private _jumpKey: string = \" \";\r\n\r\n    private _elasticCamera: boolean = true;\r\n    private _cameraTarget: Vector3 = Vector3.Zero();\r\n    //should we go into first person view when camera is near avatar (radius is lowerradius limit)\r\n    private _noFirstPerson: boolean = false;\r\n\r\n    public setAvatar(avatar: Mesh) {\r\n        this._avatar = avatar;\r\n    }\r\n\r\n    public setAvatarSkeleton(skeleton: Skeleton) {\r\n        this._skeleton = skeleton;\r\n        this.checkAnims(skeleton);\r\n    }\r\n\r\n    public setSlopeLimit(minSlopeLimit: number, maxSlopeLimit: number) {\r\n        this._minSlopeLimit = minSlopeLimit;\r\n        this._maxSlopeLimit = maxSlopeLimit;\r\n\r\n        this._sl = Math.PI * minSlopeLimit / 180;\r\n        this._sl2 = Math.PI * this._maxSlopeLimit / 180;\r\n    }\r\n\r\n    /**\r\n     * The av will step up a stair only if it is closer to the ground than the indicated value.\r\n     * Default value is 0.25 m\r\n     */\r\n    public setStepOffset(stepOffset: number) {\r\n        this._stepOffset = stepOffset;\r\n    }\r\n\r\n    public setWalkSpeed(n: number) {\r\n        this._walkSpeed = n;\r\n    }\r\n    public setRunSpeed(n: number) {\r\n        this._runSpeed = n;\r\n    }\r\n    public setBackSpeed(n: number) {\r\n        this._backSpeed = n;\r\n    }\r\n    public setJumpSpeed(n: number) {\r\n        this._jumpSpeed = n;\r\n    }\r\n    public setLeftSpeed(n: number) {\r\n        this._leftSpeed = n;\r\n    }\r\n    public setRightSpeed(n: number) {\r\n        this._rightSpeed = n;\r\n    }\r\n    // get turnSpeed in degrees per second.\r\n    // store in radians per second\r\n    public setTurnSpeed(n: number) {\r\n        this._turnSpeed = n * Math.PI / 180;\r\n    }\r\n    public setGravity(n: number) {\r\n        this._gravity = n;\r\n    }\r\n\r\n    /**\r\n     * Use this to provide animationGroups to the character controller.\r\n     * Provide the AnimationGroups using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animationGroup.\r\n     * Example:\r\n     * let myWalkAnimationGroup:AnimationGroup = ...;\r\n     * let agMap:{} = {\r\n     *  \"walk\":myWalkAnimationGroup,\r\n     *   ....\r\n     * }\r\n     * \r\n     * @param agMap a map of character controller animation name to animationGroup\r\n     */\r\n    public setAnimationGroups(agMap: {}) {\r\n        this._isAG = true;\r\n        for (let anim of this._anims) {\r\n            if (agMap[anim.name] != null) {\r\n                anim.ag = agMap[anim.name];\r\n                anim.exist = true;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Use this to provide AnimationRanges to the character controller.\r\n     * Provide the AnimationRanges using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animation range name or an object with animation range data.\r\n     * example:\r\n     * let arMap = {\r\n     *  \"walk\":\"myWalk\",\r\n     *  \"run\" : {\"name\":\"myRun\",\"rate\":1},\r\n     *  \"idle\" : {\"name\":\"myIdle\",\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     * }\r\n     * \r\n     * @param arMap a map of character controller animation name to animationRange data\r\n     */\r\n\r\n    public setAnimationRanges(arMap: {}) {\r\n        this._isAG = false;\r\n        let arData: string | {};\r\n        for (let anim of this._anims) {\r\n            arData = arMap[anim.name];\r\n            if (arData != null) {\r\n                if (arData instanceof Object) {\r\n                    if (arData[\"name\"]) anim.name = arData[\"name\"];\r\n                    if (arData[\"loop\"]) anim.loop = arData[\"loop\"];\r\n                    if (arData[\"rate\"]) anim.loop = arData[\"rate\"];\r\n                } else {\r\n                    anim.name = arData;\r\n                }\r\n                anim.exist = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private setAnim(anim: AnimData, rangeName?: string | AnimationGroup, rate?: number, loop?: boolean) {\r\n        if (!this._isAG && this._skeleton == null) return;\r\n        if (loop != null) anim.loop = loop;\r\n        if (!this._isAG) {\r\n            if (rangeName != null) anim.name = <string>rangeName;\r\n            if (rate != null) anim.rate = rate;\r\n            if (this._skeleton.getAnimationRange(anim.name) != null) {\r\n                anim.exist = true;\r\n            } else {\r\n                anim.exist = false;\r\n            }\r\n        } else {\r\n            if (rangeName != null) {\r\n                anim.ag = <AnimationGroup>rangeName;\r\n                anim.exist = true;\r\n            }\r\n            if (rate != null && anim.exist) {\r\n                anim.rate = rate;\r\n                anim.ag.speedRatio = rate;\r\n            }\r\n        }\r\n    }\r\n\r\n    public enableBlending(n: number) {\r\n        if (this._isAG) {\r\n            for (let anim of this._anims) {\r\n                if (anim.exist) {\r\n                    let ar: AnimationGroup = anim.ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = true;\r\n                        ta.animation.blendingSpeed = n;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            this._skeleton.enableBlending(n);\r\n        }\r\n    }\r\n\r\n    public disableBlending() {\r\n        if (this._isAG) {\r\n            for (let anim of this._anims) {\r\n                if (anim.exist) {\r\n                    let ar: AnimationGroup = anim.ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //setters for animations\r\n    public setWalkAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._walk, rangeName, rate, loop);\r\n    }\r\n    public setRunAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._run, rangeName, rate, loop);\r\n    }\r\n    public setWalkBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._walkBack, rangeName, rate, loop);\r\n    }\r\n    public setSlideBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._slideBack, rangeName, rate, loop);\r\n    }\r\n    public setIdleAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._idle, rangeName, rate, loop);\r\n    }\r\n    public setTurnRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._turnRight, rangeName, rate, loop);\r\n    }\r\n    public setTurnLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._turnLeft, rangeName, rate, loop);\r\n    }\r\n    public setStrafeRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._strafeRight, rangeName, rate, loop);\r\n    }\r\n    public setStrafeLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._strafeLeft, rangeName, rate, loop);\r\n    }\r\n    public setIdleJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._idleJump, rangeName, rate, loop);\r\n    }\r\n    public setRunJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._runJump, rangeName, rate, loop);\r\n    }\r\n    public setFallAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this.setAnim(this._fall, rangeName, rate, loop);\r\n    }\r\n\r\n    // setters for keys\r\n    public setWalkKey(key: string) {\r\n        this._walkKey = key.toLowerCase();\r\n    }\r\n    public setWalkBackKey(key: string) {\r\n        this._walkBackKey = key.toLowerCase();\r\n    }\r\n    public setTurnLeftKey(key: string) {\r\n        this._turnLeftKey = key.toLowerCase();\r\n    }\r\n    public setTurnRightKey(key: string) {\r\n        this._turnRightKey = key.toLowerCase();\r\n    }\r\n    public setStrafeLeftKey(key: string) {\r\n        this._strafeLeftKey = key.toLowerCase();\r\n    }\r\n    public setStrafeRightKey(key: string) {\r\n        this._strafeRightKey = key.toLowerCase();\r\n    }\r\n    public setJumpKey(key: string) {\r\n        this._jumpKey = key.toLowerCase();\r\n    }\r\n\r\n    public setCameraElasticity(b: boolean) {\r\n        this._elasticCamera = b;\r\n    }\r\n    public setCameraTarget(v: Vector3) {\r\n        this._cameraTarget.copyFrom(v);\r\n    }\r\n    /**\r\n     * user should call this whenever the user changes the camera checkCollision \r\n     * property\r\n     * \r\n     */\r\n    public cameraCollisionChanged() {\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n    }\r\n    public setNoFirstPerson(b: boolean) {\r\n        this._noFirstPerson = b;\r\n    }\r\n\r\n\r\n    private checkAnims(skel: Skeleton) {\r\n        for (let anim of this._anims) {\r\n            if (skel != null) {\r\n                if (skel.getAnimationRange(anim.name) != null) anim.exist = true;\r\n            } else {\r\n                anim.exist = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use this to make the  character controller suitable for a isometeric/top down games or  fps/third person game.\r\n     * 1 In isometric/top down games the camera direction has no bearing on avatar movement.\r\n     * 0 In fps/third person game rotating the camera around the avatar , rotates the avatr too.\r\n     */\r\n    private mode = 0;\r\n    private _saveMode = 0;\r\n    public setMode(n: number) {\r\n        this.mode = n;\r\n        this._saveMode = n;\r\n    }\r\n\r\n    /**\r\n        * checks if a have left hand , right hand issue.\r\n        * In other words if a mesh is a LHS mesh in RHS system or \r\n        * a RHS mesh in LHS system\r\n        * The X axis will be reversed in such cases.\r\n        * thus Cross product of X and Y should be inverse of Z.\r\n        * BABYLONJS GLB models are RHS and exhibit this behavior\r\n        * \r\n        */\r\n    private _isRHS = false;\r\n    private _signRHS = -1;\r\n    private _setRHS(mesh: TransformNode) {\r\n        const meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        const _localX = Vector3.FromFloatArray(meshMatrix.m, 0);\r\n        const _localY = Vector3.FromFloatArray(meshMatrix.m, 4);\r\n        const _localZ = Vector3.FromFloatArray(meshMatrix.m, 8);\r\n        const actualZ = Vector3.Cross(_localX, _localY);\r\n        //same direction or opposite direction of Z\r\n        if (Vector3.Dot(actualZ, _localZ) < 0) {\r\n            this._isRHS = true;\r\n            this._signRHS = 1;\r\n        }\r\n        else {\r\n            this._isRHS = false;\r\n            this._signRHS = -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use setFaceForward(true|false) to indicate that the avatar face  faces forward (true) or backward (false).\r\n     * The avatar face faces forward if its face points to positive local Z axis direction\r\n     */\r\n    private _ffSign;\r\n    //in mode 0, av2cam is used to align avatar with camera , with camera always facing avatar's back\r\n    //note:camera alpha is measured anti-clockwise , avatar rotation is measured clockwise \r\n    private _av2cam;\r\n    public setFaceForward(b: boolean) {\r\n        if (this._isRHS) {\r\n            this._av2cam = b ? Math.PI / 2 : 3 * Math.PI / 2;\r\n            this._ffSign = b ? 1 : -1;\r\n        } else {\r\n            this._av2cam = b ? 3 * Math.PI / 2 : Math.PI / 2;\r\n            this._ffSign = b ? -1 : 1;\r\n        }\r\n    }\r\n\r\n    private checkAGs(agMap: {}) {\r\n        for (let anim of this._anims) {\r\n            if (agMap[anim.name] != null) {\r\n                anim.ag = agMap[anim.name];\r\n                anim.exist = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _started: boolean = false;\r\n    public start() {\r\n        if (this._started) return;\r\n        this._started = true;\r\n        this._act.reset();\r\n        this._movFallTime = 0;\r\n        //first time we enter render loop, delta time is zero\r\n        this._idleFallTime = 0.001;\r\n        this._grounded = false;\r\n        this._updateTargetValue();\r\n        this.enableKeyBoard();\r\n        this._scene.registerBeforeRender(this._renderer);\r\n    }\r\n\r\n    public stop() {\r\n        if (!this._started) return;\r\n        this._started = false;\r\n        this._scene.unregisterBeforeRender(this._renderer);\r\n        this.disableKeyBoard();\r\n        this._prevAnim = null;\r\n    }\r\n\r\n    /**\r\n     * use pauseAnim to stop the charactere controller from playing\r\n     * any animation on the character\r\n     * use this when you want to play your animation instead\r\n     * see also resumeAnim()\r\n     */\r\n    private _stopAnim: boolean = false;\r\n    public pauseAnim() {\r\n        this._stopAnim = true;\r\n    }\r\n\r\n    /**\r\n     * use resumeAnim to resume the character controller playing\r\n     * animations on the character.\r\n     * see also pauseAnim()\r\n     */\r\n    public resumeAnim() {\r\n        this._stopAnim = false;\r\n    }\r\n\r\n    private _prevAnim: AnimData = null;\r\n    private _avStartPos: Vector3 = Vector3.Zero();\r\n    private _grounded: boolean = false;\r\n    //distance by which AV would move down if in freefall\r\n    private _freeFallDist: number = 0;\r\n\r\n    //how many minimum contiguos frames should the AV have been in free fall\r\n    //before we assume AV is in big freefall.\r\n    //we will use this to remove animation flicker during move down a slope (fall, move, fall move etc)\r\n    //TODO: base this on slope - large slope large count\r\n    private _fallFrameCountMin: number = 50;\r\n    private _fallFrameCount: number = 0;\r\n\r\n    private _inFreeFall: boolean = false;\r\n    private _wasWalking: boolean = false;\r\n    private _wasRunning: boolean = false;\r\n    private _moveVector: Vector3;\r\n\r\n    //used only in mode 1\r\n    //value 1 or -1 , -1 if avatar is facing camera\r\n    //private _notFacingCamera = 1;\r\n\r\n    private _isAvFacingCamera(): number {\r\n        if (Vector3.Dot(this._avatar.forward, this._avatar.position.subtract(this._camera.position)) < 0) return 1\r\n        else return -1;\r\n    }\r\n\r\n    private _moveAVandCamera() {\r\n        this._avStartPos.copyFrom(this._avatar.position);\r\n        let anim: AnimData = null;\r\n        const dt: number = this._scene.getEngine().getDeltaTime() / 1000;\r\n\r\n        if (this._act._jump && !this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            anim = this._doJump(dt);\r\n        } else if (this.anyMovement() || this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            anim = this._doMove(dt);\r\n        } else if (!this._inFreeFall) {\r\n            anim = this._doIdle(dt);\r\n        }\r\n        if (!this._stopAnim && this._hasAnims && anim != null) {\r\n            if (this._prevAnim !== anim) {\r\n                if (anim.exist) {\r\n                    if (this._isAG) {\r\n                        if (this._prevAnim != null && this._prevAnim.exist) this._prevAnim.ag.stop();\r\n                        anim.ag.play(anim.loop);\r\n                    } else {\r\n                        this._skeleton.beginAnimation(anim.name, anim.loop, anim.rate);\r\n                    }\r\n                }\r\n                this._prevAnim = anim;\r\n            }\r\n        }\r\n        this._updateTargetValue();\r\n        return;\r\n    }\r\n\r\n    //verical position of AV when it is about to start a jump\r\n    private _jumpStartPosY: number = 0;\r\n    //for how long the AV has been in the jump\r\n    private _jumpTime: number = 0;\r\n    private _doJump(dt: number): AnimData {\r\n\r\n        let anim: AnimData = null;\r\n        anim = this._runJump;\r\n        if (this._jumpTime === 0) {\r\n            this._jumpStartPosY = this._avatar.position.y;\r\n        }\r\n        //up velocity at the begining of the lastt frame (v=u+at)\r\n        const js: number = this._jumpSpeed - this._gravity * this._jumpTime;\r\n        //distance travelled up since last frame to this frame (s=ut+1/2*at^2)\r\n        const jumpDist: number = js * dt - 0.5 * this._gravity * dt * dt;\r\n        this._jumpTime = this._jumpTime + dt;\r\n\r\n        let forwardDist: number = 0;\r\n        let disp: Vector3;\r\n        if (this.mode != 1) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        if (this._wasRunning || this._wasWalking) {\r\n            if (this._wasRunning) {\r\n                forwardDist = this._runSpeed * dt;\r\n            } else if (this._wasWalking) {\r\n                forwardDist = this._walkSpeed * dt;\r\n            }\r\n            //find out in which horizontal direction the AV was moving when it started the jump\r\n            disp = this._moveVector.clone();\r\n            disp.y = 0;\r\n            disp = disp.normalize();\r\n            disp.scaleToRef(forwardDist, disp);\r\n            disp.y = jumpDist;\r\n        } else {\r\n            disp = new Vector3(0, jumpDist, 0);\r\n            anim = this._idleJump;\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y/2;\r\n        }\r\n        //moveWithCollision only seems to happen if length of displacment is atleast 0.001\r\n        this._avatar.moveWithCollisions(disp);\r\n        if (jumpDist < 0) {\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y;\r\n            //check if going up a slope or back on flat ground \r\n            if ((this._avatar.position.y > this._avStartPos.y) || ((this._avatar.position.y === this._avStartPos.y) && (disp.length() > 0.001))) {\r\n                this._endJump();\r\n            } else if (this._avatar.position.y < this._jumpStartPosY) {\r\n                //the avatar is below the point from where it started the jump\r\n                //so it is either in free fall or is sliding along a downward slope\r\n                //\r\n                //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n                //else it is on a slope\r\n                const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                    //AV is on slope\r\n                    //Should AV continue to slide or stop?\r\n                    //if slope is less steeper than acceptable then stop else slide\r\n                    if (this._verticalSlope(actDisp) <= this._sl) {\r\n                        this._endJump();\r\n                    }\r\n                } else {\r\n                    anim = this._fall;\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    /**\r\n     * does cleanup at the end of a jump\r\n     */\r\n    private _endJump() {\r\n        this._act._jump = false;\r\n        this._jumpTime = 0;\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n    }\r\n\r\n    /**\r\n     * checks if two vectors v1 and v2 are equal within a precision of p\r\n     */\r\n    private _areVectorsEqual(v1: Vector3, v2: Vector3, p: number) {\r\n        return ((Math.abs(v1.x - v2.x) < p) && (Math.abs(v1.y - v2.y) < p) && (Math.abs(v1.z - v2.z) < p));\r\n    }\r\n\r\n    /*\r\n     * returns the slope (in radians) of a vector in the vertical plane\r\n     */\r\n    private _verticalSlope(v: Vector3): number {\r\n        return Math.atan(Math.abs(v.y / Math.sqrt(v.x * v.x + v.z * v.z)));\r\n    }\r\n\r\n    //for how long has the av been falling while moving\r\n    private _movFallTime: number = 0;\r\n    private _sign = 1;\r\n\r\n    private _doMove(dt: number): AnimData {\r\n\r\n        //initial down velocity\r\n        const u: number = this._movFallTime * this._gravity\r\n        //calculate the distance by which av should fall down since last frame\r\n        //assuming it is in freefall\r\n        this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n\r\n        this._movFallTime = this._movFallTime + dt;\r\n\r\n        let moving: boolean = false;\r\n        let anim: AnimData = null;\r\n\r\n        if (this._inFreeFall) {\r\n            this._moveVector.y = -this._freeFallDist;\r\n            moving = true;\r\n        } else {\r\n            this._wasWalking = false;\r\n            this._wasRunning = false;\r\n\r\n            if (this.mode != 1) {\r\n                this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n            }\r\n            if (this._act._forward) {\r\n                let forwardDist: number = 0;\r\n                if (this._act._shift) {\r\n                    this._wasRunning = true;\r\n                    forwardDist = this._runSpeed * dt;\r\n                    anim = this._run;\r\n                } else {\r\n                    this._wasWalking = true;\r\n                    forwardDist = this._walkSpeed * dt;\r\n                    anim = this._walk;\r\n                }\r\n                this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, this._ffSign * forwardDist);\r\n                moving = true;\r\n            } else if (this._act._backward) {\r\n                this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, -this._ffSign * (this._backSpeed * dt));\r\n                anim = this._walkBack;\r\n                moving = true;\r\n            } else if (this._act._stepLeft) {\r\n                let sign = this._signRHS * this._isAvFacingCamera();\r\n                this._moveVector = this._avatar.calcMovePOV(sign * (this._leftSpeed * dt), -this._freeFallDist, 0);\r\n                anim = (sign > 0) ? this._strafeLeft : this._strafeRight;\r\n                moving = true;\r\n            } else if (this._act._stepRight) {\r\n                let sign = -this._signRHS * this._isAvFacingCamera();\r\n                this._moveVector = this._avatar.calcMovePOV(sign * (this._rightSpeed * dt), -this._freeFallDist, 0);\r\n                anim = (sign > 0) ? this._strafeLeft : this._strafeRight;\r\n                moving = true;\r\n            }\r\n        }\r\n\r\n        if ((!this._act._stepLeft && !this._act._stepRight) && (this._act._turnLeft || this._act._turnRight)) {\r\n\r\n            if (this.mode == 1) {\r\n                // while turining, the avatar could start facing away from camera and end up facing camera.\r\n                // we should not switch turning direction during this transition\r\n                if (this._act.name != this._act.prevName) {\r\n                    this._act.prevName = this._act.name;\r\n                    this._sign = -this._ffSign * this._isAvFacingCamera();\r\n                    if (this._isRHS) this._sign = - this._sign;\r\n                }\r\n                let a = this._sign;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._forward) { }\r\n                    else if (this._act._backward) a = -this._sign;\r\n                    else {\r\n                        anim = (this._sign > 0) ? this._turnRight : this._turnLeft;\r\n                    }\r\n                } else {\r\n                    if (this._act._forward) a = -this._sign;\r\n                    else if (this._act._backward) { }\r\n                    else {\r\n                        a = -this._sign;\r\n                        anim = (this._sign > 0) ? this._turnLeft : this._turnRight;\r\n                    }\r\n                }\r\n                this._avatar.rotation.y = this._avatar.rotation.y + this._turnSpeed * dt * a;\r\n            } else {\r\n                let a = 1;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._backward) a = -1;\r\n                    if (!moving) anim = this._turnLeft;\r\n                } else {\r\n                    if (this._act._forward) a = -1;\r\n                    if (!moving) { a = -1; anim = this._turnRight; }\r\n                }\r\n                this._camera.alpha = this._camera.alpha + a * this._turnSpeed * dt;\r\n                this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n            }\r\n        }\r\n\r\n        if (moving) {\r\n            if (this._moveVector.length() > 0.001) {\r\n                this._avatar.moveWithCollisions(this._moveVector);\r\n                //walking up a slope\r\n                if (this._avatar.position.y > this._avStartPos.y) {\r\n                    const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                    const _sl: number = this._verticalSlope(actDisp);\r\n                    if (_sl >= this._sl2) {\r\n                        //this._climbingSteps=true;\r\n                        //is av trying to go up steps\r\n                        if (this._stepOffset > 0) {\r\n                            if (this._vMoveTot == 0) {\r\n                                //if just started climbing note down the position\r\n                                this._vMovStartPos.copyFrom(this._avStartPos);\r\n                            }\r\n                            this._vMoveTot = this._vMoveTot + (this._avatar.position.y - this._avStartPos.y);\r\n                            if (this._vMoveTot > this._stepOffset) {\r\n                                //move av back to its position at begining of steps\r\n                                this._vMoveTot = 0;\r\n                                this._avatar.position.copyFrom(this._vMovStartPos);\r\n                                this._endFreeFall();\r\n                            }\r\n                        } else {\r\n                            //move av back to old position\r\n                            this._avatar.position.copyFrom(this._avStartPos);\r\n                            this._endFreeFall();\r\n                        }\r\n                    } else {\r\n                        this._vMoveTot = 0;\r\n                        if (_sl > this._sl) {\r\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                            this._fallFrameCount = 0;\r\n                            this._inFreeFall = false;\r\n                        } else {\r\n                            //continue walking\r\n                            this._endFreeFall();\r\n                        }\r\n                    }\r\n                } else if ((this._avatar.position.y) < this._avStartPos.y) {\r\n                    const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                    if (!(this._areVectorsEqual(actDisp, this._moveVector, 0.001))) {\r\n                        //AV is on slope\r\n                        //Should AV continue to slide or walk?\r\n                        //if slope is less steeper than acceptable then walk else slide\r\n                        if (this._verticalSlope(actDisp) <= this._sl) {\r\n                            this._endFreeFall();\r\n                        } else {\r\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                            this._fallFrameCount = 0;\r\n                            this._inFreeFall = false;\r\n                        }\r\n                    } else {\r\n                        this._inFreeFall = true;\r\n                        this._fallFrameCount++;\r\n                        //AV could be running down a slope which mean freefall,run,frefall run ...\r\n                        //to remove anim flicker, check if AV has been falling down continously for last few consecutive frames\r\n                        //before changing to free fall animation\r\n                        if (this._fallFrameCount > this._fallFrameCountMin) {\r\n                            anim = this._fall;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this._endFreeFall();\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _endFreeFall(): void {\r\n        this._movFallTime = 0;\r\n        this._fallFrameCount = 0;\r\n        this._inFreeFall = false;\r\n    }\r\n\r\n    //for how long has the av been falling while idle (not moving)\r\n    private _idleFallTime: number = 0;\r\n    private _doIdle(dt: number): AnimData {\r\n        if (this._grounded) {\r\n            return this._idle;\r\n        }\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n        this._movFallTime = 0;\r\n        let anim: AnimData = this._idle;\r\n        this._fallFrameCount = 0;\r\n\r\n\r\n        if (dt === 0) {\r\n            this._freeFallDist = 5;\r\n        } else {\r\n            const u: number = this._idleFallTime * this._gravity\r\n            this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n            this._idleFallTime = this._idleFallTime + dt;\r\n        }\r\n        //if displacement is less than 0.01(? need to verify further) then \r\n        //moveWithDisplacement down against a surface seems to push the AV up by a small amount!!\r\n        if (this._freeFallDist < 0.01) return anim;\r\n        const disp: Vector3 = new Vector3(0, -this._freeFallDist, 0);\r\n        if (this.mode != 1) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        this._avatar.moveWithCollisions(disp);\r\n        if ((this._avatar.position.y > this._avStartPos.y) || (this._avatar.position.y === this._avStartPos.y)) {\r\n            //                this.grounded = true;\r\n            //                this.idleFallTime = 0;\r\n            this._groundIt();\r\n        } else if (this._avatar.position.y < this._avStartPos.y) {\r\n            //AV is going down. \r\n            //AV is either in free fall or is sliding along a downward slope\r\n            //\r\n            //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n            //else it is on a slope\r\n            const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n            if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                //AV is on slope\r\n                //Should AV continue to slide or stop?\r\n                //if slope is less steeper than accebtable then stop else slide\r\n                if (this._verticalSlope(actDisp) <= this._sl) {\r\n                    //                        this.grounded = true;\r\n                    //                        this.idleFallTime = 0;\r\n                    this._groundIt();\r\n                    this._avatar.position.copyFrom(this._avStartPos);\r\n                } else {\r\n                    this._unGroundIt();\r\n                    anim = this._slideBack;\r\n                }\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _groundFrameCount = 0;\r\n    private _groundFrameMax = 10;\r\n    /**\r\n     * donot ground immediately\r\n     * wait few more frames\r\n     */\r\n    private _groundIt(): void {\r\n        this._groundFrameCount++;\r\n        if (this._groundFrameCount > this._groundFrameMax) {\r\n            this._grounded = true;\r\n            this._idleFallTime = 0;\r\n        }\r\n    }\r\n    private _unGroundIt() {\r\n        this._grounded = false;\r\n        this._groundFrameCount = 0;\r\n    }\r\n\r\n    private _savedCameraCollision: boolean = true;\r\n    private _inFP = false;\r\n    private _updateTargetValue() {\r\n        //donot move camera if av is trying to clinb steps\r\n        if (this._vMoveTot == 0)\r\n            this._avatar.position.addToRef(this._cameraTarget, this._camera.target);\r\n\r\n        if (this._camera.radius > this._camera.lowerRadiusLimit) { if (this._elasticCamera) this._snapCamera(); }\r\n\r\n        if (this._camera.radius <= this._camera.lowerRadiusLimit) {\r\n            if (!this._noFirstPerson && !this._inFP) {\r\n                this._avatar.visibility = 0;\r\n                this._camera.checkCollisions = false;\r\n                this._saveMode = this.mode;\r\n                this.mode = 0;\r\n                this._inFP = true;\r\n            }\r\n        } else {\r\n            this._inFP = false;\r\n            this.mode = this._saveMode;\r\n            this._avatar.visibility = 1;\r\n            this._camera.checkCollisions = this._savedCameraCollision;\r\n        }\r\n    }\r\n\r\n    private _ray: Ray = new Ray(Vector3.Zero(), Vector3.One(), 1);\r\n    private _rayDir: Vector3 = Vector3.Zero();\r\n    //camera seems to get stuck into things\r\n    //should move camera away from things by a value of cameraSkin\r\n    private _cameraSkin: number = 0.5;\r\n    private _skip: number = 0;\r\n    private _snapCamera() {\r\n        //            if(this.skip<120) {\r\n        //                this.skip++;\r\n        //                return;\r\n        //            }\r\n        //            this.skip=0;\r\n        //get vector from av (camera.target) to camera\r\n        this._camera.position.subtractToRef(this._camera.target, this._rayDir);\r\n        //start ray from av to camera\r\n        this._ray.origin = this._camera.target;\r\n        this._ray.length = this._rayDir.length();\r\n        this._ray.direction = this._rayDir.normalize();\r\n\r\n        const pi: PickingInfo = this._scene.pickWithRay(this._ray, (mesh) => {\r\n            //if(mesh==this.avatar||!mesh.isPickable||!mesh.checkCollisions) return false;\r\n            if (mesh == this._avatar || !mesh.checkCollisions) return false;\r\n            else return true;\r\n        }, true);\r\n\r\n        if (pi.hit) {\r\n            //postion the camera in front of the mesh that is obstructing camera\r\n            if (this._camera.checkCollisions) {\r\n                const newPos: Vector3 = this._camera.target.subtract(pi.pickedPoint).normalize().scale(this._cameraSkin);\r\n                pi.pickedPoint.addToRef(newPos, this._camera.position);\r\n            } else {\r\n                const nr: number = pi.pickedPoint.subtract(this._camera.target).length();\r\n                this._camera.radius = nr - this._cameraSkin;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _move: boolean = false;\r\n    public anyMovement(): boolean {\r\n        return (this._act._forward || this._act._backward || this._act._turnLeft || this._act._turnRight || this._act._stepLeft || this._act._stepRight);\r\n    }\r\n\r\n    private _onKeyDown(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        if (e.repeat) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case this._jumpKey:\r\n                this._act._jump = true;\r\n                break;\r\n            case \"capslock\":\r\n                if (this._act._shift === false) {\r\n                    this._act._shift = true;\r\n                } else {\r\n                    this._act._shift = false;\r\n                }\r\n                break;\r\n            case \"shift\":\r\n                this._act._shift = true;\r\n                break;\r\n            case \"arrowup\":\r\n            case this._walkKey:\r\n                this._act._forward = true;\r\n                break;\r\n            case \"arrowleft\":\r\n            case this._turnLeftKey:\r\n                this._act._turnLeft = true;\r\n                this._act.name = \"tl\";\r\n                break;\r\n            case \"arrowright\":\r\n            case this._turnRightKey:\r\n                this._act._turnRight = true;\r\n                this._act.name = \"tr\";\r\n                break;\r\n            case \"arrowdown\":\r\n            case this._walkBackKey:\r\n                this._act._backward = true;\r\n                break;\r\n            case this._strafeLeftKey:\r\n                this._act._stepLeft = true;\r\n                break;\r\n            case this._strafeRightKey:\r\n                this._act._stepRight = true;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    private _onKeyUp(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        //if (e.repeat) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case \"shift\":\r\n                this._act._shift = false;\r\n                break;\r\n            case \"arrowup\":\r\n            case this._walkKey:\r\n                this._act._forward = false;\r\n                break;\r\n            case \"arrowleft\":\r\n            case this._turnLeftKey:\r\n                this._act._turnLeft = false;\r\n                this._act.name = \"\";\r\n                this._act.prevName = \"\";\r\n                break;\r\n            case \"arrowright\":\r\n            case this._turnRightKey:\r\n                this._act._turnRight = false;\r\n                this._act.name = \"\";\r\n                this._act.prevName = \"\";\r\n                break;\r\n            case \"arrowdown\":\r\n            case this._walkBackKey:\r\n                this._act._backward = false;\r\n                break;\r\n            case this._strafeLeftKey:\r\n                this._act._stepLeft = false;\r\n                break;\r\n            case this._strafeRightKey:\r\n                this._act._stepRight = false;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    // control movement by commands rather than keyboard.\r\n    public disableKeyBoard() {\r\n        window.removeEventListener(\"keyup\", this._handleKeyUp, false);\r\n        window.removeEventListener(\"keydown\", this._handleKeyDown, false);\r\n    }\r\n\r\n    public enableKeyBoard() {\r\n        window.addEventListener(\"keyup\", this._handleKeyUp, false);\r\n        window.addEventListener(\"keydown\", this._handleKeyDown, false);\r\n    }\r\n\r\n    public walk(b: boolean) {\r\n        this._act._forward = b;\r\n    }\r\n    public walkBack(b: boolean) {\r\n        this._act._backward = b;\r\n    }\r\n    public run(b: boolean) {\r\n        this._act._forward = b;\r\n        this._act._shift = b;\r\n    }\r\n    public turnLeft(b: boolean) {\r\n        this._act._turnLeft = b;\r\n        if (b) this._act.name = \"tl\"\r\n        else {\r\n            this._act.name = \"\";\r\n            this._act.prevName = \"\";\r\n        }\r\n    }\r\n    public turnRight(b: boolean) {\r\n        this._act._turnRight = b;\r\n        if (b) this._act.name = \"tr\"\r\n        else {\r\n            this._act.name = \"\";\r\n            this._act.prevName = \"\";\r\n        }\r\n    }\r\n    public strafeLeft(b: boolean) {\r\n        this._act._stepLeft = b;\r\n    }\r\n    public strafeRight(b: boolean) {\r\n        this._act._stepRight = b;\r\n    }\r\n    public jump() {\r\n        this._act._jump = true;\r\n    }\r\n    public idle() {\r\n        this._act.reset();\r\n    }\r\n\r\n    private _act: Action;\r\n    private _renderer: () => void;\r\n    private _handleKeyUp: (e) => void;\r\n    private _handleKeyDown: (e) => void;\r\n    private _isAG: boolean = false;\r\n    private _hasAnims: boolean = false;\r\n    /**\r\n     * \r\n     * @param avatar \r\n     * @param camera \r\n     * @param scene \r\n     * @param agMap map of animationRange name to animationRange\r\n\t * @param faceForward \r\n     */\r\n    constructor(avatar: Mesh, camera: ArcRotateCamera, scene: Scene, agMap?: {}, faceForward = false) {\r\n\r\n        this._avatar = avatar;\r\n\r\n        this._setRHS(avatar);\r\n        this.setFaceForward(faceForward);\r\n\r\n        this._scene = scene;\r\n\r\n        if (agMap != null) {\r\n            this._isAG = true;\r\n            this.setAnimationGroups(agMap);\r\n        }\r\n\r\n        if (this._isAG || this._skeleton !== null) {\r\n            this._hasAnims = true;\r\n        }\r\n\r\n        if (!this._isAG) this._skeleton = avatar.skeleton;\r\n\r\n        if (!this._isAG && this._skeleton != null) this.checkAnims(this._skeleton);\r\n        this._camera = camera;\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n\r\n        this._act = new Action();\r\n\r\n        this._renderer = () => { this._moveAVandCamera() };\r\n        this._handleKeyUp = (e) => { this._onKeyUp(e) };\r\n        this._handleKeyDown = (e) => { this._onKeyDown(e) };\r\n    }\r\n}\r\n\r\nclass AnimData {\r\n    public name: string;\r\n    public loop: boolean = true;\r\n    public rate: number = 1;\r\n    public ag: AnimationGroup;\r\n    public exist: boolean = false;\r\n\r\n    public constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nclass Action {\r\n    public _forward: boolean;\r\n    public _backward: boolean;\r\n    public _turnRight: boolean;\r\n    public _turnLeft: boolean;\r\n    public _stepRight: boolean;\r\n    public _stepLeft: boolean;\r\n    public _jump: boolean;\r\n    public _shift: boolean;\r\n\r\n    public name: string;\r\n    public prevName: string = \"\";\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    reset() {\r\n        this._forward = false;\r\n        this._backward = false;\r\n        this._turnRight = false;\r\n        this._turnLeft = false;\r\n        this._stepRight = false;\r\n        this._stepLeft = false;\r\n        this._jump = false;\r\n        this._shift = false;\r\n    }\r\n}\r\n"],"sourceRoot":""}