{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///external {\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\",\"root\":\"BABYLON\"}","webpack:///./src/CharacterController.ts"],"names":["root","factory","exports","module","require","define","amd","a","i","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","CharacterController","AnimData","Key","babylonjs__WEBPACK_IMPORTED_MODULE_0__","avatar","camera","scene","_this","this","walkSpeed","runSpeed","backSpeed","jumpSpeed","leftSpeed","rightSpeed","gravity","minSlopeLimit","maxSlopeLimit","sl","Math","PI","sl2","_stepOffset","_vMoveTot","_vMovStartPos","walk","walkBack","idle","idleJump","run","runJump","fall","turnLeft","turnRight","strafeLeft","strafeRight","slideBack","anims","walkKey","walkBackKey","turnLeftKey","turnRightKey","strafeLeftKey","strafeRightKey","jumpKey","walkCode","walkBackCode","turnLeftCode","turnRightCode","strafeLeftCode","strafeRightCode","jumpCode","elasticCamera","cameraTarget","noFirstPerson","started","_stopAnim","prevAnim","avStartPos","grounded","freeFallDist","fallFrameCountMin","fallFrameCount","inFreeFall","wasWalking","wasRunning","jumpStartPosY","jumpTime","movFallTime","idleFallTime","groundFrameCount","groundFrameMax","savedCameraCollision","ray","Zero","One","rayDir","cameraSkin","skip","move","_ellipsoid","ellipsoid","clone","skeleton","checkAnims","checkCollisions","addEventListener","e","onKeyDown","onKeyUp","renderer","moveAVandCamera","setAvatar","setAvatarSkeleton","setSlopeLimit","setStepOffset","stepOffset","setWalkSpeed","setRunSpeed","setBackSpeed","setJumpSpeed","setLeftSpeed","setRightSpeed","setGravity","setAnim","anim","rangeName","rate","loop","getAnimationRange","exist","setWalkAnim","setRunAnim","setWalkBackAnim","setSlideBackAnim","setIdleAnim","setTurnRightAnim","setTurnLeftAnim","setStrafeRightAnim","setSrafeLeftAnim","setIdleJumpAnim","setRunJumpAnim","setFallAnim","setWalkKey","setWalkBackKey","setTurnLeftKey","setTurnRightKey","setStrafeLeftKey","setStrafeRightKey","setJumpKey","setWalkCode","code","setWalkBackCode","setTurnLeftCode","setTurnRightCode","setStrafeLeftCode","setStrafeRightCode","setJumpCode","setCameraElasticity","b","setCameraTarget","v","copyFrom","cameraCollisionChanged","setNoFirstPerson","skel","_i","_a","length","start","reset","updateTargetValue","registerBeforeRender","stop","unregisterBeforeRender","pauseAnim","resumeAnim","position","dt","getEngine","getDeltaTime","jump","doJump","anyMovement","doMove","doIdle","beginAnimation","y","jumpDist","disp","forwardDist","rotation","alpha","moveVector","normalize","scaleToRef","moveWithCollisions","endJump","actDisp","subtract","areVectorsEqual","verticalSlope","v1","v2","abs","x","z","atan","sqrt","u","moving","forward","shift","calcMovePOV","backward","stepLeft","stepRight","_sl","endFreeFall","groundIt","unGroundIt","addToRef","target","radius","lowerRadiusLimit","snapCamera","visibility","subtractToRef","origin","direction","pi","pickWithRay","mesh","hit","newPos","pickedPoint","scale","nr","keyCode","chr","String","fromCharCode"],"mappings":"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","file":"CharacterController.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"babylonjs\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"babylonjs\")) : factory(root[\"BABYLON\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import {\n    Skeleton,\n    ArcRotateCamera,\n    Vector3,\n    Mesh,\n    Scene,\n    Ray,\n    PickingInfo\n} from \"babylonjs\"\n\nexport class CharacterController {\n\n    private avatar: Mesh;\n    private skeleton: Skeleton;\n    private camera: ArcRotateCamera;\n    private scene: Scene;\n\n    //avatar speed in meters/second\n    private walkSpeed: number=3;\n    private runSpeed: number=this.walkSpeed*2;\n    private backSpeed: number=this.walkSpeed/2;\n    private jumpSpeed: number=this.walkSpeed*2;\n    private leftSpeed: number=this.walkSpeed/2;\n    private rightSpeed: number=this.walkSpeed/2;\n    private gravity: number=9.8;\n    //slopeLimit in degrees\n    private minSlopeLimit: number=30;\n    private maxSlopeLimit: number=45;\n    //slopeLimit in radians\n    sl: number=Math.PI*this.minSlopeLimit/180;\n    sl2: number=Math.PI*this.maxSlopeLimit/180;\n\n    //The av will step up a stair only if it is closer to the ground than the indicated value.\n    private _stepOffset: number=0.25;\n    //toal amount by which the av has moved up\n    private _vMoveTot: number=0;\n    //position of av when it started moving up\n    private _vMovStartPos: Vector3=new Vector3(0,0,0);\n\n    //animations\n    private walk: AnimData=new AnimData(\"walk\");\n    private walkBack: AnimData=new AnimData(\"walkBack\");\n    private idle: AnimData=new AnimData(\"idle\");\n    private idleJump: AnimData=new AnimData(\"idleJump\");\n    private run: AnimData=new AnimData(\"run\");\n    private runJump: AnimData=new AnimData(\"runJump\");\n    private fall: AnimData=new AnimData(\"fall\");\n    private turnLeft: AnimData=new AnimData(\"turnLeft\");\n    private turnRight: AnimData=new AnimData(\"turnRight\");\n    private strafeLeft: AnimData=new AnimData(\"strafeLeft\");\n    private strafeRight: AnimData=new AnimData(\"strafeRight\");\n    private slideBack: AnimData=new AnimData(\"slideBack\");\n\n    private anims: AnimData[]=[this.walk,this.walkBack,this.idle,this.run,this.runJump,this.fall,this.turnLeft,this.turnRight,this.strafeLeft,this.strafeRight,this.slideBack];\n\n    //move keys\n    private walkKey: string=\"W\";\n    private walkBackKey: string=\"S\";\n    private turnLeftKey: string=\"A\";\n    private turnRightKey: string=\"D\";\n    private strafeLeftKey: string=\"Q\";\n    private strafeRightKey: string=\"E\";\n    private jumpKey: string=\"32\";\n    private walkCode: number=38;\n    private walkBackCode: number=40;\n    private turnLeftCode: number=37;\n    private turnRightCode: number=39;\n    private strafeLeftCode: number=0;\n    private strafeRightCode: number=0;\n    private jumpCode: number=32;\n\n    private elasticCamera: boolean=true;\n    private cameraTarget: Vector3=new Vector3(0,0,0);\n    //should we go into first person view when camera is near avatar (radius is lowerradius limit)\n    private noFirstPerson: boolean=false;\n\n    public setAvatar(avatar: Mesh) {\n        this.avatar=avatar;\n    }\n\n    public setAvatarSkeleton(skeleton: Skeleton) {\n        this.skeleton=skeleton;\n        this.checkAnims(skeleton);\n    }\n\n    public setSlopeLimit(minSlopeLimit: number,maxSlopeLimit: number) {\n        this.minSlopeLimit=minSlopeLimit;\n        this.maxSlopeLimit=maxSlopeLimit;\n\n        this.sl=Math.PI*minSlopeLimit/180;\n        this.sl2=Math.PI*this.maxSlopeLimit/180;\n    }\n\n    /**\n     * The av will step up a stair only if it is closer to the ground than the indicated value.\n     * Default value is 0.25 m\n     */\n    public setStepOffset(stepOffset: number) {\n        this._stepOffset=stepOffset;\n    }\n\n    public setWalkSpeed(n: number) {\n        this.walkSpeed=n;\n    }\n    public setRunSpeed(n: number) {\n        this.runSpeed=n;\n    }\n    public setBackSpeed(n: number) {\n        this.backSpeed=n;\n    }\n    public setJumpSpeed(n: number) {\n        this.jumpSpeed=n;\n    }\n    public setLeftSpeed(n: number) {\n        this.leftSpeed=n;\n    }\n    public setRightSpeed(n: number) {\n        this.rightSpeed=n;\n    }\n    public setGravity(n: number) {\n        this.gravity=n;\n    }\n\n    public setAnim(anim: AnimData,rangeName: string,rate: number,loop: boolean) {\n        if(this.skeleton==null) return;\n        anim.name=rangeName;\n        anim.rate=rate;\n        anim.loop=loop;\n        if(this.skeleton.getAnimationRange(anim.name)!=null) {\n            anim.exist=true;\n        } else {\n            anim.exist=false;\n        }\n    }\n\n    public setWalkAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.walk,rangeName,rate,loop);\n    }\n    public setRunAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.run,rangeName,rate,loop);\n    }\n    public setWalkBackAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.walkBack,rangeName,rate,loop);\n    }\n    public setSlideBackAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.slideBack,rangeName,rate,loop);\n    }\n    public setIdleAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.idle,rangeName,rate,loop);\n    }\n    public setTurnRightAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.turnRight,rangeName,rate,loop);\n    }\n    public setTurnLeftAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.turnLeft,rangeName,rate,loop);\n    }\n    public setStrafeRightAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.strafeRight,rangeName,rate,loop);\n    }\n    public setSrafeLeftAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.strafeLeft,rangeName,rate,loop);\n    }\n    public setIdleJumpAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.idleJump,rangeName,rate,loop);\n    }\n    public setRunJumpAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.runJump,rangeName,rate,loop);\n    }\n    public setFallAnim(rangeName: string,rate: number,loop: boolean) {\n        this.setAnim(this.fall,rangeName,rate,loop);\n    }\n\n    public setWalkKey(key: string) {\n        this.walkKey=key\n    }\n    public setWalkBackKey(key: string) {\n        this.walkBackKey=key\n    }\n    public setTurnLeftKey(key: string) {\n        this.turnLeftKey=key\n    }\n    public setTurnRightKey(key: string) {\n        this.turnRightKey=key\n    }\n    public setStrafeLeftKey(key: string) {\n        this.strafeLeftKey=key\n    }\n    public setStrafeRightKey(key: string) {\n        this.strafeRightKey=key\n    }\n    public setJumpKey(key: string) {\n        this.jumpKey=key\n    }\n\n    public setWalkCode(code: number) {\n        this.walkCode=code\n    }\n    public setWalkBackCode(code: number) {\n        this.walkBackCode=code\n    }\n    public setTurnLeftCode(code: number) {\n        this.turnLeftCode=code\n    }\n    public setTurnRightCode(code: number) {\n        this.turnRightCode=code\n    }\n    public setStrafeLeftCode(code: number) {\n        this.strafeLeftCode=code\n    }\n    public setStrafeRightCode(code: number) {\n        this.strafeRightCode=code\n    }\n    public setJumpCode(code: number) {\n        this.jumpCode=code\n    }\n\n    public setCameraElasticity(b: boolean) {\n        this.elasticCamera=b;\n    }\n    public setCameraTarget(v: Vector3) {\n        this.cameraTarget.copyFrom(v);\n    }\n    /**\n     * user should call this whenever the user changes the camera checkCollision \n     * property\n     * \n     */\n    public cameraCollisionChanged() {\n        this.savedCameraCollision=this.camera.checkCollisions;\n    }\n    public setNoFirstPerson(b: boolean) {\n        this.noFirstPerson=b;\n    }\n\n    private checkAnims(skel: Skeleton) {\n        for(let anim of this.anims) {\n            if(skel.getAnimationRange(anim.name)!=null) anim.exist=true;\n        }\n    }\n\n    private key: Key;\n    private renderer: () => void;\n    private _ellipsoid: Vector3;\n    constructor(avatar: Mesh,camera: ArcRotateCamera,scene: Scene) {\n\n        this.avatar=avatar;\n        this.scene=scene;\n        this._ellipsoid=this.avatar.ellipsoid.clone();\n\n        this.skeleton=avatar.skeleton;\n        if(this.skeleton!=null) this.checkAnims(this.skeleton);\n        this.camera=camera;\n        this.savedCameraCollision=this.camera.checkCollisions;\n\n        this.key=new Key();\n\n        window.addEventListener(\"keydown\",(e) => {return this.onKeyDown(e)},false);\n        window.addEventListener(\"keyup\",(e) => {return this.onKeyUp(e)},false);\n        this.renderer=() => {this.moveAVandCamera()};\n\n    }\n\n    private started: boolean=false;\n    public start() {\n        if(this.started) return;\n        this.started=true;\n        this.key.reset();\n        this.movFallTime=0;\n        //first time we enter render loop, delta time shows zero !!\n        this.idleFallTime=0.001;\n        this.grounded=false;\n        this.updateTargetValue();\n\n        this.scene.registerBeforeRender(this.renderer);\n        this.scene\n    }\n\n    public stop() {\n        if(!this.started) return;\n        this.started=false;\n        this.scene.unregisterBeforeRender(this.renderer);\n\n        this.prevAnim=null;\n    }\n\n    /**\n     * use pauseAnim to stop the charactere controller from playing\n     * any animation on the character\n     * use this when you want to play your animation instead\n     * see also resumeAnim()\n     */\n    private _stopAnim: boolean=false;\n    public pauseAnim() {\n        this._stopAnim=true;\n    }\n\n    /**\n     * use resumeAnim to resume the character controller playing\n     * animations on the character.\n     * see also pauseAnim()\n     */\n    public resumeAnim() {\n        this._stopAnim=false;\n    }\n\n    private prevAnim: AnimData=null;\n\n    private avStartPos: Vector3=new Vector3(0,0,0);\n    private grounded: boolean=false;\n    //distance by which AV would move down if in freefall\n    private freeFallDist: number=0;\n\n    //how many minimum contiguos frames should the AV have been in free fall\n    //before we assume AV is in big freefall.\n    //we will use this to remove animation flicker during move down a slope (fall, move, fall move etc)\n    //TODO: base this on slope - large slope large count\n    private fallFrameCountMin: number=50;\n    private fallFrameCount: number=0;\n\n    private inFreeFall: boolean=false;\n    private wasWalking: boolean=false;\n    private wasRunning: boolean=false;\n    private moveVector: Vector3;\n\n    private moveAVandCamera() {\n        this.avStartPos.copyFrom(this.avatar.position);\n        let anim: AnimData=null;\n        let dt: number=this.scene.getEngine().getDeltaTime()/1000;\n\n        if(this.key.jump&&!this.inFreeFall) {\n            this.grounded=false;\n            this.idleFallTime=0;\n\n            anim=this.doJump(dt);\n        } else if(this.anyMovement()||this.inFreeFall) {\n            this.grounded=false;\n            this.idleFallTime=0;\n\n            anim=this.doMove(dt);\n        } else if(!this.inFreeFall) {\n\n            anim=this.doIdle(dt);\n        }\n        if(!this._stopAnim) {\n            if(anim!=null) {\n                if(this.skeleton!==null) {\n                    if(this.prevAnim!==anim) {\n                        if(anim.exist) {\n                            this.skeleton.beginAnimation(anim.name,anim.loop,anim.rate);\n                        }\n                        this.prevAnim=anim;\n                    }\n                }\n            }\n        }\n        this.updateTargetValue();\n        return;\n    }\n\n    //verical position of AV when it is about to start a jump\n    private jumpStartPosY: number=0;\n    //for how long the AV has been in the jump\n    private jumpTime: number=0;\n    private doJump(dt: number): AnimData {\n\n        let anim: AnimData=null;\n        anim=this.runJump;\n        if(this.jumpTime===0) {\n            this.jumpStartPosY=this.avatar.position.y;\n        }\n        //up velocity at the begining of the lastt frame (v=u+at)\n        let js: number=this.jumpSpeed-this.gravity*this.jumpTime;\n        //distance travelled up since last frame to this frame (s=ut+1/2*at^2)\n        let jumpDist: number=js*dt-0.5*this.gravity*dt*dt;\n        this.jumpTime=this.jumpTime+dt;\n\n        let forwardDist: number=0;\n        let disp: Vector3;\n        this.avatar.rotation.y=-4.69-this.camera.alpha;\n        if(this.wasRunning||this.wasWalking) {\n            if(this.wasRunning) {\n                forwardDist=this.runSpeed*dt;\n            } else if(this.wasWalking) {\n                forwardDist=this.walkSpeed*dt;\n            }\n            //find out in which horizontal direction the AV was moving when it started the jump\n            disp=this.moveVector.clone();\n            disp.y=0;\n            disp=disp.normalize();\n            disp.scaleToRef(forwardDist,disp);\n            disp.y=jumpDist;\n        } else {\n            disp=new Vector3(0,jumpDist,0);\n            anim=this.idleJump;\n            //this.avatar.ellipsoid.y=this._ellipsoid.y/2;\n        }\n        //moveWithCollision only seems to happen if length of displacment is atleast 0.001\n        this.avatar.moveWithCollisions(disp);\n        if(jumpDist<0) {\n            //this.avatar.ellipsoid.y=this._ellipsoid.y;\n            //anim=this.fall;\n            //check if going up a slope or back on flat ground \n            if((this.avatar.position.y>this.avStartPos.y)||((this.avatar.position.y===this.avStartPos.y)&&(disp.length()>0.001))) {\n                this.endJump();\n            } else if(this.avatar.position.y<this.jumpStartPosY) {\n                //the avatar is below the point from where it started the jump\n                //so it is either in free fall or is sliding along a downward slope\n                //\n                //if the actual displacemnt is same as the desired displacement then AV is in freefall\n                //else it is on a slope\n                let actDisp: Vector3=this.avatar.position.subtract(this.avStartPos);\n                if(!(this.areVectorsEqual(actDisp,disp,0.001))) {\n                    //AV is on slope\n                    //Should AV continue to slide or stop?\n                    //if slope is less steeper than acceptable then stop else slide\n                    if(this.verticalSlope(actDisp)<=this.sl) {\n                        this.endJump();\n                    }\n                }\n            }\n        }\n        return anim;\n    }\n\n    /**\n     * does cleanup at the end of a jump\n     */\n    private endJump() {\n        this.key.jump=false;\n        this.jumpTime=0;\n        this.wasWalking=false;\n        this.wasRunning=false;\n\n    }\n\n    /**\n     * checks if two vectors v1 and v2 are equal within a precision of p\n     */\n    private areVectorsEqual(v1: Vector3,v2: Vector3,p: number) {\n        return ((Math.abs(v1.x-v2.x)<p)&&(Math.abs(v1.y-v2.y)<p)&&(Math.abs(v1.z-v2.z)<p));\n    }\n    /*\n     * returns the slope (in radians) of a vector in the vertical plane\n     */\n    private verticalSlope(v: Vector3): number {\n        return Math.atan(Math.abs(v.y/Math.sqrt(v.x*v.x+v.z*v.z)));\n    }\n\n    //for how long has the av been falling while moving\n    private movFallTime: number=0;\n\n    private doMove(dt: number): AnimData {\n\n        //initial down velocity\n        let u: number=this.movFallTime*this.gravity\n        //calculate the distance by which av should fall down since last frame\n        //assuming it is in freefall\n        this.freeFallDist=u*dt+this.gravity*dt*dt/2;\n\n        this.movFallTime=this.movFallTime+dt;\n\n        let moving: boolean=false;\n        let anim: AnimData=null;\n\n        if(this.inFreeFall) {\n            this.moveVector.y=-this.freeFallDist;\n            moving=true;\n        } else {\n            this.wasWalking=false;\n            this.wasRunning=false;\n\n            if(this.key.forward) {\n                let forwardDist: number=0;\n                if(this.key.shift) {\n                    this.wasRunning=true;\n                    forwardDist=this.runSpeed*dt;\n                    anim=this.run;\n                } else {\n                    this.wasWalking=true;\n                    forwardDist=this.walkSpeed*dt;\n                    anim=this.walk;\n                }\n                this.moveVector=this.avatar.calcMovePOV(0,-this.freeFallDist,forwardDist);\n                moving=true;\n            } else if(this.key.backward) {\n                this.moveVector=this.avatar.calcMovePOV(0,-this.freeFallDist,-(this.backSpeed*dt));\n                anim=this.walkBack;\n                moving=true;\n            } else if(this.key.stepLeft) {\n                anim=this.strafeLeft;\n                this.moveVector=this.avatar.calcMovePOV(-(this.leftSpeed*dt),-this.freeFallDist,0);\n                moving=true;\n            } else if(this.key.stepRight) {\n                anim=this.strafeRight;\n                this.moveVector=this.avatar.calcMovePOV((this.rightSpeed*dt),-this.freeFallDist,0);\n                moving=true;\n            }\n        }\n\n        if(!this.key.stepLeft&&!this.key.stepRight) {\n            if(this.key.turnLeft) {\n                this.camera.alpha=this.camera.alpha+0.022;\n                if(!moving) {\n                    this.avatar.rotation.y=-4.69-this.camera.alpha;\n                    anim=this.turnLeft;\n                }\n            } else if(this.key.turnRight) {\n                this.camera.alpha=this.camera.alpha-0.022;\n                if(!moving) {\n                    this.avatar.rotation.y=-4.69-this.camera.alpha;\n                    anim=this.turnRight;\n                }\n            }\n        }\n\n        if(moving) {\n            this.avatar.rotation.y=-4.69-this.camera.alpha;\n\n            if(this.moveVector.length()>0.001) {\n                this.avatar.moveWithCollisions(this.moveVector);\n                //walking up a slope\n                if(this.avatar.position.y>this.avStartPos.y) {\n                    let actDisp: Vector3=this.avatar.position.subtract(this.avStartPos);\n                    let _sl: number=this.verticalSlope(actDisp);\n                    if(_sl>=this.sl2) {\n                        //this._climbingSteps=true;\n                        //is av trying to go up steps\n                        if(this._stepOffset>0) {\n                            if(this._vMoveTot==0) {\n                                //if just started climbing note down the position\n                                this._vMovStartPos.copyFrom(this.avStartPos);\n                            }\n                            this._vMoveTot=this._vMoveTot+(this.avatar.position.y-this.avStartPos.y);\n                            if(this._vMoveTot>this._stepOffset) {\n                                //move av back to its position at begining of steps\n                                this._vMoveTot=0;\n                                this.avatar.position.copyFrom(this._vMovStartPos);\n                                this.endFreeFall();\n                            }\n                        } else {\n                            //move av back to old position\n                            this.avatar.position.copyFrom(this.avStartPos);\n                            this.endFreeFall();\n                        }\n                    } else {\n                        this._vMoveTot=0;\n                        if(_sl>this.sl) {\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\n                            this.fallFrameCount=0;\n                            this.inFreeFall=false;\n                        } else {\n                            //continue walking\n                            this.endFreeFall();\n                        }\n                    }\n                } else if((this.avatar.position.y)<this.avStartPos.y) {\n                    let actDisp: Vector3=this.avatar.position.subtract(this.avStartPos);\n                    if(!(this.areVectorsEqual(actDisp,this.moveVector,0.001))) {\n                        //AV is on slope\n                        //Should AV continue to slide or walk?\n                        //if slope is less steeper than acceptable then walk else slide\n                        if(this.verticalSlope(actDisp)<=this.sl) {\n                            this.endFreeFall();\n                        } else {\n                            //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\n                            this.fallFrameCount=0;\n                            this.inFreeFall=false;\n                        }\n                    } else {\n                        this.inFreeFall=true;\n                        this.fallFrameCount++;\n                        //AV could be running down a slope which mean freefall,run,frefall run ...\n                        //to remove anim flicker, check if AV has been falling down continously for last few consecutive frames\n                        //before changing to free fall animation\n                        if(this.fallFrameCount>this.fallFrameCountMin) {\n                            anim=this.fall;\n                        }\n                    }\n                } else {\n                    this.endFreeFall();\n                }\n            }\n        }\n        return anim;\n    }\n\n    private endFreeFall(): void {\n        this.movFallTime=0;\n        this.fallFrameCount=0;\n        this.inFreeFall=false;\n    }\n\n    //for how long has the av been falling while idle (not moving)\n    private idleFallTime: number=0;\n    private doIdle(dt: number): AnimData {\n        if(this.grounded) {\n            return this.idle;\n        }\n        this.wasWalking=false;\n        this.wasRunning=false;\n        this.movFallTime=0;\n        let anim: AnimData=this.idle;\n        this.fallFrameCount=0;\n\n\n        if(dt===0) {\n            this.freeFallDist=5;\n        } else {\n            let u: number=this.idleFallTime*this.gravity\n            this.freeFallDist=u*dt+this.gravity*dt*dt/2;\n            this.idleFallTime=this.idleFallTime+dt;\n        }\n        //if displacement is less than 0.01(? need to verify further) then \n        //moveWithDisplacement down against a surface seems to push the AV up by a small amount!!\n        if(this.freeFallDist<0.01) return anim;\n        let disp: Vector3=new Vector3(0,-this.freeFallDist,0);;\n        this.avatar.rotation.y=-4.69-this.camera.alpha;\n        this.avatar.moveWithCollisions(disp);\n        if((this.avatar.position.y>this.avStartPos.y)||(this.avatar.position.y===this.avStartPos.y)) {\n            //                this.grounded = true;\n            //                this.idleFallTime = 0;\n            this.groundIt();\n        } else if(this.avatar.position.y<this.avStartPos.y) {\n            //AV is going down. \n            //AV is either in free fall or is sliding along a downward slope\n            //\n            //if the actual displacemnt is same as the desired displacement then AV is in freefall\n            //else it is on a slope\n            let actDisp: Vector3=this.avatar.position.subtract(this.avStartPos);\n            if(!(this.areVectorsEqual(actDisp,disp,0.001))) {\n                //AV is on slope\n                //Should AV continue to slide or stop?\n                //if slope is less steeper than accebtable then stop else slide\n                if(this.verticalSlope(actDisp)<=this.sl) {\n                    //                        this.grounded = true;\n                    //                        this.idleFallTime = 0;\n                    this.groundIt();\n                    this.avatar.position.copyFrom(this.avStartPos);\n                } else {\n                    this.unGroundIt();\n                    anim=this.slideBack;\n                }\n            }\n        }\n        return anim;\n    }\n\n    private groundFrameCount=0;\n    private groundFrameMax=10;\n    /**\n     * donot ground immediately\n     * wait few more frames\n     */\n    private groundIt(): void {\n        this.groundFrameCount++;\n        if(this.groundFrameCount>this.groundFrameMax) {\n            this.grounded=true;\n            this.idleFallTime=0;\n        }\n    }\n    private unGroundIt() {\n        this.grounded=false;\n        this.groundFrameCount=0;\n    }\n\n    savedCameraCollision: boolean=true;\n    private updateTargetValue() {\n        //donot move camera if av is trying to clinb steps\n        if(this._vMoveTot==0)\n            this.avatar.position.addToRef(this.cameraTarget,this.camera.target);\n\n        if(this.camera.radius>this.camera.lowerRadiusLimit) {if(this.elasticCamera) this.snapCamera();}\n\n        if(this.camera.radius<=this.camera.lowerRadiusLimit) {\n            if(!this.noFirstPerson) {\n                this.avatar.visibility=0;\n                this.camera.checkCollisions=false;\n            }\n        } else {\n            this.avatar.visibility=1;\n            this.camera.checkCollisions=this.savedCameraCollision;\n        }\n    }\n\n    ray: Ray=new Ray(Vector3.Zero(),Vector3.One(),1);\n    rayDir: Vector3=Vector3.Zero();\n    //camera seems to get stuck into things\n    //should move camera away from things by a value of cameraSkin\n    cameraSkin: number=0.5;\n    skip: number=0;\n    private snapCamera() {\n        //            if(this.skip<120) {\n        //                this.skip++;\n        //                return;\n        //            }\n        //            this.skip=0;\n        //get vector from av (camera.target) to camera\n        this.camera.position.subtractToRef(this.camera.target,this.rayDir);\n        //start ray from av to camera\n        this.ray.origin=this.camera.target;\n        this.ray.length=this.rayDir.length();\n        this.ray.direction=this.rayDir.normalize();\n\n        let pi: PickingInfo=this.scene.pickWithRay(this.ray,(mesh) => {\n            //if(mesh==this.avatar||!mesh.isPickable||!mesh.checkCollisions) return false;\n            if(mesh==this.avatar||!mesh.checkCollisions) return false;\n            else return true;\n        },true);\n\n        if(pi.hit) {\n            //postion the camera in front of the mesh that is obstructing camera\n            if(this.camera.checkCollisions) {\n                let newPos: Vector3=this.camera.target.subtract(pi.pickedPoint).normalize().scale(this.cameraSkin);\n                pi.pickedPoint.addToRef(newPos,this.camera.position);\n            } else {\n                let nr: number=pi.pickedPoint.subtract(this.camera.target).length();\n                this.camera.radius=nr-this.cameraSkin;\n            }\n        }\n    }\n\n    move: boolean=false;\n    public anyMovement(): boolean {\n        return (this.key.forward||this.key.backward||this.key.turnLeft||this.key.turnRight||this.key.stepLeft||this.key.stepRight);\n    }\n\n    private onKeyDown(e: Event) {\n        var event: KeyboardEvent=<KeyboardEvent>e;\n        var code: number=event.keyCode;\n        var chr: string=String.fromCharCode(code);\n\n        if((chr===this.jumpKey)||(code===this.jumpCode)) this.key.jump=true;\n        else if(code===16) this.key.shift=true;\n        //WASD or arrow keys\n        else if((chr===this.walkKey)||(code===this.walkCode)) this.key.forward=true;\n        else if((chr===this.turnLeftKey)||(code===this.turnLeftCode)) this.key.turnLeft=true;\n        else if((chr===this.turnRightKey)||(code===this.turnRightCode)) this.key.turnRight=true;\n        else if((chr===this.walkBackKey)||(code===this.walkBackCode)) this.key.backward=true;\n        else if((chr===this.strafeLeftKey)||(code===this.strafeLeftCode)) this.key.stepLeft=true;\n        else if((chr===this.strafeRightKey)||(code===this.strafeRightCode)) this.key.stepRight=true;\n        this.move=this.anyMovement();\n    }\n\n    private onKeyUp(e: Event) {\n        var event: KeyboardEvent=<KeyboardEvent>e;\n        var code: number=event.keyCode;\n        var chr: string=String.fromCharCode(code);\n\n        if(code===16) {this.key.shift=false;}\n        //WASD or arrow keys\n        else if((chr===this.walkKey)||(code===this.walkCode)) this.key.forward=false;\n        else if((chr===this.turnLeftKey)||(code===this.turnLeftCode)) this.key.turnLeft=false;\n        else if((chr===this.turnRightKey)||(code===this.turnRightCode)) this.key.turnRight=false;\n        else if((chr===this.walkBackKey)||(code===this.walkBackCode)) this.key.backward=false;\n        else if((chr===this.strafeLeftKey)||(code===this.strafeLeftCode)) this.key.stepLeft=false;\n        else if((chr===this.strafeRightKey)||(code===this.strafeRightCode)) this.key.stepRight=false;\n\n        this.move=this.anyMovement();\n    }\n}\n\nexport class AnimData {\n    public name: string;\n    public loop: boolean=true;\n    public rate: number=1;\n    public exist: boolean=false;\n\n    public constructor(name: string) {\n        this.name=name;\n    }\n}\n\nexport class Key {\n    public forward: boolean;\n    public backward: boolean;\n    public turnRight: boolean;\n    public turnLeft: boolean;\n    public stepRight: boolean;\n    public stepLeft: boolean;\n    public jump: boolean;\n    public shift: boolean;\n\n    constructor() {\n        this.reset();\n    }\n\n    reset() {\n        this.forward=false;\n        this.backward=false;\n        this.turnRight=false;\n        this.turnLeft=false;\n        this.stepRight=false;\n        this.stepLeft=false;\n        this.jump=false;\n        this.shift=false;\n    }\n\n}\n\n\n\n\n"],"sourceRoot":""}